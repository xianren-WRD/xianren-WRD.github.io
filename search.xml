<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CANoe 使用问题汇总</title>
    <url>/2023/CANoe-Usage-5b23d9c22076/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>记录日常工作中使用CANoe遇到的问题的解决方法。</p>
<h1 id="CANoe安装"><a href="#CANoe安装" class="headerlink" title="CANoe安装"></a>CANoe安装</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECREPAIR: Failed to open the file:E:\CANoe11.0 SP3\canoe\Files\2d2d758a-571d-4239-ba27-ceca9435a110\Data1.cab for computing its hash. Error:2</span><br><span class="line">SECUREREPAIR: Failed to CreateContentHash of the file: Data1.cab: for computing its hash. Error: 2</span><br></pre></td></tr></table></figure>

<p>之前在公司安装CANoe 11时，出现了错误，导致安装进行不下去。通过上面的错误提示，在查看本地电脑的路径后，可以大致看出问题出现是因为少了一个文件夹。在官网下载对应的SP4升级包后，能够找到缺失的文件夹。由此可以推断，公司放在共享盘的安装包是有问题的。于是，选择使用官方的升级包进行安装，最终安装成功。</p>
<h1 id="J1939-Options"><a href="#J1939-Options" class="headerlink" title="J1939 Options"></a>J1939 Options</h1><p>由于缺少相应的License，无法使用 J1939 Options 插件。因此，在导入J1939的DBC后，启动CANoe时出错，提示<code>Required bus system options: J1939 (missing)</code>，详见下图。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812173933.png" alt="J1939 Option.png"></p>
<p>对策方法是禁用DBC的J1939功能，也就是修改DBC的Networks属性，将ProtocolType这个属性的值删除&#x2F;置空即可，详见下图。注意，该操作是不可逆的，如有需要，可以先将原始文件备份一下。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812173949.png" alt="Disable J1939 Func.png"></p>
<h1 id="Graphics"><a href="#Graphics" class="headerlink" title="Graphics"></a>Graphics</h1><p>在CANoe的Graphics窗口，修改左边图例的Name，只是相应修改了右边坐标轴显示的名字，实际解析的信号和Name无关，不会因为Name的改变而改变。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812175128.png" alt="Graphics.png"></p>
<h1 id="报文回放"><a href="#报文回放" class="headerlink" title="报文回放"></a>报文回放</h1><p>PCAN导出的trc格式的报文，经过PEAK-Converter转换成asc格式之后，不能直接导入CANoe回放。但是，可以先拖到CANoe Trace窗口里面，右键导出保存为blf格式，然后再回放。</p>
<h1 id="CAPL"><a href="#CAPL" class="headerlink" title="CAPL"></a>CAPL</h1><h2 id="加密问题"><a href="#加密问题" class="headerlink" title="加密问题"></a>加密问题</h2><p>在工作中，有时候需要将CANoe工程外发，如果不想让别人查看我们编写的CAPL源码，那么这个时候就可以通过CAPL Browser的加密功能对源码进行加密。具体如何加密，网上已经有了很多教程。这里主要想说的是，之前在工作中发现：</p>
<ul>
<li><p>CANoe 10.0加密CAPL后，在Simulation Setup界面右键编辑ECU节点，会自动生成一个与加密前的CAPL源文件同名的文件，但是文件内容是空的。这样会导致后续再启动CANoe会出问题，ECU节点的CAPL不起作用了，不符合我们的预期；</p>
</li>
<li><p>CANoe 11.0加密则不同，同样去编辑节点会弹框提示已加密，并不会生成文件，后续再启动CANoe工程，所有的功能和加密前的一样，符合预期。</p>
</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>依次点击<code>CANoe Options--General--License</code>，即可设置，在打开CANoe时，显示license检查对话框。</p>
]]></content>
      <categories>
        <category>CAN总线工具</category>
      </categories>
      <tags>
        <tag>CANoe</tag>
      </tags>
  </entry>
  <entry>
    <title>J1939设计注意点</title>
    <url>/2025/prefix%20remember%20to%20change!!!-9a9c4e5c1e4f/</url>
    <content><![CDATA[<h1 id="需求规范检查"><a href="#需求规范检查" class="headerlink" title="需求规范检查"></a>需求规范检查</h1><h2 id="标准规范"><a href="#标准规范" class="headerlink" title="标准规范"></a>标准规范</h2><p><strong>OSI层级</strong></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013203758.png"></p>
<table>
<thead>
<tr>
<th align="left">规范类别</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">J1939-Year</td>
<td>Year指特定的版本，比如：J1939-2005。描述了网络的概况 、OSI分层结构、下属文档结构，并为所有预分配的值和名称提供管控。</td>
</tr>
<tr>
<td align="left">J1939-0x</td>
<td>⼀个应用文档，其中 x 指代网络的特定网络&#x2F;应用版本。该文档将说明其适用的行业或应用，并列出了构成此网络的各层的具体版本。 <br/>• J1939&#x2F;01: 卡车和客车控制与通信网络 (Truck and Bus Control and Communications Network)。<br/>• J1939&#x2F;02 (草案): 农业设备控制与通信网络 (Agricultural Equipment Control and Communications Network)。</td>
</tr>
<tr>
<td align="left">J1939-1x</td>
<td>物理层文档，其中 x 指特定的物理层不同内容。<br/>• J1939&#x2F;11：物理层，250K 比特&#x2F;秒，屏蔽双绞线。<br/>• J1939&#x2F;16：自动选择波特率<br/>• J1939&#x2F;17：CAN FD-500 kbit&#x2F;s | 2 Mbit&#x2F;s</td>
</tr>
<tr>
<td align="left">J1939-2x</td>
<td>详细规定数据链路层的具体实现。<br/>• J1939&#x2F;21：Data Link Layer on Classic CAN<br/>• J1939&#x2F;22：Data Link Layer on CAN FD</td>
</tr>
<tr>
<td align="left">J1939-31</td>
<td>网络层：定义了在更复杂的网络拓扑中（如多个网段通过网桥&#x2F;网关连接）如何路由J1939消息</td>
</tr>
<tr>
<td align="left">J1939-7x</td>
<td>应用层文档，其中 x 指代应用层的特定版本。<br/>• 1939&#x2F;71: 车辆应用层。定义了车辆中各种具体功能所需的数据参数、消息（PGN）及其格式、语义和传输要求。<br/>• J1939&#x2F;73: 应用层 - 诊断</td>
</tr>
<tr>
<td align="left">J1939-81</td>
<td>网络管理 - 地址配置与参数配置</td>
</tr>
</tbody></table>
<h2 id="客户规范"><a href="#客户规范" class="headerlink" title="客户规范"></a>客户规范</h2><ul>
<li><p>明确客户参考的标准规范版本 ，OEM规范引用的J1939⼀般都很旧</p>
</li>
<li><p>明确实施J1939规范的适用内容&#x2F;范围，定义在OEM规范</p>
</li>
<li><p>确认Vector协议栈⽀持的OEM规范和J1939版本及对应的OEM功能</p>
</li>
</ul>
<h1 id="SAE分层设计考虑"><a href="#SAE分层设计考虑" class="headerlink" title="SAE分层设计考虑"></a>SAE分层设计考虑</h1><h2 id="J1939-11"><a href="#J1939-11" class="headerlink" title="J1939-11"></a>J1939-11</h2><p>规定了最常用的J1939物理层实现标准。</p>
<ul>
<li>关键点： 基于ISO 11898-2 (高速CAN) 的电气特性（电压电平、阻抗、终端电阻）、电缆要求（屏蔽双绞线）、连接器（推荐9针Deutsch DT或等效）、总线拓扑（主干线-支线结构）、最大线缆长度（40米 250kbps）、通信速率（250 kbps）。</li>
</ul>
<p><strong><mark>设计考虑</mark></strong></p>
<ol>
<li>需要考虑波特率和采样点的配置。</li>
</ol>
<h2 id="J1939-16"><a href="#J1939-16" class="headerlink" title="J1939-16"></a>J1939-16</h2><p>介绍了车辆通信网络中自动波特率检测的流程。该流程使网络设备能够自动识别并适应 SAE J1939- 11、SAE J1939-14 或 SAE J1939-15 物理层标准所指定的 CAN 经典网络的通信速率（波特率）。</p>
<p>其核心目的是实现设备间无需预先配置波特率即可互联互通，从而提升通信的灵活性和效率，并最大限度地减少或消除因波特率不匹配对现有网络设备造成的通信中断。</p>
<p>标准里面提到两种实现，大致如下：</p>
<ul>
<li><p>设置某个波特率，如果发送报文时，检测到总线上有错误，⼀段时间后切到另⼀个波特率，重复这个过程。</p>
</li>
<li><p>CAN控制器设置为监听模式，只接收，不发送报文，如果检测到总线上有错误，⼀段时间后切到另⼀个波特率，重复这个过程。</p>
</li>
</ul>
<p><strong><mark>设计考虑</mark></strong></p>
<ol>
<li>需要明确的是，此流程仅适用于使用ISO 11898-1:2015 定义的经典基本帧格式 (CBFF) 和经典扩展帧格式 (CEFF) 数据帧的 CAN 经典网络。基于 SAE J1939-17 物理层（唯⼀⽀持的 SAE J1939 CAN FD 物理层选项）的 SAE J1939 CAN FD 网络不在此流程适用范围内，因为该标准仅指定了⼀种波特率组合（500 kbit&#x2F;s 仲裁段+2000 kbit&#x2F;s 数据段）。</li>
</ol>
<h2 id="J1939-21"><a href="#J1939-21" class="headerlink" title="J1939-21"></a>J1939-21</h2><p>详细规定了J1939协议栈中数据链路层的具体实现。定义了数据如何在物理层之上可靠地打包、寻址、传输和接收，是通信可靠性的核心保障。</p>
<h3 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h3><p>协议数据单元PDU格式：优先级、保留位、数据页、PDU格式PF、PDU特定PS、源地址SA。 </p>
<p><strong>PGN的定义</strong></p>
<p>PGN是24位，⼀共三个字节，第⼀个字节高六位都是0填充。PGN是唯⼀的。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013210628.png"></p>
<p><strong>PDU的详细解析规则</strong></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013210755.png"></p>
<p>扩展CAN ID是29位标识符，各部分含义如下：</p>
<table>
<thead>
<tr>
<th>CAN ID域</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>P</td>
<td>优先级。用来优化报文延迟，所有控制报文缺省优先级是3。其他所有报文、专用、请求和ACK 报文的缺省优先级是6。</td>
</tr>
<tr>
<td>EDP</td>
<td>扩展数据页</td>
</tr>
<tr>
<td>DP</td>
<td>数据页</td>
</tr>
<tr>
<td>PF</td>
<td>PDU格式段（0-239：PDU1格式；240-255：PDU2格式）</td>
</tr>
<tr>
<td>PS</td>
<td>PDU特定域（PDU1格式：DA 目的地址；PDU2格式：GE 群扩展）</td>
</tr>
<tr>
<td>SA</td>
<td>源地址。网络中⼀个特定源地址只能匹配⼀个设备</td>
</tr>
</tbody></table>
<p><strong>CanId解析举例</strong></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013211018.png"></p>
<p><strong><mark>设计考虑</mark></strong></p>
<p>需要检查AUTOSAR过滤器的配置，包括<u>硬件过滤（Can）和软件过滤（CanIf）</u>。</p>
<p>目前购买的vector AUTOSAR的硬件过滤会自动mask掉优先级，要自己检查filter是否正确，并且在实际项目还是需要自测不同优先级是否能接收。</p>
<p>确保：</p>
<p><strong>PDU2格式和PDU1格式</strong></p>
<ul>
<li><p>相同PGN和相同SA，不同优先级，能被正常接收（即，优先级位必须被接收器屏蔽）。</p>
</li>
<li><p>相同PGN和不同SA，不同优先级，是否要被正常接收取决于客户需求。比如：DAF要求源地址位不应被接收器屏蔽。（其他国内有遇到过，不同车型会发送不同的SA，通过PGN区分）-&gt; 确认vector是否支持mask SA</p>
</li>
</ul>
<p>如果不同的SA要被支持，硬件过滤需要mask SA！</p>
<p><strong>PDU1格式特有</strong></p>
<ul>
<li>相同PGN，不同优先级，只接收报文DA与自己DA⼀致的报文。</li>
</ul>
<p><strong>UDS DTC</strong></p>
<p>DTC timeout检测要考虑mask优先级，避免DBC定义之外的报文优先级没有考虑，导致误报</p>
<p>timeout DTC；</p>
<h3 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h3><p>多包报文在连接管理报文（TP.CM）的协调下进行多帧传输。它可再细分为两个主要功能：消息的拆装和重组； 和连接管理。</p>
<p>连接管理是用于处理在特定目标地址传输时，节点间虚拟连接的打开、使用和关闭。虚拟连接，是指在 SAE J1939 的网络环境中，为了传送⼀条由⼀个单独的PGN描述的长消息，在两个节点间建立的临时连接。</p>
<p>在连接是⼀点到多点的情况下(广播)，不提供数据流控制和关闭的管理功能。</p>
<p><strong>广播BAM</strong></p>
<p>TP.CM_BAM和TP.DT。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013213749.png"></p>
<p><strong>RTS&#x2F;CTS</strong></p>
<p>TP.CM_RTS和TP.CM_CTS。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013213842.png"></p>
<p>需要注意：RTS&#x2F;CTS是有错误处理和重传机制的。</p>
<p><strong><mark>设计考虑</mark></strong></p>
<ul>
<li><p>需要考虑数据包DT的传输间隔，默认是50ms。</p>
</li>
<li><p>⼀些特定的报文当它们≤ 8 个字节时，会使用非TP的形式来发送，而当它们＞8个字节时，则使用TP的形式来发送。这两种形式可能同时进行发送。</p>
</li>
<li><p>PGN TP形式长数据正在发送(使用TP PGN)，此时PGN的数据长度更新为≤ 8 个字节需要非TP形式发送(本身报文的PGN)，非TP形式不能打断前面的TP发送，理论上因为使用不同的PGN在发送，所以无影响。但是需要考虑这种发送是否会影响到应用逻辑或时序。比如应用先发送长数据，再发送短数据，接收端可能会先收到短数据，再收到长数据！</p>
</li>
<li><p>发送&gt;1785字节数据，验证：发送端是否拒绝；接收端是否丢弃并报错。</p>
</li>
</ul>
<h3 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h3><p>J1939⽀持五种类型的报文，分别为：命令、请求、广播&#x2F;响应、确认和群扩展。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013214226.png"></p>
<ol>
<li><p>命令报文：从某个源地址向特定目标地址或全局目标地址发送命令的参数组。PDU1 格式和PDU2格式都能用作命令。命令类型的消息可能包括传动控制、地址请求、扭矩&#x2F;速度控制等等。</p>
</li>
<li><p>请求报文：从全局范围或从特定目标地址请求信息。最典型的⼀个报文是请求PGN报文。</p>
</li>
<li><p>广播&#x2F;响应报文：此消息类型可能是某设备主动提供的消息广播，也可能是命令或请求的响应，总线上的数据交换大多采用这类报文。</p>
</li>
<li><p>确认报文：对于特定命令、请求的“普通广播”或“ACK” 或“NACK”响应。</p>
</li>
<li><p>群扩展：这种类型报文用于⼀组特殊功能(如专用功能、网络管理功能、多包传输功能等)。</p>
</li>
</ol>
<p><strong><mark>设计考虑</mark></strong></p>
<p>确认DaVinci中五种报文的PGN范围配置正确（如命令PGN: 0-57343，请求PGN: 59904）。</p>
<p>对于请求报文：</p>
<ul>
<li>根据需求，在DaVinci中注册本节点需要响应的PGN列表，避免响应非法PGN请求。如果发送未注册PGN的请求，需要返回NACK。对于要支持的PGN需要勾选，默认发送的都需要：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013214834.png"></p>
<ul>
<li><p>仅对点对点请求发送ACK（校验目标地址DA 匹配本机地址），全局广播报文不响应ACK(vector协议栈已处理)。</p>
</li>
<li><p>需要考虑ACK超时时间（默认200ms），实现重传机制（≤3次），vector可配置。</p>
</li>
<li><p>请求发送需要管理⼀个队列，队列大小需要确保所有需要发送的确认PG都可以按照顺序排队等待发送，vector可配置。</p>
</li>
</ul>
<h2 id="J1939-31"><a href="#J1939-31" class="headerlink" title="J1939-31"></a>J1939-31</h2><p>定义了在更复杂的网络拓扑中（如多个网段通过网桥&#x2F;网关连接）如何路由J1939消息。</p>
<ul>
<li><p>关键点：网桥&#x2F;网关的功能要求、网络分段原则、基于目标地址的路由规则、报文过滤、地址管理（网桥自身的地址声明）、网络层协议NLP（用于网桥间通信）。</p>
</li>
<li><p>重要性：使J1939网络能够扩展到大型或复杂的车辆架构（如带挂车的牵引车、大型工程机械），实现不同网段间的通信。</p>
</li>
</ul>
<p>仅适用于旨在提供网络服务的 ECU。</p>
<h2 id="J1939-71"><a href="#J1939-71" class="headerlink" title="J1939-71"></a>J1939-71</h2><p>定义了车辆中各种具体功能所需的数据参数、消息（PGN）及其格式、语义和传输要求。</p>
<ul>
<li><p>关键点： 包含海量的标准PGN定义（如发动机转速、车速、油压、故障码DTC、巡航控制状态、变速箱档位等）、每个PGN包含哪些SPN（具体参数）、每个SPN的数据长度、分辨率、偏移量、单位、范围、数据更新周期或传输触发条件。这是内容最庞大且不断更新的部分。</p>
</li>
<li><p>重要性： 规定了车辆各ECU之间交换的具体数据内容及其含义，是实现互操作性的关键。仪表显示、控制逻辑、诊断信息都依赖于此。</p>
</li>
</ul>
<p>SAE J1939 的报文格式使用PGN作为⼀组参数的标号。⼀组参数称为“参数组”，PGN是其唯⼀的标识号。参数组内有⼀个或多个具体的参数，每个具体参数都有⼀个唯⼀的标号，称为“可疑参数编号”，即SPN。PGN类似于报文ID，SPN则类似于信号ID。</p>
<h3 id="信号参数值范围"><a href="#信号参数值范围" class="headerlink" title="信号参数值范围"></a>信号参数值范围</h3><p>标准的参数值范围定义如下，包括：有效值，错误值，无效值等。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013215516.png"></p>
<h3 id="标准PGN定义"><a href="#标准PGN定义" class="headerlink" title="标准PGN定义"></a>标准PGN定义</h3><p>有些时候客户只提供某个具体的PGN&#x2F;SPN，而不提供信号的layout以及属性定义。</p>
<p>如果PGN是标准PGN（不属于自定义PGN范围）的情况下，我们就可以在 J1939.dbc 里面找到对应的layout定义。</p>
<p>注意： J1939.dbc 在安装CANoe的时候就会携带，或者在SIP包里面也可以找到。查看J1939网络的属性，可以看到引用的版本。也可以在J1939-Year的规范里面找到标准PGN定义。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013215710.png"></p>
<h3 id="自定义报文原则"><a href="#自定义报文原则" class="headerlink" title="自定义报文原则"></a>自定义报文原则</h3><p>自定义报文通过选定SAE J1939协议中预留的PDU2格式中的“<u>私有(专用)B段</u>”，即 PF&#x3D;255， PS&#x3D;0~255 来编制PGN。</p>
<p>参数组定义的原则：</p>
<ol>
<li><p>按照参数的功能分组而不是按照参数的类型分组</p>
</li>
<li><p>按照参数的刷新频率分组</p>
</li>
<li><p>按照参数所属的子系统</p>
</li>
</ol>
<p>所以，同⼀子系统的相同功能的刷新率接近的若干参数可以构成⼀个参数组。</p>
<p>SPN选择SAE J1939 在预留段 520192~524287 中定义，并从520192开始顺序地为每个参数分配SPN。</p>
<h2 id="J1939-73"><a href="#J1939-73" class="headerlink" title="J1939-73"></a>J1939-73</h2><p>定义车辆诊断相关的消息、参数和流程。在商用车网络设计领域，诊断常用组合如下：J1939-73的DM报文或DM1报文+UDS的组合。</p>
<p>关键内容：</p>
<ol>
<li><p>诊断故障码 (DTC - Diagnostic Trouble Code)：</p>
<ul>
<li><p>定义了 DTC 的结构：由 SPN (可疑参数编号) + FMI (故障模式标识符) + OC (发生次数) 组成。</p>
</li>
<li><p>规定了如何报告、存储和清除 DTC。</p>
</li>
</ul>
</li>
<li><p>诊断消息 (Diagnostic Messages - DM)：</p>
<ul>
<li><p>提供了⼀系列标准化的 PGN (参数组编号) 用于诊断通信：</p>
<ul>
<li><p>DM1: 报告当前检测到并激活的故障。</p>
</li>
<li><p>DM13: 停止&#x2F;启动广播消息 (比如DM1)。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="DM1"><a href="#DM1" class="headerlink" title="DM1"></a>DM1</h3><p>作用：报告当前检测到并激活的故障。</p>
<p><strong>发送方式</strong></p>
<ul>
<li><p>故障首次激活（持续 ≥ 1秒）：</p>
<ul>
<li><p>⼀旦某个 DTC 从“不激活”变成“激活”状态，并且这个激活状态持续了 1 秒或更⻓时间，ECU 会立即开始传输 DM1 报文。</p>
</li>
<li><p>之后，只要该故障（或其它故障）仍处于激活状态，DM1 报文就以每秒⼀次的速率持续更新。</p>
</li>
</ul>
</li>
<li><p>故障从不激活变为激活（短于1秒）：</p>
<ul>
<li>如果故障激活的时间非常短（少于 1 秒），然后立刻又变回不激活，这种情况可能不会触发⼀次单独的 DM1 传输来报告“激活”，因为它没有持续到触发传输的最小时间（1秒）。</li>
</ul>
</li>
<li><p>故障从激活变为不激活：</p>
<ul>
<li>如果⼀个激活状态持续了 1 秒或更长的故障，随后变为不激活状态，那么 ECU 必须在状态改变后的下⼀个传输机会（即下⼀次正常的每秒更新点）发送⼀个新的 DM1 报文，以表明这个DTC 不再处于激活状态。</li>
</ul>
</li>
<li><p>同⼀秒内发生多次状态变化（防抖&#x2F;限流）：（DM1本身是固定1S周期，本身就已经防抖）</p>
<ul>
<li><p>为了防止某个 DTC 在极短时间内（比如 1 秒内）反复在激活和不激活状态之间快速切换，导致DM1 报文发送过于频繁（高传输率），引入了⼀个限制规则：每个 DTC 每秒最多只报告⼀次状态改变。</p>
</li>
<li><p>具体处理：</p>
<ul>
<li><p>如果某个 DTC 在 1 秒内发生了两次状态改变（例如：先激活，然后在不激活），ECU 会：</p>
<ol>
<li><p>在检测到第⼀次状态改变（激活） 后的下⼀个传输机会（T1 时刻）发送 DM1，报告该DTC为激活状态。</p>
</li>
<li><p>在下⼀秒的传输机会（T2 时刻），再发送⼀个 DM1，报告该 DTC 为不激活状态。</p>
</li>
</ol>
</li>
<li><p>这样，无论 1 秒内实际状态切换了多少次，对于网络来说，每个 DTC 每秒最多只看到⼀次状态变化报告（要么激活，要么不激活），降低了传输负载。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>无激活故障时不主动发送：</p>
<ul>
<li><p>当没有任何 DTC 处于激活状态时，ECU 不会主动发送 DM1 报文。</p>
</li>
<li><p>例外：当诊断工具主动请求 DM1 信息时，即使没有激活故障，ECU 也必须响应这个请求并发送 DM1 报文（通常报告无激活故障或包含历史故障信息）。</p>
</li>
</ul>
</li>
<li><p>多故障处理（多包传输）：</p>
<ul>
<li><p>如果同时有多个激活的 DTC 需要报告，单个标准的 DM1 报文无法容纳所有信息。</p>
</li>
<li><p>此时，ECU 必须使用 “多包传输” 机制（例如 J1939 的传输协议功能 TP，使用 BAM ）。这意味着 DM1 的信息会被拆分成多个数据包（帧）在总线上传输。</p>
</li>
</ul>
</li>
</ul>
<p><mark><strong>设计考虑</strong></mark></p>
<p>UDS 28服务不能关闭DM1，DM1不在BSWM规则里面控制，DM1只受控于DM13控制。</p>
<p>BSWM的 J1939规则，只判断网络状态，控制整个J1939 DCM和J1939 RM模块通信。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013222021.png"></p>
<h3 id="DM13"><a href="#DM13" class="headerlink" title="DM13"></a>DM13</h3><p>停止&#x2F;启动广播消息 (比如DM1)。每当需要停止或开始广播事件时发送。</p>
<p><strong><mark>设计考虑</mark></strong></p>
<p>需要确认DM13影响的bus类型。一般，只需要支持current data link。</p>
<p>Autosar配置必须要选择⼀种，下图选择NETWORK_1，所以最终current data link(AUTOSAR没有选项，静态代码默认支持)或NETWORK_1都会生效：</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013222345.png"></p>
<h4 id="Hold-signal"><a href="#Hold-signal" class="headerlink" title="Hold signal"></a>Hold signal</h4><p>指示所有节点，DM13操作过的通信端口保持在修改状态。为了维持车辆网络的修改状态，保持信号必须每5秒广播⼀次，允许±1s的误差。请求停止广播的设备必须每5秒发送⼀次保持信号，如果在6秒内未收到该消息，则所有相关节点将恢复到其正常状态。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013222602.png"></p>
<p>保持信号允许DM13消息的发送者不必将DM13发送到特定地址，而是发送给已修改的控制器组或所有设备。这减少了需要发送的消息数量，从而使每个单独控制器的修改广播状态保持有效。</p>
<h4 id="Suspend-signal"><a href="#Suspend-signal" class="headerlink" title="Suspend signal"></a>Suspend signal</h4><p>向所有节点发出指示，当前J1939数据链路上的广播消息由于除了J1939 DM13之外的命令（比如： UDS 28）而被暂停。因此，接收节点应暂停对来自发送设备的所有消息的超时诊断。</p>
<p>暂停信号应广播⼀次，但发送设备可以选择重复发送（如果其具备该能力），以增加正确接收的机会，可以在暂停的第⼀秒内重复发送⼀到两次。如果发送设备发送⼀条将暂停信号设置为“1110”的DM13消息，则指示其正在恢复到完整的广播状态。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013222851.png"></p>
<p><strong><mark>设计考虑</mark></strong></p>
<p>Vector AUTOSAR包不支持suspend signal配置，静态代码也没有。</p>
<p>因为这个规范已经过时，目前接触的项目不要求实施，可以和客户确认是否需要实施。</p>
<h2 id="J1939-81"><a href="#J1939-81" class="headerlink" title="J1939-81"></a>J1939-81</h2><p>定义了如何为ECU分配网络地址以及如何配置ECU内部参数的标准化方法。不定义网络唤醒和休眠，网络管理机制采用OSEK或AUTOSAR NM。</p>
<ul>
<li><p>关键点：地址配置协议（通过专用工具或特定ECU）、参数配置协议（读取&#x2F;写入配置参数）、服务工具到ECU的通信机制。</p>
</li>
<li><p>重要性：简化了车辆生产线上ECU的初始化和维修过程中的ECU更换、参数调整，确保ECU能在网络上正确工作（获得地址）并按需设置（如车辆VIN号、轮胎尺寸、后桥速比等）</p>
</li>
</ul>
<p>控制器应用程序（CA）的基本概念：控制器由硬件和软件组成，其中软件叫作CA。⼀个ECU可以有多个CA，每个CA都有可以唯⼀识别的名字（称为CA NAME）和地址。</p>
<h3 id="地址的配置和作用"><a href="#地址的配置和作用" class="headerlink" title="地址的配置和作用"></a>地址的配置和作用</h3><p>地址的配置，定义了⼀个 ECU如何获得并保留它的源地址。地址配置与地址声明程序不同，后者是 ECU 想要使用某个地址时进行广播声明的程序。有四种不同地址配置可供 ECU使用。</p>
<ul>
<li><p>Non-Configurable Address CA&#x2F;固定地址配置</p>
<p>不可配置地址的ECU，是指那些已由OEM提供了源地址的ECU。在地址域中，包括服务工具在内的任何方法都不可改变它的地址。</p>
</li>
<li><p>Service Configurable Address CA&#x2F;服务可配置地址</p>
<p>可由维护人员配置地址的ECU，是指那些在地址域中源地址可以由维护的技术人员进行更改的ECU。这种 ECU 的 CA 可以在车辆下线时或维修时，使用外部的诊断工具（Service Tool） 通过 J1939 定义的诊断服务（通常是 DM15 - DTC Configuration，或者 DM16 - Binary Data Transfer）来进行更改或配置。</p>
<p>地址更改机制：</p>
<ul>
<li><p>需要离线或在特定配置模式下进行（通常车辆点火开关在 OFF 或 ACC 状态）。</p>
</li>
<li><p>诊断工具发送特定的 J1939 诊断服务报文到 ECU。</p>
</li>
<li><p>ECU 接收并验证请求后，将新的值存储到非易失性存储器（NVRAM）中。</p>
</li>
<li><p>下次启动时，ECU 使用新配置的值。</p>
</li>
</ul>
</li>
<li><p>Command Configurable Address CA&#x2F;J1939 Command修改地址</p>
<p>命令配置地址的ECU，是指那些在正常操作模式（相对于维护操作模式）下，可以通过命令地址报文（ PGN 65240 (0xFEC8)）来更改源地址的ECU。在上电时改变地址，不需要服务工具或者运行于特殊模式。实现运行时、自动化的地址分配和冲突解决，无需人工干预或诊断工具。</p>
<p>地址更改机制：</p>
<ul>
<li><p>⼀个具有地址分配权限的 ECU在网络上广播 Commanded Address 消息。</p>
</li>
<li><p>消息指定目标 ECU 的 NAME 和要分配给它的新 CA。</p>
</li>
<li><p>目标 ECU 接收到该命令（匹配其 NAME），验证命令合法性后，立即或在下⼀个启动周期使用新的 CA。</p>
</li>
<li><p>更改通常需要存储到 NVRAM。</p>
</li>
</ul>
</li>
<li><p>Self-Configurable Address CA&#x2F;动态地址配置</p>
<p>可自配置地址的ECU，是指那些根据内部计算确定它的源地址并自己声明该地址的ECU。如果可自配置地址的ECU在声明第⼀个计算出来的地址时失败，那么ECU会重新计算并声明另⼀地址。实现 ECU的“即插即用”，最大程度减少人工配置需求。ECU 自己负责在网络上找到⼀个不冲突的地址。</p>
<p>地址更改机制：</p>
<ul>
<li><p>ECU 启动时，检查其存储的 CA。</p>
</li>
<li><p>如果无效或冲突，它广播 Request for Address Claim (PGN 59904 &#x2F; 0xEA00) 或直接参与 Address Claim 过程。</p>
</li>
<li><p>在 Address Claim 过程中，ECU 广播其 NAME 和它希望使用的 CA（通常是之前存储的或⼀个默认值）。</p>
</li>
<li><p>如果发生冲突（有另⼀个 ECU 声明了相同 CA 且 NAME 优先级更高），该 ECU 会尝试选择另⼀个 CA，并重新声明，直到找到⼀个不冲突的 CA 或者尝试失败。</p>
</li>
<li><p>成功获取的 CA 会存储到 NVRAM 供下次使用。</p>
</li>
</ul>
</li>
</ul>
<p><strong><mark>关于地址</mark></strong></p>
<p>大部分基于 SAE J1939 网络的 ECU 都将拥有⼀个设置好的首选地址（参阅 SAE J1939， 表B2到B9），ECU 必须尝试首先使用。</p>
<h3 id="NAME"><a href="#NAME" class="headerlink" title="NAME"></a>NAME</h3><p>J1939定义了⼀套ECU命名方法，用于地址管理、网络出错管理等功能。</p>
<p>在J1939网络中，每个ECU都必须声明⼀个唯⼀的地址，以便其他节点能够准确地识别和与其通信。地址的声明过程涉及到在总线上广播声明消息，其中包含ECU的唯⼀地址。</p>
<p>地址声明消息包含⼀个源地址和⼀个NAME，可在网络中用于把⼀个NAME和⼀个特定的地址关联起来，也使地址和功能关联起来。</p>
<p>在 SAE J1939 网络中，传输消息的ECU需要⼀个NAME，作用有两个：</p>
<ul>
<li><p>为模块提供⼀个功能描述；</p>
</li>
<li><p>提供⼀个编号值用于地址仲裁(当ECU有出现使用相同地址时仲裁)。编号越小，优先级越高。</p>
</li>
</ul>
<p>从左到右的优先次序排列如下：</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013224404.png"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013224509.png"></p>
<table>
<thead>
<tr>
<th>NAME 域</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>仲裁地址能力域</td>
<td>这个 1 位的域表示⼀个 ECU是否可自配置地址，声明地址发生冲突时，可以在可仲裁的源地址（128~ 247）范围中选择⼀个地址将其声明为其源地址。如果这位被设为“1”，那么当该 ECU 与⼀个具有较高优先级（编号值较小）标称符的 ECU发生地址声明冲突时，它可以通过采用⼀个新的源地址来解决。如果⼀个 ECU 计算它的地址后，只能声明某个特定的地址，那么这个 ECU并不具有仲裁地址能力。</td>
</tr>
<tr>
<td>产业类群域</td>
<td>由SAE定义并分配的⼀个 3 位的域。其定义可以在 SAE J1939 基础文档的附录B.7 中找到。</td>
</tr>
<tr>
<td>汽车系统实例域</td>
<td>是⼀个 4 位的域，用来区别某汽车系统中的子系统，例如，0表示第⼀个子系统。注意，如果是网络中唯⼀⼀个或第⼀个特定的汽车系统域，则要把实例域置为零，以表示这是第⼀个实例。</td>
</tr>
<tr>
<td>汽车系统域</td>
<td>是由SAE定义和设置的⼀个 7 位的域，它和产业类群域组合起来， 可以和⼀个共用名相关联。这样，汽车系统域在网络中为⼀系列功能提供了共用名。</td>
</tr>
<tr>
<td>保留域</td>
<td>这是 SAE 为以后的定义保留的。保留位应置为零。</td>
</tr>
<tr>
<td>功能域</td>
<td>功能实例域是⼀个 5 位的域。表示⼀个具体的功能实例，例如，0表示第⼀个功能实例。</td>
</tr>
<tr>
<td>ECU实例域</td>
<td>是⼀个 3 位的域，它可以显示同特定功能域相关联的⼀组电子控制模块中哪⼀个被引用了。即用来区别相同功能域中的⼀组电控单元。例如，当两个分开的控制单元去控制同⼀台发动机时，每个控制单元都附属于相同的 SAE J1939 网络，这时对于第⼀个ECU，ECU 实例域的值设为0；对于第⼆个ECU, 设为1。注意，如果是网络中唯⼀⼀个或第⼀个特定的 ECU，则要把实例域置为零，以表示这是第⼀个实例。</td>
</tr>
<tr>
<td>制造商代码域</td>
<td>是⼀个 11 位的域，它可以显示哪⼀家公司对使用这种标称符的电子控制模块产品承担责任。制造商代码是由SAE设置的，并可以在 SAE J1939 基础文档中找到。</td>
</tr>
<tr>
<td>⾝份编号域</td>
<td>其值由ECU 制造商设置，当名字不唯⼀时，必须使用ID编号，这个域必须是唯⼀的，并且在断电的情况下保持不变。</td>
</tr>
</tbody></table>
<p>除了仲裁地址能力域以外，如果任⼀标称符域的数据不可知或不可用，那么该域将被设为⼆进制1，表示不可知或不可用。仲裁地址能力域应该被设置为适当的值。</p>
<h3 id="地址声明消息"><a href="#地址声明消息" class="headerlink" title="地址声明消息"></a>地址声明消息</h3><p>任何⼀种 ECU 都可以使用地址声明请求消息，来请求NAME，以及同一个网络下，其他ECU的地址。每个ECU都可以发送⼀个包含了它的地址和NAME的地址声明消息，来响应这个请求。如果 ECU 不能够声明地址，那它就会响应⼀条“不能声明地址”的消息。</p>
<p>还没有尝试声明地址的 ECU 要等到这个尝试声明地址为止，然后才能够参与网络通讯，才能够发送不能够声明地址消息或者其他任何的消息。</p>
<p>ECU 还可以通过向全局目标地址（255）发送地址声明请求并检验响应，从而确定在网络上其他正在工作的 ECU。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013224648.png"></p>
]]></content>
      <categories>
        <category>汽车与工业网络</category>
      </categories>
      <tags>
        <tag>J1939</tag>
      </tags>
  </entry>
  <entry>
    <title>Keil 使用问题汇总</title>
    <url>/2023/Keil-Usage-12a1a959c43e/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>记录日常工作中使用Keil遇到的问题的解决方法。</p>
<h1 id="keil仿真相关"><a href="#keil仿真相关" class="headerlink" title="keil仿真相关"></a>keil仿真相关</h1><h2 id="添加芯片flash型号"><a href="#添加芯片flash型号" class="headerlink" title="添加芯片flash型号"></a>添加芯片flash型号</h2><p>在用仿真器烧录时，需要在flash download列表下，选择待烧写设备的芯片对应的flash型号。如果flash download添加列表中，没有我们要的芯片flash型号，则需要去官网下载相应系列的芯片包，如STM32F4xx_DFP。这里面会包含我们需要的FLM文件，将FLM文件复制到<code>keil安装路径\ARM\flash</code>目录下即可。</p>
<h2 id="烧录异常"><a href="#烧录异常" class="headerlink" title="烧录异常"></a>烧录异常</h2><p>在安装JLink驱动时，最后一步会检测本地电脑中，使用 JLinkARM.dll 的第三方应用程序，并提示是否要将它们使用的dll替换为当前安装的版本，详见下图。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812152342.png" alt="jLink.png"></p>
<p>如果错误的替换了dll，则可能导致第三方应用程序使用异常，比如：keil烧录、仿真异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The firmware of the connected J-link does not support the following memory access(Cannot load driver \ARM\Segger\JL2CM3.dll)。</span><br></pre></td></tr></table></figure>

<p>解决方法：进入<code>Keil安装目录下的\ARM\Segger</code>，将里面的JLinkARM.dll用合适的JLinkARM.dll替换即可。如：JLink驱动安装目录下，或者从其他正常使用keil的电脑，在同样的路径里面找到dll，复制出来替换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JLink Warning: Mis-aligned memory write: Address: 0x20000000, NumBytes: 2, Alignment: 2 (Halfword-aligned)</span><br></pre></td></tr></table></figure>

<p>这个是JL2CM3.dll的问题，把它换成其他版本的（版本不要过低），也可以安装MDK其他的低版本解决，或者同上一个问题一样复制替换。</p>
<h2 id="编译报错"><a href="#编译报错" class="headerlink" title="编译报错"></a>编译报错</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.\Output\Stm32_MCU_FBL.axf: error: L6050U: The code size of this image (42994 bytes) exceeds the maximum allowed for this version of the linker.</span><br></pre></td></tr></table></figure>

<p>原因是没有注册，还是试用版，对编译文件的大小有限制。解决方法：keil注册（破解）</p>
<h1 id="Keil工程相关"><a href="#Keil工程相关" class="headerlink" title="Keil工程相关"></a>Keil工程相关</h1><p>当电脑安装了Keil4与Keil5两个软件时，打开工程文件会默认选择Keil5打开，而用Keil4创建的工程，用keil5打开会崩溃。通过修改注册表可以实现，不同的工程文件类型用指定的Keil版本打开。即Keil4建立的工程用Keil4打开，Keil5建立的工程用Keil5打开。</p>
<p>打开注册表，展开<code>HKEY_CLASSER_ROOT</code>，找到<code>UVPROJFILE</code>目录（Keil4工程文件类型）和<code>UVPROJXFILE</code>目录（Keil5工程文件类型）。在右侧窗口双击名称下面的条目，出现编辑框后，将数值数据填写为对应的Keil应用程序路径即可。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812145104.png" alt="keil注册表.png"></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>之前遇到过一个问题，在win10环境下，Keil4启动时会有类型闪退的现象，卡在启动界面一段时间后会自动退出。调出任务管理器，查看程序的运行状态，发现启动时会自动被挂起。后续，安装高版本的keil4之后不再出现。</p>
]]></content>
      <categories>
        <category>嵌入式IDE</category>
      </categories>
      <tags>
        <tag>Keil</tag>
        <tag>JLink</tag>
      </tags>
  </entry>
  <entry>
    <title>PCAN 使用笔记</title>
    <url>/2023/PCAN-Usage-4b8805394c51/</url>
    <content><![CDATA[<h1 id="PCAN-Explorer回放报文"><a href="#PCAN-Explorer回放报文" class="headerlink" title="PCAN-Explorer回放报文"></a>PCAN-Explorer回放报文</h1><ol>
<li><p>打开工程，如何新建工程详见<a href="https://peak-system.com.cn/wp-content/uploads/2022/06/PCAN-Explorer6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.pdf">PCAN-Explorer6基本使用方法.pdf</a></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812204403.png" alt="工程文件.png"></p>
</li>
<li><p>添加连接，如何新建连接详见说明文档</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812204754.png" alt="添加连接.png"></p>
</li>
<li><p>导入DBC，双击打开，全选并Apply</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812204904.png" alt="导入DBC.png"></p>
</li>
<li><p>打开Plotter插件，并导入报文。Plotter插件中显示的是具体的信号值，所以在工程中必须有相应的解析文件如：sym、dbc，把CAN报文解析为具体的信号值才能正常把trc文件导入到Plotter插件。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812205653.png" alt="import from tracer.png"></p>
</li>
<li><p>选择信号。导入报文后选择要查看的信号，提供选择的信号是导入的报文所包含的信号，可以一次选择多个。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812210321.png" alt="选择信号.png"></p>
</li>
<li><p>调整样式</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812210420.png" alt="样式调整.png"></p>
</li>
<li><p>回放查看</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812210535.png" alt="报文查看.png"></p>
</li>
</ol>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p>PCAN-Explorer打开PCAN-View录制的trc格式报文，显示出来的内容为空；Plotter插件导入同一份报文，提示无信号。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812210836.png" alt="no signal.png"></p>
<p>原因为两者的文件版本不一致，解析错误。我用的PCAN-Explorer文件版本为1.3，PCAN-View文件版本为2.0。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812211812.png" alt="PCAN-Explorer Version.png"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812211826.png" alt="PCAN-View Version.png"></p>
<p>解决方法：使用PEAK-Converter，将PCAN-View导出的trc报文转为1.3版本，格式不变，这样可以继续导入到Plotter插件中，进行后续回放。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812212213.png" alt="Format.png"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812212222.png" alt="Target Version.png"></p>
]]></content>
      <categories>
        <category>CAN总线工具</category>
      </categories>
      <tags>
        <tag>PCAN</tag>
      </tags>
  </entry>
  <entry>
    <title>S32DS 使用问题汇总</title>
    <url>/2023/S32DS-Usage-31bfab119a51/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>记录日常工作中使用S32 Design Studio IDE遇到的问题的解决方法。问题大多比较久远，因此没有附图。</p>
<h1 id="S32DS安装"><a href="#S32DS安装" class="headerlink" title="S32DS安装"></a>S32DS安装</h1><h2 id="安装出错"><a href="#安装出错" class="headerlink" title="安装出错"></a>安装出错</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The installation of S32 Design Studio for ARM Version 2018.R1 has been rolle back</span><br></pre></td></tr></table></figure>

<p>原因：没有安装权限，以管理身份重新安装即可解决。</p>
<h2 id="离线激活"><a href="#离线激活" class="headerlink" title="离线激活"></a>离线激活</h2><ol>
<li><p>在官网下载需要的安装包，点击下载需要注册账号，根据提示注册即可。然后在下载界面找到License Keys，记录下Activation code，安装过程要用到；</p>
</li>
<li><p>安装过程会要求输入Activation code，激活类型选择offline。生成request.xml，然后将该文件上传到<a href="https://nxp.flexnetoperations.com/control/frse/offlineActivation">链接</a>，点击process生成activation.xml，通过安装指导上传activation.xml后，继续后续的安装。</p>
</li>
</ol>
<h1 id="S32DS仿真报错"><a href="#S32DS仿真报错" class="headerlink" title="S32DS仿真报错"></a>S32DS仿真报错</h1><h2 id="JLinkGDBServerCL-exe"><a href="#JLinkGDBServerCL-exe" class="headerlink" title="JLinkGDBServerCL.exe"></a>JLinkGDBServerCL.exe</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error in services launch sequence</span><br><span class="line">Launching command [C:/NXP/S32DS_ARM_v2.0/Drivers/Segger/JLinkGDBServerCL.exe -if swd -device S32K144 -endian little -speed auto -port 2331 -swoport 2332 -telnetport 2333 -vd -ir -localhostonly 1 -singlerun -strict -timeout 0 -nogui] failed.</span><br><span class="line">Cannot run program &quot;C:/NXP/S32DS_ARM_v2.0/Drivers/Segger/JLinkGDBServerCL.exe&quot;: Launching failed。</span><br></pre></td></tr></table></figure>

<p>从报错提示来看应该是JLinkGDBServerCL.exe出现错误了，查看之后发现本地并没有这个路径。</p>
<p>解决方法如下：进入S32DS对应的Debug配置界面，在executable设置中点击Variables，修改里面的<code>$&#123;jlink_path&#125;</code>（Path to J-Link installation folder），可以选择为S32DS安装路径下的<code>\Drivers\Segger\</code>路径，这样一来Launching command里面的可执行程序的路径就变为我们所设置的路径了。</p>
<h2 id="PEmicro-GDB-Launch-Failure"><a href="#PEmicro-GDB-Launch-Failure" class="headerlink" title="PEmicro GDB Launch Failure"></a>PEmicro GDB Launch Failure</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Another GDB Server debug session is alreadyusing the same Server Port number. To run simultaneous debug sessions, please specify a unique Server Port and GDBMI Port in the Debug Configuration for each project. If another session is not running simultaneously, make sure that the pegdbserver_console and the arm-none-eabi-gdb processes have terminated.</span><br></pre></td></tr></table></figure>

<p>解决如下：通过任务管理器，关闭pegdbserver_console.exe进程。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230811202451.png" alt="pegdb.png"></p>
<h2 id="J-Link-GDB-Server-failed"><a href="#J-Link-GDB-Server-failed" class="headerlink" title="J-Link GDB Server failed"></a>J-Link GDB Server failed</h2><p><img title="" src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230811203342.png" alt="could not connect to J-Link.png" width="329"><img title="" src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230811203351.png" alt="could not connect to target.png" width="320"></p>
<p>出现这个问题原因有很多，包括但不限于：待烧录设备未供电、JLink未连接、待烧录设备芯片型号选择错误、S32DS安装目录下的Segger目录文件被替换。</p>
<h1 id="S32DS工程相关"><a href="#S32DS工程相关" class="headerlink" title="S32DS工程相关"></a>S32DS工程相关</h1><p>在切换不同项目时，我习惯先在Project Explorer框中，右键选中并删除当前项目的工程文件夹，然后，再右键导入工程来打开另外一个项目。在选择要导入的工程路径时，IDE会记忆之前选择过的路径，这样的话切换起来比较方便。但是，有些项目已经移动或者删除了，这样一来，这些路径就是无效的。但是，IDE的下拉框还是会显示这些无效的路径。于是，可以通过下面的方式，来修改历史选择过的路径。导入的工程路径保存在：<br><code>工作目录\.metadata\.plugins\org.eclipse.ui.ide\dialog_settings.xml</code></p>
<p>具体操作时，<strong>首先要退出S32DS软件</strong>，然后找到上面这个xml文件，修改文件内容，也就是删除不需要的路径。这样的话，下次重新启动S32DS时，下拉提示框显示的内容就会做出相应改变了。</p>
<p>顺便一提，每次切换工程后，建议先make clean，再make编译。</p>
]]></content>
      <categories>
        <category>嵌入式IDE</category>
      </categories>
      <tags>
        <tag>S32DS</tag>
      </tags>
  </entry>
  <entry>
    <title>spreadsheet compare 简单使用说明</title>
    <url>/2023/spreadsheet-compare-cf954b484b3c/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Office2013开始，Office家族增加了Spreadsheet Compare工具，使用这个工具可快速比较识别两个工作簿（或者同一个工作簿的不同版本）来查看不同工作簿之间的差异。Spreadsheet Compare是名符其实的Office官方出品的数据比对神器。</p>
<p>Beyond Compare 也可以用来对比表格差异，但是只能比较两个Excel的当前工作表，如果每个 Excel 文件中包含多个工作表时就会对比错误的情况，而 <code>Spreadsheet Compare</code> 在这一点上更加优秀，可以对比多个表格数据。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>打开两份需要比较Excel（注意：两份原文件一定要做备份，Spreadsheet Compare会修改当前文件。）</p>
<p>点击任意一个文件Exce菜单加载项</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20220220213550.png" alt="image20220220203635055"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20220220213603.png" alt="image20220220204055371"></p>
<h2 id="Compare-Type设置"><a href="#Compare-Type设置" class="headerlink" title="Compare Type设置"></a>Compare Type设置</h2><p>选择Database Style Compare，Primary KEY Colum选择可作为数据库内主键的列，否则对比的结果会有错乱。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20220220213609.png" alt="image20220220205530434"></p>
<p>设置Excel工作薄中需要比较的Sheet，两个文件均需要设置具体的Sheet，这边有两步，选择好之后点击Next。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20220220213612.png" alt="image20220220205827545"></p>
<h2 id="报告查看"><a href="#报告查看" class="headerlink" title="报告查看"></a>报告查看</h2><p>Report详细列出了两份文件的修改情况。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20220220213615.png" alt="image20220220211610710"></p>
<p>Merged Diffs则把两份合并在一起，列出其差异。同时工具也会修改原文件，把有差异的地方标红，两份文件并排在一起方便对比查看。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20220220213618.png" alt="image20220220212018465"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20220220213622.png" alt="image20220220213418872"></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>其余选项的说明可以查看帮助文档</p>
]]></content>
      <categories>
        <category>Office</category>
      </categories>
      <tags>
        <tag>对比工具</tag>
      </tags>
  </entry>
  <entry>
    <title>使用拨号上网时，笔记本电脑无法打开热点的解决方法</title>
    <url>/2021/%E6%97%A0%E6%B3%95%E5%BC%80%E5%90%AF%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98-38d92260e969/</url>
    <content><![CDATA[<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>一般情况下，我们是可以正常使用笔记本电脑来开启热点的。但是，在使用拨号的方式上网时，热点无法正常开启。具体表现如下图所示，热点按钮无法点击。当然，你也可以买一个路由器达到曲线救国的目的。在这里，本文给出一种方法，在不用路由器的情况下(<del>绝对不是因为穷</del>😭)开启电脑热点，供其它设备正常连接使用。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20210809005435.png" alt="image-20210808225118370"></p>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ol>
<li>先不要拨号上网，如果连上了就先断开连接，然后手机开启热点</li>
<li>电脑连接手机开启的热点，这时电脑的热点按钮是可以点击开启的。我们开启电脑的热点功能，然后手机关掉热点（这里注意：是关闭手机的，电脑不要把热点关了）。完成之后，依次点击<code>网络和Internet设置--&gt;更改适配器选项</code>，我们可以看到有一个叫本地连接*2之类的适配器（后面的数字不重要），这个对应的就是电脑开启的热点。<br><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20210809005442.png" alt="image-20210808223329092"></li>
<li>电脑正常拨号上网，然后按照下图的操作，共享给上一步的本地连接*2即可。<br><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20210809005448.png" alt="image-20210808224205345"></li>
<li>以上的操作，网上已有不少的博客介绍了。但是，这里面存在一个问题，这样操作之后的电脑热点用不了多久就会自动关闭。我上网找了一下，没有相应的解决方法。下面本文将会给出一种解决方法，也算是有一点原创的内容了。</li>
</ol>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>通过上面设置后，电脑热点只能使用20分钟左右，就会自动关闭，并且无法通过右下角的任务栏来再次打开。</p>
<p>这里我猜测自动关闭是因为步骤2中，手机突然关闭了热点，但是电脑的热点功能还开启着（这时候其它的设备连上这个电脑热点也是无法上网的，因为手机的热点关闭了。当然，完成步骤3后是可以上网的，只不过会自动关闭），没有实时的对手机热点的关闭做出响应，会有一段时间的延迟，也就是20分钟左右，才会对手机热点的关闭做出响应，响应的具体表现就是电脑热点的自动关闭。</p>
<p><strong>解决方法</strong>就是完成上面的一系列操作后，进入热点的设置界面（图一中的热点按钮右键点击设置，即可打开），<mark>不要关闭这个界面</mark>，可以将界面最小化，一直等到热点自动关闭后，我们再点击这个热点设置界面的开启按钮即可。这样处理一次之后，电脑热点就会一直保持开启了，这个时候就可以关闭热点的设置界面了。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20210809005454.png" alt="image-20210809004547802"></p>
<p>当然，如果重启电脑的话，又得按照上面的步骤来一遍。虽说会有点繁琐，不过熟练操作以后，也花不了太多的时间。这里提一下，重启电脑后如果完成了上面的操作，手机连接上电脑的热点，提示<code>已连接，但无法访问互联网</code>，这时我们只需要将步骤3的宽带连接先取消共享（取消勾选），然后再次共享即可。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>疑难杂症</tag>
      </tags>
  </entry>
  <entry>
    <title>CCS使用笔记</title>
    <url>/2025/prefix%20remember%20to%20change!!!-0d2b6ccd334f/</url>
    <content><![CDATA[<h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><p>TI 官方文档：<a href="https://software-dl.ti.com/ccs/esd/documents/users_guide_ccs_20.1.0/index.html">Code Composer Studio™ User Guide</a></p>
<h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><p><strong>CCS下载链接：</strong><a href="https://www.ti.com/tool/download/CCSTUDIO/20.1.0">CCSTUDIO IDE, configuration, compiler or debugger | TI.com</a></p>
<p><strong>SDK下载链接：</strong><a href="https://www.ti.com.cn/tool/cn/download/MCU-PLUS-SDK-AM62A">MCU-PLUS-SDK-AM62A 软件开发套件 (SDK) | 德州仪器 TI.com.cn</a></p>
<ul>
<li>SDK安装完成后，如果需要用CCS编译，则需要做如下配置：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016165912.png"></p>
<p><strong>SysConfig下载链接：</strong><a href="https://www.ti.com.cn/tool/cn/download/SYSCONFIG/1.20.0.3587">SYSCONFIG IDE、配置、编译器或调试器 | 德州仪器 TI.com.cn</a></p>
<p><strong>编译器下载链接：</strong><a href="https://www.ti.com/tool/download/ARM-CGT-CLANG/3.2.2.LTS">ARM-CGT-CLANG IDE, configuration, compiler or debugger | TI.com</a></p>
<p><strong>MCAL SDK：</strong></p>
<ol>
<li><p>使用以下链接申请</p>
<p><a href="https://www.ti.com/licreg/docs/swlicexportcontrol.tsp?form_id=337627&prod_no=PROCESSORSDK-MCAL-AM62X&ref_url=EP-Proc-Sitara-MPU">https://www.ti.com/licreg/docs/swlicexportcontrol.tsp?form_id=337627&amp;prod_no=PROCESSORSDK-MCAL-AM62X&amp;ref_url=EP-Proc-Sitara-MPU</a></p>
</li>
<li><p>获得批准后，从以下链接下载 MCAL SDK：</p>
<p><a href="https://www.ti.com/securesoftware/docs/autopagepreview.tsp?opnId=27760">https://www.ti.com/securesoftware/docs/autopagepreview.tsp?opnId=27760</a></p>
</li>
<li><p>文档</p>
<p><a href="https://software-dl.ti.com/mcu-plussdk/esd/PLATFORM_SW_MCAL/AM62Ax/09.00.00.01/mcusw_c_ug_top.html">https://software-dl.ti.com/mcu-plussdk/esd/PLATFORM_SW_MCAL/AM62Ax/09.00.00.01/mcusw_c_ug_top.html</a></p>
</li>
</ol>
<h1 id="CCT"><a href="#CCT" class="headerlink" title="CCT"></a>CCT</h1><p>CTT：Clock Tree Tool，适用于TI处理器的时钟树工具，直观的显示系统时钟。</p>
<p>根据用户定义的时钟源（晶振、PLL等）、分频系数、输出频率等参数，工具可自动生成时钟寄存器配置。</p>
<h2 id="在线使用"><a href="#在线使用" class="headerlink" title="在线使用"></a>在线使用</h2><p>TI官网上针对AM62AX的CCT工具是在线的：<a href="https://login.ti.com/as/authorization.oauth2?client_id=DCIT_ALL_LOGIN_CALLOUT&redirect_uri=https://auth.ti.com/davinci/oauth2/callback&response_type=code&state=c83e81af5f0a3fc11b3bc04088891eb635189b744e3294e9668b677ebf88d5b9&scope=openid%20profile%20email">Log in</a></p>
<p>其他在线工具：<a href="https://dev.ti.com/">TI Developer Zone</a></p>
<p>在线的CCT版本是1.1.4。</p>
<h2 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h2><p>在链接里面可以找到CCT的安装包：<a href="https://dev.ti.com/tirex/explore">TI Resource Explorer</a></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016170637.png"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016170655.png"></p>
<ol>
<li><p>解压下载好的压缩包</p>
</li>
<li><p>CCS里面需要导入CCT</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016170819.png"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016171023.png" title="" alt="" width="715"><strong>可能会有版本不匹配的问题，按照提示解决。</strong><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016171118.png"></p>
</li>
<li><p>找到sysconfig的安装路径，双击打开</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016171205.png"></p>
<p>按照如下配置，点击start，会创建cfg文件。save的时候会保存相关的寄存器配置文件。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016171238.png"></p>
</li>
</ol>
<h2 id="生成物"><a href="#生成物" class="headerlink" title="生成物"></a>生成物</h2><p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016171309.png"></p>
<p>生成文件说明</p>
<ul>
<li><p><code>.syscfg</code> 文件：是ClockTree生成的配置文件，可在TI的开发环境中导入使用(目前无法打开，会报错，可能和CCS 的版本有关系)。</p>
</li>
<li><p><code>.gel</code> 文件：是用于CCS的脚本文件，可在调试时加载，用于打印时钟寄存器值。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016171545.png"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016171604.png"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016171757.png"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016172103.png"></p>
<ul>
<li><p><code>.py</code> 文件：在Linux环境下，使用<code>k3conf</code>打印时钟寄存器值的Python文件。和gel作用一样，也是打印寄存器的值。打印的结果可以保存到txt，然后再导入CCT里面。</p>
</li>
<li><p><code> .rd1</code> 、<code>.rd2</code> 寄存器转储文件：记录寄存器的值，用于调试和验证配置是否正确。</p>
</li>
</ul>
<h1 id="编译报错"><a href="#编译报错" class="headerlink" title="编译报错"></a>编译报错</h1><h2 id="SDK和sysconfig版本不匹配报错"><a href="#SDK和sysconfig版本不匹配报错" class="headerlink" title="SDK和sysconfig版本不匹配报错"></a>SDK和sysconfig版本不匹配报错</h2><p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016172230.png"></p>
<p>sysconfig版本需要和SDK版本匹配，如果不匹配需要自己在TI官网下载并安装SDK以及sysconfig。 修改版本方法见下图，SDK和sysconfig设置方法一致。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016172257.png"></p>
<p>如果选择的版本不匹配，会有报错提示</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016172327.png"></p>
<h2 id="Norflash相关函数链接报错"><a href="#Norflash相关函数链接报错" class="headerlink" title="Norflash相关函数链接报错"></a>Norflash相关函数链接报错</h2><p>MCU R5F核添加了norflash驱动，据说是TI修改了SDK，改完的SDK用CCS去编译会出现如下错误：</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016172408.png"></p>
<p>从上面这个报错，可以推测有一些文件使用了其他C文件的函数，但是编译这个库的时候，没有包含对应文件去编译，导入我们自己的工程后，找不到对应的函数实现，导致链接报错。</p>
<p><mark>MCU+SDK v10.01已经解决了这个问题。</mark></p>
<h3 id="解决方法一：添加缺失的文件"><a href="#解决方法一：添加缺失的文件" class="headerlink" title="解决方法一：添加缺失的文件"></a>解决方法一：添加缺失的文件</h3><p>去SDK里面找到缺少的函数定义，找到对应的C文件，添加到我们自己的工程里面。</p>
<h3 id="解决方法二：切换成Release编译"><a href="#解决方法二：切换成Release编译" class="headerlink" title="解决方法二：切换成Release编译"></a>解决方法二：切换成Release编译</h3><p>用makefile编译是ok的，CCS编译不行，对比了一下发现makefile是Release的配置，用的库也是release，所以尝试把CCS改为Release，测试是可行的。</p>
<ol>
<li><p>选择Release</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016172616.png"></p>
</li>
<li><p>修改完后，发现没有添加对应的头文件，需要手动添加。修改工程文件，添加头文件路径如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//找到Release标签</span><br><span class="line"><span class="tag">&lt;<span class="name">cconfiguration</span></span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">&quot;com.ti.ccstudio.buildDefinitions.TMS470.Release.1770007231&quot;</span>&gt;</span></span><br><span class="line">//添加如下内容 主要就是头文件路径</span><br><span class="line"><span class="tag">&lt;<span class="name">listOptionValue</span> <span class="attr">builtIn</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">value</span>=<span class="string">&quot;$&#123;workspace_loc:/$&#123;ProjName&#125;/xxx/inc&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listOptionValue</span> <span class="attr">builtIn</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">...</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="fatal-error-‘xxx-h’-file-not-found"><a href="#fatal-error-‘xxx-h’-file-not-found" class="headerlink" title="fatal error: ‘xxx.h’ file not found"></a>fatal error: ‘xxx.h’ file not found</h2><p>前提：<code>xxx.c</code>包含了<code>xxx.h</code>文件。</p>
<p><strong>问题的根本原因</strong></p>
<p>在编译命令中，通过 <code>-I</code> 参数指定了多个头文件搜索路径，但这些路径中没有包含 <code>xxx.h</code> 的实际位置。</p>
<p><code>subdir_rules.mk</code> 的编译命令没有这个路径，因此，编译器无法自动搜索到 <code>xxx.h</code> ，导致报错。</p>
<p>解决方法：</p>
<ol>
<li>改为相对路径</li>
</ol>
<ul>
<li><p>相对路径是相对于当前源文件（ <code>xxx.c</code> ）的位置解析的。编译器会从<code>xxx.c </code>所在目录出发，按照相对路径找到 <code>xxx.h</code> 。</p>
</li>
<li><p>相对路径绕过了编译器默认的搜索路径机制，直接指定了文件的实际位置，因此不再依赖 <code>-I </code>参数。</p>
</li>
</ul>
<ol start="2">
<li>修改 .<code>cproject </code>文件</li>
</ol>
<p>由于 <code>subdir_rules.mk </code>是自动生成的，而且在项目配置中也添加了头文件路径，但是还是出现了这个错误。于是想到查看 <code>.cproject</code> 文件：</p>
<p>问题在于 <code>xxx.c </code>文件有一段单独的配置，但是这段配置没有包含对应的头文件路径。</p>
<ul>
<li><p>可以增加<code>xxx.h</code>实际所在的路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;listOptionValue builtIn=&quot;false&quot; value=&quot;$&#123;workspace_loc:/$&#123;ProjName&#125;/xxx/inc&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>或者直接把这个单独的配置整个删掉（推荐）</p>
</li>
</ul>
<h2 id="current-parser-token-‘include’-xxx-h"><a href="#current-parser-token-‘include’-xxx-h" class="headerlink" title="current parser token ‘include’ xxx.h"></a>current parser token ‘include’ xxx.h</h2><p>解决方法：再编译一次。</p>
<p>编译命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;D:\\ti\\ccs1240\\ccs\\utils\\bin\\gmake&quot; -k -j 16 all -O</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>-j 16 </code>是明确的并行编译标志，表示允许同时运行 16 个编译任务。</p>
</li>
<li><p><code>-O </code>选项表示输出同步（<code> --output-sync</code> ），确保不同线程的编译日志不会交错显示。</p>
</li>
</ul>
<p>可能的原因：</p>
<ol>
<li><p>首次编译：如果某些生成的代码（如 xxx.h ）尚未完成生成，而其他线程已经开始编译依赖它的文件（如 xxx.c ），会导致头文件缺失错误。</p>
</li>
<li><p>第⼆次编译：生成的文件已经存在（如 xxx.h ），竞态条件消失，编译成功。</p>
</li>
</ol>
<p><strong>降低并行度测试</strong></p>
<p>可以使用单线程编译验证是否为竞态问题，如果单线程编译始终成功，则可确认是并行竞态问题。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016173942.png"></p>
<h2 id="“-linker-cmd”-line-53-error-10099-D-program-will-not-fit-into-available-memory"><a href="#“-linker-cmd”-line-53-error-10099-D-program-will-not-fit-into-available-memory" class="headerlink" title="“..&#x2F;linker.cmd”, line 53: error #10099-D: program will not fit into available memory,"></a>“..&#x2F;linker.cmd”, line 53: error #10099-D: program will not fit into available memory,</h2><p>按照ti demo工程替换linker.cmd文件后，使用ccs编译报错，原因是内存不⾜。</p>
<p>查看map文件发现，ccs debug模式下，没有编译优化，编译出来的文件text段比较⼤。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016174057.png"></p>
<p>解决方法：可以和makefile文件使用相同的编译优化参数</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016174123.png"></p>
]]></content>
      <categories>
        <category>嵌入式IDE</category>
      </categories>
      <tags>
        <tag>Code Composer Studio</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Curl排查HTTP问题的经历</title>
    <url>/2025/prefix%20remember%20to%20change!!!-92342a72fd01/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我的核心职责是MCU侧的CAN总线开发。在联调过程中，Soc端需依赖一个专用Box来生成第三方算法的运行License。联调期间，该Box无法生成License，严重阻碍了联调进度。本文记录了本人协助Soc同事定位并解决此问题的全过程。</p>
<h1 id="Box策略分析"><a href="#Box策略分析" class="headerlink" title="Box策略分析"></a>Box策略分析</h1><blockquote>
<p>因为不清楚Box的策略，以下分析都是主观的，不⼀定准确。</p>
</blockquote>
<p>Box有⼀个默认的网址，用于查看当前的状态信息。这个网址内容数据来源于Box的固件，存储在Box的非易失性存储器中。当Box启动后，收到请求时，固件会加载相关文件，然后通过http协议传输内容给PC，使得我们可以在本地浏览器查看信息。</p>
<p>PC不联网也可以生成license，这是因为当通过网线连接PC和Box时，PC和Box之间形成了⼀个本地网络，数据访问和设置过程都是在本地网络内进行的，不需要互联网连接。</p>
<h1 id="http连接异常分析"><a href="#http连接异常分析" class="headerlink" title="http连接异常分析"></a>http连接异常分析</h1><p><strong>错误信息</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">D:\share&gt;python .\main_create_license.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">&quot;D:\software\Python\lib\site-packages\urllib3\connection.py&quot;</span>, line</span><br><span class="line"><span class="number">207</span>, <span class="keyword">in</span> _new_conn</span><br><span class="line">socket_options=self.socket_options,</span><br><span class="line">File <span class="string">&quot;D:\software\Python\lib\site-packages\urllib3\util\connection.py&quot;</span>,</span><br><span class="line">line <span class="number">60</span>, <span class="keyword">in</span> create_connection</span><br><span class="line"><span class="keyword">for</span> res <span class="keyword">in</span> socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):</span><br><span class="line">File <span class="string">&quot;D:\software\Python\lib\socket.py&quot;</span>, line <span class="number">752</span>, <span class="keyword">in</span> getaddrinfo</span><br><span class="line"><span class="keyword">for</span> res <span class="keyword">in</span> _socket.getaddrinfo(host, port, family, <span class="built_in">type</span>, proto, flags):</span><br><span class="line">socket.gaierror: [Errno <span class="number">11001</span>] getaddrinfo failed</span><br></pre></td></tr></table></figure>

<p>根据错误信息， <code>socket.gaierror: [Errno 11001] getaddrinfo failed </code>这个错误⼀般是尝试解析主机名以获取地址信息时失败了。</p>
<p><strong>测试网络连接</strong></p>
<p>PC和Box，通过网线连接，Box对应网络适配器是<code>#2</code>，使用 <code>ipconfig</code> 查看Box的IP地址。</p>
<p>地址是可以ping通的，可以说明：</p>
<ol>
<li><p>设备能够通过网络到达目标地址，说明至少在网络层面上，设备和目标地址之间的路径是通的。</p>
</li>
<li><p>目标地址上的设备或服务处于开机状态，并响应了ICMP请求。</p>
</li>
<li><p>目标地址的防火墙和路由器配置允许ICMP包通过，没有被阻止。</p>
</li>
</ol>
<p>即使地址可以ping通，也不能保证所有的网络服务都能正常工作，因为ping命令通常只检测ICMP协议的响应。</p>
<p><strong>测试HTTP的连通性</strong></p>
<p>对于HTTP，因为”ping”不支持HTTP协议，可以通过以下方法来测试：</p>
<ol>
<li>使用浏览器访问： 直接在浏览器地址栏输入HTTP地址，如果服务器响应，说明是可访问的。(如下图)</li>
</ol>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016183351.png"></p>
<ol start="2">
<li><p>在命令行中，可以使用 <code>curl </code>命令来测试HTTP地址。例如： curl <a href="http://xxx.local:3000/">http://xxx.local:3000/</a> ，这将发送⼀个HTTP GET请求，并显示响应内容。(如下所示)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">C:\Users\uidq9792&gt;curl http://xxx.local:3000/</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">href</span>=<span class="string">&quot;/stylesheets/style.css&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="问题一：浏览器无法访问Box网址"><a href="#问题一：浏览器无法访问Box网址" class="headerlink" title="问题一：浏览器无法访问Box网址"></a>问题一：浏览器无法访问Box网址</h1><p>PC连接WiFi，浏览器无法访问Box网址，但<code>curl</code>可以获取到内容。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016183808.png"></p>
<p>这种情况http是通的，不影响license生成，不过也可以解决。从错误码<code>DNS_PROBE_FINISHED_NXDOMAIN </code>来看，是域名解析问题。</p>
<p><strong>方法⼀：</strong></p>
<p>修改hosts文件(需要权限)，绕过DNS解析。文件通常位于</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C:\Windows\System32\drivers\etc\</span><br></pre></td></tr></table></figure>

<p>如果域名对应的IP地址发生变化，需要手动更新 hosts 文件。</p>
<blockquote>
<p>hosts文件是⼀个系统文件，用于将域名映射到IP地址。这个文件主要用于将特定的域名与IP地址关联起来，使得计算机可以直接通过这个映射关系来访问网络资源，而不需要通过DNS服务器进行域名解析</p>
</blockquote>
<p><strong>方法⼆：</strong></p>
<p>断开PC的WiFi连接，然后重置适配器，刷新网页就行了。</p>
<h1 id="问题二：Curl-无法解析主机名"><a href="#问题二：Curl-无法解析主机名" class="headerlink" title="问题二：Curl 无法解析主机名"></a>问题二：Curl 无法解析主机名</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl: (6) Could not resolve host: xxx</span><br></pre></td></tr></table></figure>

<p>出现这种情况，可以右键对应的网络适配器，然后点击诊断，这个过程会重置适配器(不用关心诊断的结果)，然后重新执行curl命令，看是否可以获取到响应内容。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016184052.png"></p>
<p>当可以获取到响应内容时，执行license生成脚本，成功执行的结果如下：</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016184153.png"></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Curl</tag>
      </tags>
  </entry>
  <entry>
    <title>同星UDS刷写工程搭建</title>
    <url>/2025/prefix%20remember%20to%20change!!!-68598371f033/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前做的升级工程是基于CANoe的，但是CANoe工具数量有限，且价格昂贵，在没有CANoe的情况下，可以使用同星的自动诊断流程来升级ECU。SOC的同事也可以使用同星，自行验证升级的功能。</p>
<h1 id="同星UDS刷写工程搭建"><a href="#同星UDS刷写工程搭建" class="headerlink" title="同星UDS刷写工程搭建"></a>同星UDS刷写工程搭建</h1><h2 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h2><p>同星硬件配套的TSMaster软件：</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016214458.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.tosunai.com/tosun-ecu-diagnostic-flashing-solution-reduce-difficulty-developing-ecu-flashing-software-2/">解决方案 | 同星ECU诊断与刷写解决方案：降低了开发ECU刷写软件的难度！ - 上海同星智能科技有限公司</a></p>
<p>官方文档：<code>TSMaster的UDS刷写流程.pdf</code></p>
<h2 id="工程配置流程"><a href="#工程配置流程" class="headerlink" title="工程配置流程"></a>工程配置流程</h2><ol>
<li><p>创建一个UDS诊断和刷写工程。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016214802.png"><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016214822.png"><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016214852.png"></p>
</li>
<li><p>配置通道和波特率，这里不介绍。</p>
</li>
<li><p>导入DBC文件。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016214934.png"></p>
</li>
<li><p>增加必要的模拟发送报文（网络、点火、车速报文）。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016215212.png"></p>
</li>
<li><p>添加一个基础诊断模块，修改诊断传输层配置，主要是CANID。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016215348.png"></p>
<p>修改诊断服务层配置如下：</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016215426.png"></p>
</li>
<li><p>配置34，36，37组合服务。</p>
<p><strong>基本诊断配置提供组合服务，该服务能够根据加载的数据文件自动生成0x34,0x36,0x37服务步骤流程，支持加载多种主流的数据格式（hex，bin，s19，vbf），支持多种校验方式。</strong></p>
<p><strong>通用配置（校验和配置不用关注）</strong></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016222957.png"></p>
<p><strong>擦除flash配置</strong></p>
<p>可以不用配置，在自动诊断流程增加。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016215746.png"></p>
<p><strong>请求和传输数据配置</strong></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016215813.png"><strong>传输退出配置</strong></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016215851.png"></p>
</li>
<li><p>增加自动诊断流程</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016220125.png"><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016220246.png"></p>
</li>
</ol>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><ol>
<li><p>支持文件格式（hex，bin，s19，vbf），不支持zip文件，但是可以手动修改待升级文件的扩展名，也就是把扩展名从zip改成bin。</p>
</li>
<li><p>启动流程的时候也要选择对应的流程。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016220653.png"><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016220749.png"></p>
</li>
</ol>
<p><mark>所有步骤都按照预期回复的话，会显示绿色，如果有异常会显示红色&#x2F;⻩色。</mark></p>
<p>下面是一个升级成功的截图：</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016221034.png"></p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><mark>报错：”从系统变量转化为字节数组失败”。</mark></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016221240.png"></p>
<p><mark>原因：出现这个报错是因为没有识别到升级文件。</mark></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016221344.png"></p>
<p>正常识别到升级文件，是会显示文件名的。如下图：</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016221459.png"></p>
<p>解决方法：重新配置（需要先解锁编辑器），然后选择需要的组合服务，如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016221844.png"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016220246.png"></p>
]]></content>
      <categories>
        <category>CAN总线工具</category>
      </categories>
      <tags>
        <tag>TSMaster</tag>
      </tags>
  </entry>
  <entry>
    <title>报文回放</title>
    <url>/2025/prefix%20remember%20to%20change!!!-76f0d30e8b43/</url>
    <content><![CDATA[<h1 id="在线回放"><a href="#在线回放" class="headerlink" title="在线回放"></a>在线回放</h1><p><strong>为什么需要在线回放报文？</strong></p>
<ol>
<li><p>复现问题场景</p>
<p>在网络通信系统（如CAN总线）中，某些问题可能只在特定的报文交互场景下才会出现。通过在线回放报文，可以将之前记录的报文重新发送到总线上，从而精确地复现问题发生的场景，便于定位和解决问题。</p>
<p>例如，某些偶现的故障可能与特定的报文序列有关，通过在线回放可以重现这些报文序列，帮助快速找到问题。因为偶发性故障很难在实时环境中捕捉，通过在线回放报文，可以在离线环境中反复重现故障场景，从而更高效地排查问题。</p>
</li>
<li><p>模拟真实网络环境</p>
<p>在线回放报文可以模拟真实的网络通信环境，包括报文的发送时间间隔、报文内容等。支持基于时间戳的报文发送，可以按照实际记录的时间顺序和间隔发送报文，从而更真实地模拟真实环境。这对于测试网络设备、协议栈或软件在实际运行中的表现非常重要。</p>
<p>例如，通过在线回放可以模拟高负载的网络环境，测试系统在极端条件下的稳定性和性能。</p>
</li>
<li><p>优化开发和测试流程</p>
<p>在线回放提供了一种灵活的测试手段，可以快速切换不同的报文序列和测试场景，减少测试准备时间。</p>
<p>例如，通过脚本和通道映射功能，可以灵活地选择需要回放的报文和发送通道，甚⾄可以屏蔽某些不需要的报文。</p>
</li>
</ol>
<p><strong>如何在线回放报文？</strong></p>
<ol>
<li><p>以同星工具为例，打开同星工程，找到总线回放的选项卡，选择在线回放。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016223753.png"></p>
</li>
<li><p>选择要回放的文件。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016223819.png"></p>
</li>
<li><p>报文回放设置。</p>
<p>根据需要修改配置，下图只是一个示例配置（只修改了红框的配置，其他都是默认的）。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016224008.png"></p>
</li>
<li><p>开始回放。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016224300.png"><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016224318.png"></p>
</li>
</ol>
<p><strong>关于通道映射</strong></p>
<p>我的工程只用了一个通道，如果是台架测试的报文，默认也是通道1，所以通道映射不用修改。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016224107.png"></p>
<p>如果要回放实车报文，需要知道ECU所在的通道，假设ECU所在通道是通道8，就需要将通道8映射到通道1。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016224209.png"></p>
<h1 id="离线回放"><a href="#离线回放" class="headerlink" title="离线回放"></a>离线回放</h1><p>以CANoe工具为例，其他工具的方法大同小异。</p>
<ol>
<li><p>导入DBC文件。</p>
<p>DBC文件是用于描述和解释车辆中CAN网络上传输的数据的数据库文件。主要用来做数据解析：DBC文件包含有关CAN总线上各个信号的信息，例如每个信号的比特位置、长度、比例因子、偏移量等。这些信息使得接收报文的电子控制单元（ECU）或分析人员能够理解报文中的各个数据位代表的物理或逻辑含义。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016224556.png"></p>
</li>
<li><p>导入要回放的文件。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016224654.png"></p>
</li>
<li><p>确定CAN报文中，我们要看的是哪个通道的报文。</p>
<p>可以根据ECU的网络管理报文确认通道，先点start运行，在Trace窗口过滤网络报文ID。确认通道后，要在simulation里面设置，确保通道一致。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016224846.png"></p>
</li>
<li><p>添加想要分析的信号，添加完后，再点一次Start运行。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016225144.png"></p>
</li>
<li><p>设置图形样式，方便查看。按照个人习惯设置即可，一般设置如下：</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016225222.png"></p>
<p>1：选中，用来显示信号图例。</p>
<p>2&#x2F;3：设置光标。</p>
<p>4：不选择，关掉。</p>
<p>5：Start运行后，选择Fit All Signals Y。</p>
<p>6：选择Show Signals in Separate Diagrams（分离显示）。</p>
<p>7：如下图，网格，采样点，纵坐标，都打开。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016225250.png"></p>
</li>
</ol>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>CAN报文时间查看方式：</p>
<ol>
<li><p>在Graphics窗口里面配置；<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016225605.png"></p>
</li>
<li><p>查看时间报文。一般会有ECU节点发送时间报文，时间数据可能来源于GPS，如果没有GPS，则数据不准确。注意：如果是UTC时间，小时的数据会存在相差8小时的情况。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016225731.png"></p>
</li>
</ol>
<h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016225440.png"></p>
<p>如果导入回放文件出现上面这种红色感叹号的图标，那么有可能回放出来的报文，在Trace窗口什么都看不到，但是把文件拖拽到Trace窗口又是有报文的。而且，用notepad++打开也是有数据的。这种情况把文件拖拽到Trace窗口，然后右键export，重新导出asc&#x2F;blf格式，然后保存。再用这个新保存的文件去回放就可以了。</p>
]]></content>
      <categories>
        <category>CAN总线工具</category>
      </categories>
      <tags>
        <tag>报文分析与回放</tag>
      </tags>
  </entry>
  <entry>
    <title>ASPICE文档编写笔记</title>
    <url>/2025/prefix%20remember%20to%20change!!!-728c68a67aa9/</url>
    <content><![CDATA[<h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><p>在软件工程中，有如下的术语定义和关系：</p>
<p><strong>软件单元（Software Unit）</strong>：软件单元是最小的功能单元，通常由一个或几个源代码文件组成。它是系统中最小的测试和维护单元，通常可以单独编译和测试。软件单元在某些上下文中也可以指具体的类、函数、或方法等。</p>
<p><strong>组件（Component）</strong>：组件是由多个软件单元组成的功能模块。组件可以是一个较大的、具有独立功能的软件部分，通常包含多个软件单元。组件可以被多个系统或子系统复用，并且有定义良好的接口与其他组件进行交互。</p>
<p><strong>子系统（Subsystem）</strong>：子系统是由多个组件组成的较大功能模块，通常代表系统中的一个主要功能区域。子系统将组件组织起来，提供更高级别的功能和服务，并可能包括多个组件之间的协作。</p>
<p><strong>模块（Module）</strong>：模块是一个广泛使用的术语，通常指软件系统中的一个独立功能部分，可以是软件单元、组件、子系统等的集合。模块通常用于描述系统的结构和组织，关注于如何将系统分解为多个部分以便于管理和维护。</p>
<p><strong>关系总结：</strong></p>
<ul>
<li><p>软件单元是最小的构建块。</p>
</li>
<li><p>组件由一个或多个软件单元组成。</p>
</li>
<li><p>子系统由多个组件组成。</p>
</li>
<li><p>模块可以是软件单元、组件、子系统等的集合，作为系统的一个功能区块来考虑。</p>
</li>
</ul>
<p>这些术语在不同的上下文中可能会有不同的具体含义，但通常它们都围绕着软件系统的组织和结构进行描述。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017213628.png"></p>
<h1 id="软件需求"><a href="#软件需求" class="headerlink" title="软件需求"></a>软件需求</h1><p>软件需求通常可以分为以下几类：</p>
<p><strong>功能性需求（Functional Requirements）</strong>：描述系统应该执行的功能或服务，包括输入、处理和输出。它们定义了系统应如何响应特定输入或条件。</p>
<p><strong>非功能性需求（Non-Functional Requirements）</strong>：描述系统的性能标准和质量属性，包括：</p>
<ul>
<li><p>性能需求：响应时间、吞吐量等。</p>
</li>
<li><p>安全性需求：数据加密、用户认证等。</p>
</li>
<li><p>可用性需求：系统的可用性和可靠性。</p>
</li>
<li><p>可维护性需求：系统的可维护性和可扩展性。</p>
</li>
</ul>
<p><strong>接口需求（Interface Requirements）</strong>：描述系统与其他系统或组件之间的交互要求，包括API、用户界面和外部系统的通信协议等。</p>
<p><strong>系统需求（System Requirements）</strong>：描述系统内部和外部的需求，包括硬件、软件和网络环境的需求。</p>
<p><strong>约束需求（Constraint Requirements）</strong>：描述在开发和实现过程中需要遵循的限制条件，如法律法规、标准和技术限制。</p>
<p><strong>用户需求（User Requirements）</strong>：描述用户的期望和需求，包括用户体验和交互流程。关注最终用户的需求和使用场景。</p>
<p><strong>业务需求（Business Requirements）</strong>：描述对软件系统的高层期望和目标，通常与商业价值和战略目标相关。</p>
<h1 id="SW-RD"><a href="#SW-RD" class="headerlink" title="SW RD"></a>SW RD</h1><p>软件需求分析，该过程的目的是：将系统需求中与软件相关的部分转化为一组软件需求。</p>
<ol>
<li><p><strong>需求分析</strong>：首先，需要对系统的功能和非功能需求进行彻底分析。这包括理解用户需求和期望，以及分析需求的可行性、正确性、可验证性和对运行环境的影响 。</p>
</li>
<li><p><strong>需求结构化</strong>：将需求进行结构化，以便于管理和跟踪。这包括将需求分类和分组，以及建立需求的层次结构 。</p>
</li>
</ol>
<hr>
<p><strong>定义需求</strong>：在需求分析的基础上，明确和定义软件需求。这包括需求的详细描述、优先级和需求之间的依赖关系 。</p>
<ul>
<li><p>描述需求：</p>
<ul>
<li><p>对每个需求进行详细描述，包括需求编号、需求名称、需求描述、验收标准等。</p>
</li>
<li><p>确保需求是明确、可测试、可追踪的，并且符合SMART原则（具体的、可测量的、可实现的、相关的、有时限的）。</p>
</li>
</ul>
</li>
<li><p>定义功能需求：描述系统应具备的具体功能，包括每个功能的输入、处理和输出。</p>
</li>
<li><p>定义非功能需求：说明性能、可靠性、兼容性、安全性、可维护性、可扩展性等方面的需求。</p>
</li>
<li><p>编写接口需求：描述系统与其他系统或组件之间的接口，包括数据交换格式、通信协议等。</p>
</li>
</ul>
<p><strong>文档管理</strong>：确保文档版本控制，记录修改历史。</p>
<hr>
<ol>
<li><p><strong>需求追溯性</strong>：确保需求具有双向可追溯性，建立系统需求与软件需求之间的双向追溯性，建立系统架构设计与软件需求之间的双向追溯性。即从需求到设计、实现和测试的可追溯性，以及从这些活动回溯到需求的能力。</p>
</li>
<li><p><strong>需求评审</strong>：组织需求评审会议，邀请相关利益相关者参与，确保需求的明确性和无歧义性，并收集反馈进行需求的迭代和改进 。</p>
</li>
<li><p><strong>需求管理计划</strong>：制定需求管理计划，包括需求变更的控制流程、需求状态跟踪和需求的版本控制 。</p>
</li>
<li><p><strong>持续监控和维护</strong>：在软件开发过程中持续监控需求的状态，对需求变更进行管理，并根据需要更新需求文档。</p>
</li>
</ol>
<h1 id="SW-AD"><a href="#SW-AD" class="headerlink" title="SW AD"></a>SW AD</h1><p>软件架构设计，该过程的目的是：建立软件架构设计，识别将哪些软件需求分配给软件的哪些组件，并依照定义的准则来评估软件架构设计。</p>
<ol>
<li><p><strong>需求分析</strong>：了解系统需求和软件需求。</p>
</li>
<li><p><strong>高层架构设计</strong>：描述系统的总体架构，定义系统的子系统&#x2F;主要模块及其之间的交互和依赖关系。</p>
</li>
<li><p><strong>设计决策</strong>：记录架构设计中的关键决策和选择，论述并比较系统中使用的重要技术方案，分析其优缺点。</p>
</li>
<li><p><strong>定义软件架构目标</strong>：明确软件架构设计的目标和约束条件，以及需要满足的关键质量属性（如性能、可维护性、可扩展性等）。</p>
</li>
</ol>
<hr>
<p><strong>子系统&#x2F;模块架构设计</strong>：详细描述子系统&#x2F;模块的内部结构(组件)及其交互方式。</p>
<p><strong>组件定义和描述</strong>：定义并详细描述每个组件的功能和相互关系。</p>
<p><strong>分配软件需求</strong>：将软件需求分配到子系统&#x2F;模块架构设计的组件。</p>
<p><strong>接口定义</strong>：定义组件之间的接口，包括接口功能、输入&#x2F;输出数据(参数和返回值)和通信协议。</p>
<p><strong>描述动态行为</strong>：展示组件间的时序和动态交互，以满足系统所需的动态行为。 动态行为取决于运行模式（例如：启动、关机、正常模式、标定、诊断等）、进程及进程间相互通信、任务、线程、时间片、中断等。</p>
<p><strong>定义资源消耗目标</strong>：资源消耗如：内存(ROM、RAM、外部内部 EEPROM 或 数据闪存）、CPU 负载等。</p>
<hr>
<ol>
<li><p><strong>溯源</strong>：建立软件需求与软件架构设计要素之间的双向可追溯性。</p>
</li>
<li><p><strong>评审</strong>：对架构设计进行内部评审，确保设计符合需求和标准。</p>
</li>
<li><p><strong>文档修订</strong>：根据评审反馈修订文档，完善设计细节。</p>
</li>
<li><p><strong>发布与维护</strong>：发布最终版本的文档，并确保文档在软件开发过程中的持续更新和维护。</p>
</li>
</ol>
<h1 id="SW-DD"><a href="#SW-DD" class="headerlink" title="SW DD"></a>SW DD</h1><p>软件详细设计和单元构建，该过程的目的是：为软件组件提供经过评估的详细设计，并定义和生成软件单元。</p>
<ol>
<li><p><strong>理解需求和架构设计</strong>：在开始详细设计之前，需要对软件的需求有深入的理解，并分析系统架构设计，确保详细设计能够满足这些需求 。</p>
</li>
<li><p><strong>定义软件单元</strong>：根据软件架构设计划分的组件，并进一步将组件划分为可以独立开发和测试的软件单元 。</p>
</li>
</ol>
<hr>
<p><strong>设计概述</strong>：简要描述组件功能，设计方针。</p>
<p><strong>开发详细设计</strong>：具体说明<strong>组件</strong>的内部设计，包括软件单元的接口、数据结构、内部逻辑以及与其他单元的交互等（<mark>每个组件的详细设计都如此，设计完一个组件就继续设计下一个</mark>）</p>
<ul>
<li><p>每个软件<strong>单元</strong>的功能描述</p>
</li>
<li><p>每个软件<strong>单元</strong>的接口设计（包括数据结构、算法和流程图）</p>
<ul>
<li><p>设计外部接口（单元之间的接口也是）</p>
</li>
<li><p>设计内部接口（只在单元内使用的接口）</p>
</li>
</ul>
</li>
<li><p>动态行为</p>
<ul>
<li><p>外部接口：描述软件组件和其他组件的处理时序，如果AD有明确清晰设计，则省略。</p>
</li>
<li><p>内部接口：描述软件<strong>单元之间</strong>的动态行为和交互，使用时序图、状态迁移图等来展示。</p>
</li>
</ul>
</li>
<li><p>状态机图（如适用）</p>
</li>
<li><p>错误处理机制</p>
</li>
</ul>
<p><strong>明确非功能需求</strong>：如性能、资源消耗、安全性等。</p>
<p><strong>评价软件详细设计</strong>：从互操作性、交互、关键性、技术复杂性、风险和可测试性等方面对软件详细设计进行评价 。</p>
<hr>
<ol>
<li><p><strong>溯源</strong>：建立软件需求与软件单元之间的双向可追溯性。建立软件架构设计与软件详细设计之间的双向可追溯性。</p>
</li>
<li><p><strong>评审&#x2F;发布等</strong>：同RD&#x2F;AD。</p>
</li>
</ol>
<h1 id="SW-UT"><a href="#SW-UT" class="headerlink" title="SW UT"></a>SW UT</h1><p>软件单元验证，该过程的目的是：验证软件单元，以提供软件单元符合软件详细设计和非功能性软件需求的证据。</p>
<p>需要对DD文档中的所有 <code>modify/new</code> 函数做单元测试。</p>
<p>输出物：UTS–&gt;UT code –&gt;UTR。</p>
<p><strong>UTS</strong></p>
<p>UTS是做单元验证的指导书，通过UTS可以确定如何做单元测试，需要多少个测试case。</p>
<p>根据函数的圈复杂度来确定被测函数需要多少个测试case，测试case总是要大于等于圈复杂度。</p>
<p><strong>UT code</strong></p>
<p>做单元测试的测试代码。可以使用<code>tessy</code>或<code>googletest</code>进行验证。</p>
<p><strong>UTR</strong></p>
<p>单元测试报告，将测试结果补充到UTS中就是UTR。</p>
<h1 id="SW-IT"><a href="#SW-IT" class="headerlink" title="SW IT"></a>SW IT</h1><p>软件集成及集成测试的核心目的是：通过逐步将软件单元组合成更大的功能模块，最终形成符合架构设计的完整系统，同时在集成过程中对各组件间的接口及整体功能进行验证，确保系统实现与设计规范（特别是模块间接口）的高度一致性。</p>
<h1 id="文档发布流程"><a href="#文档发布流程" class="headerlink" title="文档发布流程"></a>文档发布流程</h1><p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017214234.png"></p>
<h1 id="溯源"><a href="#溯源" class="headerlink" title="溯源"></a>溯源</h1><p>溯源需在文档评审前完成，评审时需要关注上下游溯源和一致性。</p>
<p>溯源需输出溯源报告，未溯源的要分析原因并备注原因。</p>
]]></content>
      <categories>
        <category>ASPICE</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>LIN总线介绍</title>
    <url>/2025/prefix%20remember%20to%20change!!!-bf0b42ffbba4/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>LIN（Local Interconnect Network）总线是在汽车内广泛应用的串行通信协议，它的第一个完整版本 V1.3 发布于 2002 年，在 2016 年LIN总线被正式列为国际标准（ISO 17987）。</p>
<p>LIN总线是针对汽车分布式电子系统而定义的一种低成本的低速串行通讯网络，是对控制器区域网络(CAN)等其它汽车多路网络的一种补充，适用于对网络的带宽、性能或容错功能没有过高要求的应用。</p>
<p>LIN适用于节点数目小于等于 16 个，数据速率 20Kbps 以内的应用场合。</p>
<p>LIN总线相对于CAN的成本节省主要是由于采用单线传输、硅片中硬件或软件的低实现成本和无需在从属节点中使用石英或陶瓷谐振器。这些优点是以较低的带宽和受局限的单宿主总线访问方法为代价的。</p>
<p>LIN总线是基于SCI(UART)数据格式，采用单主控制器&#x2F;多从设备的模式，是UART中的一种特殊情况。</p>
<p>LIN总线上的所有通讯都由主机节点中的主机任务发起，主机任务根据调度表来确定当前的通讯内容，发送相应的帧头，并为报文帧分配帧通道。总线上的从机节点接收帧头之后，通过解读标识符来确定自己是否应该对当前通讯做出响应、做出何种响应。基于这种报文滤波方式，LIN可实现多种数据传输模式，且一个报文帧可以同时被多个节点接收利用。</p>
<h1 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h1><p>开发流程中的核心组件为描述网络特征的 LDF（LIN Description File），LDF定义LIN网络的所有通信特征，通信主机基于LDF可以自动生成通信过程的所有软件组件。同时，LDF可以为测试测量工具提供分析LIN网络所必须的信息。</p>
<p>LIN Configuration Language Specification 定义了创建LDF的过程，创建语法相当简单，可以手动或通过软件工具自动生成LDF。</p>
<p>自 LIN V2.0 规范起，增补的节点统一描述语言可以清晰地说明商用节点（Off-the-Shelf Nodes）设备的通信特征，通过这种 LIN Node Capability Language 描述的节点特征文件称 NCF（Node Capability File），而LIN子网（Cluster）中所有节点NCF正是创建系统LDF的必要条件。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017221518.png"></p>
<h1 id="特点和任务"><a href="#特点和任务" class="headerlink" title="特点和任务"></a>特点和任务</h1><p>LIN总线有如下特点：</p>
<ol>
<li><p>单主控器&#x2F;多从设备模式无需仲裁机制；</p>
</li>
<li><p>低成本，基于通用UART 接口，所有控制机都具备LIN 必需的硬件；</p>
</li>
<li><p>单信号线传输，同时保证信号传输的延迟时间；</p>
</li>
<li><p>LIN具有可预测的电磁兼容性能，为了限制EMC的强度，LIN协议规定最大传输速率为20kbps；</p>
</li>
<li><p>LIN总线提供信号的配置、处理、识别和诊断功能。</p>
</li>
</ol>
<p><strong>主机任务：</strong></p>
<ol>
<li><p>调度总线上帧的传输次序；</p>
</li>
<li><p>监测数据，处理错误；</p>
</li>
<li><p>作为标准时钟参考；</p>
</li>
<li><p>接收从机节点发出的总线唤醒命令；</p>
</li>
<li><p>从机任务不能直接向总线发送数据，需要接受到主节点发送的帧头后，根据帧头所包含的信息来判断。</p>
</li>
</ol>
<p><strong>从机任务</strong>：发送应答，接收应答，忽略应答。</p>
<h1 id="网络拓扑"><a href="#网络拓扑" class="headerlink" title="网络拓扑"></a>网络拓扑</h1><p>LIN总线有其“局域”特性，在汽车中一般不独立存在，通常与上层CAN网络相连，形成CAN-LIN网关节点，通常汽车电子中，整车厂会规定该“网关节点”(主机节点)的控制器归属。</p>
<p>LIN总线拓扑通常为线型，即所有节点设备均通过单线连在一起。主机包括主机任务（Master Task）和从机任务（Slave Task），从机节点只包括从机任务。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017221616.png"></p>
<p>在LIN总线上，主机控制子网内每条消息的传输过程，这种总线访问方式称为授权令牌（Delegated Token）。授权令牌方式的优点是它可以避免消息传输过程的冲突竞争，因为完全由主机协调控制每条消息的应答请求。</p>
<p>LIN总线主机可以根据预设好的调度表（Schedule）规划总线上的数据传输。授权令牌总线访问方式因此被归类为确定性总线访问方式。</p>
<p>授权令牌访问方式的缺点有两点：首先，如果主机失效，则整个总线通信随即失效，因此该方式不适合安全要求高的应用；其次，由于每次通信过程均由主机控制，该方式不适合事件驱动型通信，从机无法自动获取总线访问权以发送数据。为弥补这点缺憾，LIN协议中增补额外的帧类型可以不按授权令牌方式发送消息。</p>
<h1 id="LIN报文帧结构"><a href="#LIN报文帧结构" class="headerlink" title="LIN报文帧结构"></a>LIN报文帧结构</h1><p>LIN报文帧由帧头（Hearder）与应答（Response）两部分组成。传输过程中，主机任务负责发送帧头；从机任务负责接收帧头，然后作出解析决定发送应答，还是接收应答或不回复。</p>
<p><mark>LIN总线显隐性与CAN总线是相同的。</mark></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017221658.png"></p>
<h2 id="同步间隔段"><a href="#同步间隔段" class="headerlink" title="同步间隔段"></a>同步间隔段</h2><p>同步间隔段（Sync Break Field）由同步间隔和同步间隔段间隔符构成，同步间隔是至少持续 13 位（以主机节点的位速率为准）的显性电平，由于帧中的所有间隔或总线空闲时都应保持隐性电平，并且帧中的任何其它字段都不会发出大于 9 位的显性电平，因此同步间隔可以标志一个帧的开始。</p>
<p>同步间隔段的间隔符是至少持续 1 位的隐性电平。</p>
<p>从机任务接收帧头的同步间隔段时，以该从机任务所在节点的位速率为准，当检测总线上出现持续 11 位的显性电平时，认为是帧的开始。当从机节点使用精度较高的时钟时，识别阈值可以选择 9.5 位。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017221730.png"></p>
<h2 id="同步段"><a href="#同步段" class="headerlink" title="同步段"></a>同步段</h2><p>在介绍同步段之前，首先介绍一下字节域(Byte Field)的概念，字节域包括1位起始位(Start Bit，显性) + 8位数据位 + 1位停止位(Stop Bit，隐性)，，这是一种标准UART数据传输格式。在 LIN 的一帧当中，除了同步间隔段，后面的各段都是通过字节域的格式传输的。</p>
<p>在 LIN 帧中，数据传输都是先发送LSB，最后发送 MSB。</p>
<p>LIN总线将下降沿作为判断标志，通过字节0x55（01010101b）进行同步，在从机节点上可以采用非高精度时钟，如果带来偏差，可以通过同步场来调整。</p>
<h2 id="PID段"><a href="#PID段" class="headerlink" title="PID段"></a>PID段</h2><p>受保护的ID，其前6位为帧ID(依据节点LDF生成)，加上两个奇偶效验码称作受保护的ID。</p>
<p>帧ID的取值范围为0x00~0x3F，共64个，帧ID标识了帧的类别和目的地，从机任务会根据帧头ID作出反应(接收&#x2F;发送&#x2F;忽略应答)，其中P0与P1效验如下：</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017221800.png"></p>
<p>其中“⊕”代表“异或”运算，“¬”代表“取非”运算。由公式可以看出，PID 不会出现全 0 或全 1 的情况，因此，如果从机节点收到了“0xFF”或“0x00”，可判断传输错误。</p>
<h2 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h2><p>包含1-8个字节，可以分为两种数据类型，信号和诊断消息。信号由信号携带帧传递，诊断消息由诊断帧传递。</p>
<p>LIN2.x规定可传输的LIN字节数为2，4，8，并不是1-8内任意一个数字。一般而言，车内会选择统一字节数，最常用的是每帧传递8个字节。</p>
<p>与CAN总线不同，LIN协议中并没有规定数据长度的信息，数据内容和长度均由系统设计者根据帧ID提前设定。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017221833.png"></p>
<h2 id="校验和段"><a href="#校验和段" class="headerlink" title="校验和段"></a>校验和段</h2><p>效验分为标准型效验与增强型效验。采用标准型还是增强型是由主机节点管理，发布节点和收听节点根据帧ID来判断采用哪种效验和。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017221859.png"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017221916.png"></p>
<h1 id="帧类型"><a href="#帧类型" class="headerlink" title="帧类型"></a>帧类型</h1><p>LIN总线根据帧ID的不同，将报文分为信号携带帧、诊断帧、保留帧。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017221944.png"></p>
<p><mark>从机应答帧是一个完整的帧，与帧结构中的“应答”不是一个概念。</mark></p>
<ol>
<li><p>无条件帧</p>
<p>无条件帧是具有单一发布节点的，无论信号是否发生变化，帧头均会被无条件应答的帧。无条件帧在主机任务分配给它的固定的帧时隙（Reserved Frame Slot）中传输。总线上一旦有帧头发送出去，必须有从机任务作应答(即无条件发送应答)。</p>
</li>
<li><p>事件触发帧</p>
<p>事件触发帧是主机节点在一个帧间隙中，<mark>主机查询</mark>各从机节点的信号是否发生变化时使用的帧。当从机节点信号发生变化的频率较低时，主机任务查询各个节点信息会占用一定的带宽。为了减小带宽的占用，引入了事件触发帧的概念。</p>
<p>其主要原理就是：</p>
<p>当从机节点信息状态没有发生变化的时候，从机节点可以不应答主机发出的帧头；当有多个节点信息同时发生变化的时候，同时应答事件触发帧头会造成总线的冲突。当主机节点检测到冲突时，便会执行冲突解决调度表，通过发送无条件帧轮询所有从机来确定从机节点的信息状态。</p>
<p>因为无条件帧只有1个节点应答，同一个 PID 的事件触发帧和无条件帧对应的第一个字节数据是相同的，即，如果从机的数据已更新，则它会做出响应，其受保护的ID位于第一个数据字节中。当多个从机同时响应时，它们各自的应答信号会在总线上产生叠加，造成电压水平异常。由于LIN总线的物理层特性，主机能够通过检测这种电压水平的变&#x2F;response_error来识别出，发生了冲突。</p>
</li>
<li><p>偶发帧</p>
<p>偶发帧是主机节点在同一帧时隙中，当自身信号发生变化时向总线发送的帧。当存在多个关联的应答信号变化时，通过预先设定的优先级来仲裁。偶发帧主要用于<mark>主机发送</mark>不经常变化的信息，可以理解为主机用的事件触发帧。与事件触发帧类似，偶发帧也定义了一组无条件帧。规定：偶发帧只有由主机节点发布。</p>
<p>主机节点上面也有信息需要告诉从机节点，当主机节点检测到某个无条件帧的信号发生变化时，它会在适当的时机（即偶发帧的时隙）将这个变化发送出去。</p>
</li>
<li><p>诊断帧</p>
<p>包括主机请求帧和从机应答帧，主要用于配置、识别和诊断。</p>
<ul>
<li><p>主机请求帧ID&#x3D;0x3C，应答部分的发布节点为主机节点；</p>
</li>
<li><p>从机应答帧ID&#x3D;0x3D，应答部分的发布节点为从机节点。</p>
</li>
<li><p>数据场规定为8个字节，一律采用标准效验和。</p>
</li>
</ul>
</li>
</ol>
<h2 id="偶发帧"><a href="#偶发帧" class="headerlink" title="偶发帧"></a>偶发帧</h2><p>偶发帧的传输可能出现 3 种状况：</p>
<ol>
<li><p>当关联的无条件帧没有信号发生变化时，该时隙保持沉默，<mark>主机节点</mark>连帧头都不需要发送；</p>
</li>
<li><p>当其中一个关联的无条件帧包含的信号发生了变化， 则<mark>发送</mark>该关联的无条件帧的<mark>应答部分</mark>，如图15上半部分所示；</p>
</li>
<li><p>如果有两个或以上关联的无条件帧包含的信号发生了变化，则按照事先规定好的优先级，优先级较高的关联的无条件帧获得发送权，优先级较低的要等到下一个偶发帧的帧头到来时才能<mark>发送</mark>应答。由于<mark>主机节点是唯一的发布节点</mark>，所以主机节点事先就知道各个关联信号的优先级别，这样在传输时不会产生冲突，如图15下半部分所示。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017222307.png"></p>
<h1 id="调度表"><a href="#调度表" class="headerlink" title="调度表"></a>调度表</h1><p>调度表规定了总线上帧的传输次序以及传输时间。调度表位于主机节点，主机任务根据应用程序需要进行调度。</p>
<p>调度表可以有多个，一般情况下，轮到某个调度表执行的时候，从该调度表的入口处开始执行，到调度表的最后一个帧时，如果没有新的调度表启动则返回到当前调度表的第一个帧开始执行；也有可能在执行到某个调度表时发生中断，跳到另一个调度表后再返回，如事件触发帧就是典型的例子。</p>
<h2 id="主机状态机"><a href="#主机状态机" class="headerlink" title="主机状态机"></a>主机状态机</h2><p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017222347.png"></p>
<p>在总线开始工作时，主机随即启动主机任务，周期性地执行调度表（Schedule）规定的消息发送程序。下表示意LIN总线调度表的内容，在调度表中包括各项消息 PID（Message Header）和启动时间。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017222408.png"></p>
<h2 id="从机状态机"><a href="#从机状态机" class="headerlink" title="从机状态机"></a>从机状态机</h2><p>从机任务负责发布或者接听帧的应答状态，包括连两个状态机：同步间隔段与同步段检查器、帧处理器。</p>
<p>从机任务状态机中，检测同步间隔段和同步段序列，要求节点处于任何状态下都能识别出该序列，包括已经检测到序列或进入帧处理的状态。</p>
<p>帧处理包括接收并分析PID，接收数据，接收校验和，发送数据和发送校验和，对接收到的受保护ID进行分析，按照事先的设计，选择是接收应答部分，还是发送应答部分，或不接收也不发送。在五个子状态中，如果收到同步间隔段或同步段序列，将重新跳到“接收并分析PID”的子状态，通信不停止，根据需要置位相应的错误标志。</p>
<h1 id="帧传输时间"><a href="#帧传输时间" class="headerlink" title="帧传输时间"></a>帧传输时间</h1><p>在消息调度中，协议为单条消息定义 Slot 的概念，Slot持续的时间必须大于帧头（Frame Header）和消息应答（Response）的时间以保证消息传送完毕。单个帧总是在同一个Slot内传输完的。考虑到收发器性能的影响，LIN协议规定单个消息传输时间有40%裕量，即帧的最小持续时间为其典型持续时间的1.4倍。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017222504.png"></p>
<p>若同步间隔段是 13 bit 显性位 + 1 bit 隐性位，则帧头计 34 bit。应答包括数据段和校验和段，根据数据段长度的不同，应答最短为 20 bit（数据段 1 Byte），应答最长为 90 bit（数据段 8 Byte）。综上， LIN总线的帧最长为 124 bit（数据段 8 Byte），最短为 54 bit（数据段 1 Byte）。</p>
<p>帧的额定传输时间计算公式如下</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017222531.png"></p>
<p>LIN协议规定帧的最大传输时间为额定传输时间的 1.4 倍，即为帧传输预留 40% 的裕量。该特性是考虑到总线上节点设备性能参差不齐，允许节点不必收到指令后立即执行。也就是说，协议允许节点推迟下一个 UART 字符的发送。</p>
<p>帧的最大传输时间计算公式如下：</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017222553.png"></p>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>协议强制规定， 每个从机节点都要在它发布的某个无条件帧中包含一个长度为一位的标量信号 response_error，向主机节点报告自身状态。 主机节点负责接收这个信号并且执行分析，如下表所示。事件触发帧由于允许总线冲突，需特殊处理。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017222622.png"></p>
<p>LIN 协议并没有标准化错误类型，用户可根据需要自行制定。 下表列出了可能出现的一些错误类型供参考。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017222644.png"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.wangdali.net/lin/">http://www.wangdali.net/lin/</a></p>
<p><a href="https://blog.csdn.net/dailbing/article/details/124248328">https://blog.csdn.net/dailbing/article/details/124248328</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/357967013">https://zhuanlan.zhihu.com/p/357967013</a></p>
<p><a href="https://news.eeworld.com.cn/qrs/article_2018012444047.html">https://news.eeworld.com.cn/qrs/article_2018012444047.html</a></p>
]]></content>
      <categories>
        <category>汽车与工业网络</category>
      </categories>
      <tags>
        <tag>LIN</tag>
      </tags>
  </entry>
  <entry>
    <title>个人学习分享</title>
    <url>/2025/prefix%20remember%20to%20change!!!-3bef8c1b86a0/</url>
    <content><![CDATA[<h1 id="关于学习的思考"><a href="#关于学习的思考" class="headerlink" title="关于学习的思考"></a>关于学习的思考</h1><p>我认为的高效学习：在有限时间内，精准获取所需知识，并能有效内化和应用。</p>
<p>我对学习的看法：知识是学不完的，论学习能力也比不上AI。我的观点是面向问题学习，让AI成为认知加速器。</p>
<p>AI是认知的杠杆： 将AI视为研究助理、翻译器、知识连接器和初稿生成器，可以大幅提升工作效率。比如：</p>
<ul>
<li><p>客户邮件翻译</p>
</li>
<li><p>需求文档的翻译和理解</p>
</li>
</ul>
<p>传统的翻译，翻译完后，也不一定能够理解对方想表达的意思。AI翻译不只是翻译，还会做出解释，这样效率更高。</p>
<h1 id="高效获取信息与知识"><a href="#高效获取信息与知识" class="headerlink" title="高效获取信息与知识"></a>高效获取信息与知识</h1><p><strong>信息源选择</strong></p>
<p>获取信息&#x2F;资料的信息源：官方文档 &gt; 官方论坛 &gt; 博客&#x2F;论文。 官方文档包括：</p>
<ul>
<li><p>官方网站的文档区域</p>
</li>
<li><p>SDK&#x2F;软件包，其中的 <code>README</code>、 <code>docs</code>、 <code>example</code>等目录</p>
</li>
<li><p>官方源代码仓库（GitHub 等）中的文档文件</p>
</li>
<li><p>官方提供的 API 参考</p>
</li>
<li><p>官方入门教程和指南</p>
</li>
</ul>
<p><strong>利用公司资源</strong></p>
<p>内部Wiki、知识库、过往项目文档。比如飞书云文档，可以在里面搜索想要了解的知识。</p>
<p><strong>利用AI找资料</strong></p>
<p>比如：项目需要使用共享内存，实现MCU和SOC之间的数据交互。</p>
<p>以<code>KIMI</code>为例，找资料的时候，要打开接入互联网功能，不开的话，因为训练大模型使用的数据不是最新的，有些东西可能找不到。打开接入互联网的功能，就会通过互联网搜索资料。如果使用的AI工具不支持联网功能，不建议用来找资料。长思考主要用来分析一些复杂问题，如果只是收集信息，可以打开也可以不开。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017205152.png"></p>
<ol>
<li><p>假设项目用的芯片是TI的芯片。首先询问TI德州仪器的官网网址是多少？我们可以从回答里面看到阅读了哪些网页，展开后可以看看网页标题和简介，哪些与我们要找的信息强相关，可以点击对应的链接看看。<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017205235.png"></p>
</li>
<li><p>进入官网，在最底部可以找到官方论坛。<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017205324.png"></p>
</li>
<li><p>在官方论坛搜索IPC rpmsg相关的帖子，里面会有一些意想不到的收获。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017205415.png"></p>
</li>
<li><p>基于官网和官方论坛找资料。找软件安装包的下载地址也是一样的方法。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017205511.png"></p>
</li>
<li><p>rpmsg原理资料收集。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017205551.png"></p>
</li>
<li><p>了解基本概念后，继续了解实现流程。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017205634.png"></p>
</li>
<li><p>在有一定的概念后，再去尝试寻找代码示例，这样才能准确表达想要找的东西是什么。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017205710.png"></p>
<p>最终引用的是官方论坛里面的一个帖子，上面的回复有提到一个demo的仓库地址。所以说官方论坛的帖子也是很重要的，有些资料藏得很深，只有TI的开发&#x2F;员工能找得到。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017205732.png"></p>
</li>
</ol>
<p>最终收集信息如下：</p>
<ul>
<li><p>MCU SDK介绍文档： <a href="https://software-dl.ti.com/mcu-plus-sdk/esd/AM62AX/09_02_00_38/exports/docs/api_guide_am62ax/IPC_GUIDE.html">Understanding inter-processor communication (IPC)</a></p>
</li>
<li><p>SOC SDK介绍文档：<a href="https://software-dl.ti.com/processor-sdk-linux/esd/AM62AX/latest/exports/docs/linux/Foundational_Components_IPC62ax.html">3.7. IPC for AM62ax &mdash; Processor SDK AM62Ax Documentation</a></p>
</li>
<li><p>官方论坛：<a href="https://e2e.ti.com/search?q=ipc&category=forum">Search - TI E2E support forums</a></p>
</li>
<li><p>代码示例：<a href="https://git.ti.com/cgit/rpmsg/rpmsg_char_zerocopy/">https://git.ti.com/cgit/rpmsg/rpmsg_char_zerocopy&#x2F;</a></p>
</li>
<li><p>高质量技术博客&#x2F;论文：<a href="https://openamp.readthedocs.io/en/latest/protocol_details/index.html">OpenAMP Design Details &mdash; OpenAMP documentation</a></p>
</li>
</ul>
<h1 id="学习习惯"><a href="#学习习惯" class="headerlink" title="学习习惯"></a>学习习惯</h1><p>流程：收集 -&gt; 速览(建框架) -&gt; 主题聚焦 -&gt; 精读(核心) -&gt; 即时笔记(防忘) -&gt; 整理(内化)。 </p>
<p><strong>第一阶段：广泛收集与初步吸收</strong></p>
<ul>
<li><p>行动： 围绕目标主题，广泛收集相关资料（遵循信息源优先级：官方文档 &gt; 官方论坛 &gt; 博客&#x2F;论文）。</p>
</li>
<li><p>方法： 对所有收集的资料进行快速通读，目标是：</p>
<ul>
<li><p>建立整体印象和知识框架。</p>
</li>
<li><p>识别核心概念、关键特性和潜在难点。</p>
</li>
<li><p>此阶段不求深度理解，重在扫盲和定位。</p>
</li>
</ul>
</li>
</ul>
<p><strong>第二阶段：聚焦主题，深度理解</strong></p>
<ul>
<li><p>方法：采用主题阅读法</p>
<ul>
<li><p>速览定位：快速浏览多个来源的目录、图表、摘要和章节标题，锁定与主题相关的核心章节。</p>
</li>
<li><p>精读核心：集中精力深入阅读与当前学习目标最相关、最重要的核心章节（如实现原理、协议机制、关键特性）。</p>
</li>
</ul>
</li>
<li><p>核心原则： 深度优先，聚焦核心，避免在非关键信息上过度耗时。</p>
</li>
</ul>
<p><strong>第三阶段：即时输出，强化记忆与理解</strong></p>
<ul>
<li><p>行动：边学边记</p>
<ul>
<li><p>重要性： 在阅读精读核心内容的同时，强制自己输出笔记。 避免遗忘。</p>
</li>
<li><p>形式： 不拘泥于完美结构，想到什么写什么，优先记录：</p>
<ul>
<li><p>关键概念的定义。</p>
</li>
<li><p>核心原理、机制的理解（用自己的话复述）。</p>
</li>
<li><p>重要的命令、API、配置片段（直接复制代码&#x2F;命令）。</p>
</li>
<li><p>产生的疑问和思考。</p>
</li>
</ul>
</li>
<li><p>心态： 接受此时的笔记可能是草稿或碎片化，目标是即时捕捉想法和知识点。</p>
</li>
</ul>
</li>
</ul>
<p><strong>第四阶段：应用与迭代</strong></p>
<ul>
<li><p>行动：事后整理</p>
<ul>
<li><p>时机：已经应用到实际项目上，基本掌握该知识&#x2F;技能时，整理总结，加深理解。</p>
</li>
<li><p>目标：将碎片化笔记整理成结构化、易检索、有价值的笔记。</p>
</li>
</ul>
</li>
</ul>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p><strong>笔记工具</strong></p>
<p>飞书云文档，支持双向链接，方便知识关联、更新和分享，还可以利用AI速览，总结笔记重点。</p>
<p><strong>信息获取</strong></p>
<p>通用对话AI (认知加速核心)：</p>
<ul>
<li><p>官方DeepSeek：不符合公司安全规范，需要注意使用场景，项目资料等信息需要保密。<a href="%5Bhttps://chat.deepseek.com/%5D(https://chat.deepseek.com/)"><a href="https://chat.deepseek.com/">https://chat.deepseek.com/</a></a></p>
</li>
<li><p>Kimi：不符合公司安全规范，需要注意使用场景，项目资料等信息需要保密。<a href="%5Bhttps://www.kimi.com/%5D(https://www.kimi.com/)"><a href="https://www.kimi.com/">https://www.kimi.com/</a></a></p>
</li>
</ul>
<p>聚合类：<a href="https://www.aigc.cn/#term-1903">https://www.aigc.cn/#term-1903</a></p>
<p><strong>AI 的幻觉&#x2F;错误</strong></p>
<p>永远保持批判性思维！ AI的输出不一定都是正确的。AI是助手，我们才是决策者和责任人，可以同时向多个AI提出相同的问题，对比判断。</p>
]]></content>
      <categories>
        <category>个人成长</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>IPC共享内存调试</title>
    <url>/2025/prefix%20remember%20to%20change!!!-25bc31419109/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>由于 RPMsg 一次只能传递 496 字节的信息(在Linux系统中，RPMsg的最大大小包括16字节的头部，因此消息的有效载荷大小为512 - 16 &#x3D; 496字节)，而CAN升级过程中需要传输的数据量是很大的，这样会很影响升级速率。因此，考虑在共享内存区域中传递大量数据，这样会更加高效。</p>
<p>参考 <code>RPMsg_char zerocopy</code> 示例，了解如何定义一个共享内存区域来在 Linux 和远程核心之间传递数据，然后使用 <code>RPMsg</code> 作为信号机制，在共享内存区域准备好读取时通知另一个核心。</p>
<h1 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h1><h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><p>IPC代表“处理器间通信”。IPC可以是处理器核心之间的任何形式的通信。TI AM62Ax可以支持多种IPC实现。</p>
<p><strong>IPC涉及核心</strong>：A53，MCU R5F，DM R5F 硬件支持的IPC特性：</p>
<ol>
<li><p>Interrupt：中断通常是从一个处理器核心传输信息到另一个处理器核心的最快方式。</p>
</li>
<li><p>Mailbox：将邮箱想象为与32位寄存器配对的中断信号。IPC Notify机制就是使用邮箱实现。</p>
</li>
<li><p>Spinlock：自旋锁可以用来协调对共享资源的访问。这有助于同步在不同处理器核心上运行的软件。</p>
</li>
</ol>
<p><strong>轮询与中断</strong></p>
<p>处理器核心接收来自另一核心信息的两种主要方法是：</p>
<ul>
<li><p>轮询：接收核心，手动检查更新的信息</p>
</li>
<li><p>中断：接收核心，继续运行自己的软件，直到被中断（通常由中断或邮箱触发）</p>
</li>
</ul>
<p>一些核心结合了硬件中断和软件轮询。在这种情况下，接收到硬件中断，处理器核心必须手动轮询核心的中断控制器（INTC），以查看是否接收到中断，并处理任何额外的信息（如触发了哪个中断）。</p>
<p><strong>内存</strong></p>
<p>可以为以下内容分配DDR或片上内存区域：</p>
<ul>
<li><p>IPC协议</p>
<ul>
<li>IPC RPMsg</li>
</ul>
</li>
<li><p>共享内存区域</p>
<ul>
<li><p>共享内存区域由发送核心直接写入，并由接收核心读取</p>
</li>
<li><p>共享内存区域可以小到一个 32 位字，也可以大到足以容纳千字节或兆字节的数据</p>
</li>
</ul>
</li>
</ul>
<p><strong>延迟与吞吐量</strong></p>
<ul>
<li><p>平均延迟：平均而言，IPC可能需要在特定时间内完成</p>
</li>
<li><p>最坏情况延迟：IPC可能需要始终在特定时间内完成</p>
</li>
<li><p>数据吞吐量：可能需要在特定时间内在核心之间传输一定量的数据</p>
</li>
</ul>
<p>许多设计对IPC有特定要求，一般来说：</p>
<ul>
<li><p>中断、邮箱（IPC Notify）：低延迟，低数据吞吐量</p>
</li>
<li><p>IPC RPMsg：易于实现，但没有针对延迟或吞吐量进行优化</p>
</li>
<li><p>共享内存区域：更高的延迟，更高的数据吞吐量</p>
</li>
</ul>
<p><strong>IPC SW Architecture</strong></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251018204356.png"></p>
<p><strong>IPC设计模式</strong></p>
<p>以下是使用IPC RP消息在“client-serve”模式下的一个典型设计模式。</p>
<ol>
<li><p>server端</p>
<p>一个服务器CPU通常提供某些服务，例如进行一些计算或读取某个传感器，</p>
<ul>
<li><p>服务器创建一个RP消息端点，一个端点是任何16位数字，然而在实现中，限制为<code>RPMESSAGE_MAX_LOCAL_ENDPT </code>，以便实现低内存占用，并且仍然保持高效能。</p>
</li>
<li><p>一个端点在某种程度上类似于UDP中的端口，而CPU ID在某种程度上类似于IP地址。因此，给定一个CPU ID和该CPU上的端点，任何其他CPU都可以向其发送消息或数据包。这个端点值对于所有希望与其通信的CPU来说是预先知道的，他们也知道所提供的服务的性质。</p>
</li>
<li><p>然后，服务器在这个端点等待接收消息。当它收到一条消息时，消息包指示要执行的操作，通常是通过包的命令ID来指示。</p>
</li>
<li><p>包还包含特定于命令的参数。参数需要适应包缓冲区，如果参数数量很大或参数本身是大量数据，则包缓冲区内的参数应该指向另一个更大的共享内存，该共享内存保存实际数据或附加参数。</p>
</li>
<li><p>作为接收到的消息的一部分，服务器还知道发送者CPU ID和发送者回复端点。处理完消息后，服务器可以向发送者发送一个包括处理结果的“确认”消息，它本身就是另一个消息包，它可以有命令状态和返回参数。</p>
<p>服务器CPU可以创建多个端点，每个端点提供逻辑上不同的服务。使用单独的RTOS任务来等待给定端点上接收的消息是一个非常常见的设计选择。</p>
</li>
</ul>
</li>
<li><p>client端</p>
<p>一个客户端CPU可以向上述服务器端点发送消息，</p>
<ul>
<li><p>创建一个RP消息端点来接收“确认”消息。这个端点可以是任何值，不需要与服务器端点匹配。</p>
</li>
<li><p>调用发送API，传入服务器CPU ID、服务器端点ID和回复端点ID。</p>
</li>
<li><p>发送API填充要发送的包，其中填充了要执行的命令和命令的参数。发送包后，等待回复。收到回复后，处理回复状态和结果。</p>
</li>
</ul>
</li>
</ol>
<p>类似的设计模式也可以用于IPC Notify，只是在这种情况下，消息包只能是一个28位的消息值。而且端点值必须小于 <code>IPC_NOTIFY_CLIENT_ID_MAX</code>。</p>
<h2 id="RPmsg"><a href="#RPmsg" class="headerlink" title="RPmsg"></a>RPmsg</h2><p>RPMsg是一种标准化的IPC协议。RPMsg创建作为共享内存的VRING缓冲区，发送核心将RPMsg消息放入VRING缓冲区，然后使用邮箱或中断通知接收核心有消息等待。VRING 共享内存地址由 Linux 设备树中的值确定，并放置在 DDR 中。</p>
<p><strong>IPC实现</strong></p>
<p>RPMsg可用于MCU+核心之间的通信，或用于Linux与运行MCU+ SDK的核心之间的通信。</p>
<p>TI为MCU核心和Linux核心提供了RPMsg驱动程序，以及仅适用于MCU核心的IPC Notify驱动程序。</p>
<ol>
<li><p>IPC Notify</p>
<p>IPC Notify运行在MCU+核心上（FreeRTOS或裸机&#x2F;NORTOS）。IPC Notify只能用于运行MCU+ SDK的核心之间的通信。TI不支持使用IPC Notify与Linux交互。</p>
<p>优点：低延迟，通过使用邮箱，IPC Notify能够在MCU+核心之间实现微秒级的延迟。</p>
</li>
<li><p>IPC RPMsg and Linux RPMsg</p>
<ul>
<li><p>IPC RPMsg运行在MCU+核心上。</p>
</li>
<li><p>Linux RPMsg运行在Linux上。</p>
</li>
</ul>
</li>
</ol>
<p><strong>IPC RPMsg具体细节</strong></p>
<ul>
<li><p>MCU+ core to MCU+ core</p>
<ul>
<li><p>消息大小和消息缓冲区数量是可配置的</p>
</li>
<li><p>共享内存可以在DDR或内部存储器中</p>
</li>
</ul>
</li>
<li><p>MCU+ core to Linux core</p>
<ul>
<li><p>消息大小和消息缓冲区数量是固定的</p>
</li>
<li><p>共享内存在DDR中</p>
</li>
</ul>
</li>
</ul>
<p><strong>Linux RPMsg具体细节</strong></p>
<p>Linux RPMsg驱动程序可以从Linux用户空间（例如，Linux应用程序）或从Linux内核空间（例如， Linux驱动程序）启用RPMsg。Linux RPMsg旨在易于使用，而不是优化延迟或数据吞吐量。</p>
<ul>
<li><p>共享内存在DDR中而不是内部存储器中</p>
</li>
<li><p>固定的RPMsg数据包大小。总数据包大小为512字节，496字节的数据，16字节的头</p>
</li>
<li><p>Linux用户空间不直接读取VRING缓冲区。相反，数据被多次复制以在Linux用户空间和远程核心之间传输。</p>
</li>
</ul>
<p><strong>RPmsg协议介绍见</strong>：</p>
<p><a href="https://www.jianshu.com/p/c7cdad8273ed">RPMsg：协议简介 - 简书</a></p>
<p><a href="https://www.cnblogs.com/mic-chen/p/18217210">核间通信：RPMsg和OpenAMP - Mic_chen - 博客园</a></p>
<p><a href="https://openamp.readthedocs.io/en/latest/protocol_details/index.html">OpenAMP Design Details — OpenAMP documentation</a></p>
<p><a href="https://blog.csdn.net/qq_21438461/article/details/142793235">【核间通讯】深入解析 Virtio 和 RPMsg：多处理器通信的开放标准与应用实践-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/huang987246510/article/details/103739592">VirtIO实现原理——vring数据结构-CSDN博客</a></p>
<p><a href="https://oenhan.com/virtio-vring">virtIO vring工作机制分析 | OenHan</a></p>
<p><a href="https://cloud.tencent.com/developer/article/2395658">多核异构通信框架（RPMsg-Lite）-腾讯云开发者社区-腾讯云</a></p>
<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p><code>RPMsg_char zerocopy</code> 这个仓库，展示了如何使用 <code>rpmsg_char</code>API 在 Linux 主机和远程 M4F 或 R5F MCU 端点之间传递共享内存数据。</p>
<p>仓库地址：<a href="https://git.ti.com/cgit/rpmsg/rpmsg_char_zerocopy/">rpmsg&#x2F;rpmsg_char_zerocopy</a></p>
<ul>
<li><p>master分支：适用 Linux 内核 6.6 或更高版本（SDK 10.x）。</p>
</li>
<li><p>ti-linux-6.1 分支：适用 Linux 内核 5.10（SDK 8.x）或 Linux 内核 6.1（SDK 9.x）。</p>
</li>
<li><p>linux目录：基于通用 Linux 的 <code>rpmsg_char</code>示例。</p>
</li>
<li><p>rtos目录：包含了针对 AM64x&#x2F;R5F、AM62x&#x2F;M4F 和 AM62Ax&#x2F;C71&#x2F;R5F 的 FreeRTOS 部分示例。</p>
</li>
</ul>
<p>查看Linux 内核版本，可以在终端或命令行界面中使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251018204603.png"></p>
<h2 id="Demo流程说明"><a href="#Demo流程说明" class="headerlink" title="Demo流程说明"></a>Demo流程说明</h2><ol>
<li><p>Linux端用指定的数据填充共享内存缓冲区。在访问 <code>mmapped </code>区域前后使用<code>DMA_BUF_IOCTL_SYNC</code>ioctl进行非常基础的缓存一致性管理。</p>
</li>
<li><p>将缓冲区的物理地址、缓冲区大小和填充的固定数据通过rpmsg发送到远程端点(MCU)，并开始等待响应。</p>
</li>
<li><p>远程MCU将验证缓冲区数据，然后反转数据，用新数据填充缓冲区，并发送响应。</p>
</li>
<li><p>当Linux收到来自远程端点的消息时，验证与远程端共享的内存中的模式。</p>
</li>
</ol>
<p>注意：填充共享内存缓冲区，也就是往共享内存写数据后，对端是不知道应用程序什么时候写的。所以在这里，rpmsg其实起到了通知的作用，实际上是产生了邮箱或中断通知，否则就需要轮询检查是否有新的数据。</p>
<p>这个示例与 ipc_rpmsg_echo_linux 示例类似，有几个关键的不同点：</p>
<ul>
<li><p>创建了一个单一的 rpmsg 端点，用于与用户空间 Linux <code>rpmsg_char</code> 应用程序通信。</p>
</li>
<li><p>通过 rpmsg 通道交换包含共享内存描述符的⼆进制消息。共享数据位于共享内存中，不通过rpmsg 通道交换。</p>
</li>
<li><p>不与其他 CPU 交换任何消息。</p>
</li>
</ul>
<h2 id="API说明"><a href="#API说明" class="headerlink" title="API说明"></a>API说明</h2><h3 id="Typedef说明"><a href="#Typedef说明" class="headerlink" title="Typedef说明"></a>Typedef说明</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(* RPMessage_RecvCallback)</span> <span class="params">(RPMessage_Object *obj, <span class="type">void</span> *arg, <span class="type">void</span></span></span><br><span class="line"><span class="params">*data, <span class="type">uint16_t</span> dataLen, <span class="type">uint16_t</span> remoteCoreId, <span class="type">uint16_t</span> remoteEndPt)</span></span><br><span class="line">`RPMessage_RecvCallback` 是一个回调函数类型定义，它在从指定的本地端点接收到任何CPU发</span><br><span class="line">送的消息时被调用。</span><br><span class="line"></span><br><span class="line">这个回调函数可以在 `RPMessage_construct` 期间选择性注册。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">回调函数中必须处理所有消息内容。当回调函数返回时，消息缓冲区会被释放回发送者。</span><br><span class="line">如果需要延迟处理消息内容，则需要复制消息内容。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">`obj` [in] 使用 `RPMessage_construct` 创建的RPMessage端点对象。</span><br><span class="line">`arg` [in] 用户在 `RPMessage_construct` 期间指定的参数。</span><br><span class="line">`data` [in] 指向消息的指针。</span><br><span class="line">`dataLen` [in] 消息的⻓度。</span><br><span class="line">`remoteCoreId` [in] 发送方的核ID。</span><br><span class="line">`remoteEndPt` [in] 发送方的端点。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(* RPMessage_RecvNotifyCallback)</span> <span class="params">(RPMessage_Object *obj, <span class="type">void</span></span></span><br><span class="line"><span class="params">*arg)</span></span><br><span class="line">`RPMessage_RecvNotifyCallback` 是一个回调函数类型定义，它在从指定的本地端点接收到任何</span><br><span class="line">CPU发送的消息时被调用。</span><br><span class="line"></span><br><span class="line">这个回调函数可以在 `RPMessage_construct` 期间选择性注册。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">与 `RPMessage_RecvCallback` 不同，这个回调函数仅通知有一条或多条消息待读取，</span><br><span class="line">但消息本身不会被驱动程序读取，除非在该回调函数中或之后的某个任务中调用了</span><br><span class="line">`RPMessage_recv`。</span><br><span class="line">如果设置了 `RPMessage_RecvCallback`，则不会使用 `RPMessage_RecvNotifyCallback` 回</span><br><span class="line">调函数。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">`obj` [in] 使用 `RPMessage_construct` 创建的RPMessage端点对象。</span><br><span class="line">`arg` [in] 用户在 `RPMessage_construct` 期间指定的参数。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(* RPMessage_ControlEndPtCallback)</span> <span class="params">(<span class="type">void</span> *arg, <span class="type">uint16_t</span></span></span><br><span class="line"><span class="params">remoteCoreId, <span class="type">uint16_t</span> remoteEndPt, <span class="type">const</span> <span class="type">char</span> *remoteServiceName)</span></span><br><span class="line">`RPMessage_ControlEndPtCallback` 是一个回调函数类型定义，在控制端点上接收到通知消息</span><br><span class="line">时调用的回调。</span><br><span class="line"></span><br><span class="line">这个回调函数可以在 `RPMessage_init` 期间选择性注册。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">与 `RPMessage_RecvCallback` 类似，回调函数中必须处理所有消息内容。</span><br><span class="line">当回调函数返回时，消息缓冲区会被释放回发送者。如果需要延迟处理消息内容，则需要复制消息内</span><br><span class="line">容。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">`arg` [in] 用户在 `RPMessage_init` 期间指定的参数。</span><br><span class="line">`remoteCoreId` [in] 发送方的核ID。</span><br><span class="line">`remoteEndPt` [in] 在控制端点上宣布服务的发送者的端点。</span><br><span class="line">`remoteServiceName` [in] 被宣布的远程服务的名称。</span><br></pre></td></tr></table></figure>

<h3 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RPMessage_Params_init</span><span class="params">(RPMessage_Params * params)</span></span><br><span class="line"></span><br><span class="line">`<span class="title function_">RPMessage_Params_init</span><span class="params">()</span>` 函数用于为 `RPMessage_Params` 结构体设置默认值。</span><br><span class="line">参数：</span><br><span class="line">`params` [out] 需要被初始化为默认值的结构体。</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RPMessage_CreateParams_init</span><span class="params">(RPMessage_CreateParams * params)</span></span><br><span class="line"></span><br><span class="line">`<span class="title function_">RPMessage_CreateParams_init</span><span class="params">()</span>` 函数用于为 `RPMessage_CreateParams` 结构体设置默</span><br><span class="line">认值。 </span><br><span class="line">参数：</span><br><span class="line">`params` [out] 需要被初始化为默认值的结构体。</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">RPMessage_init</span><span class="params">(<span class="type">const</span> RPMessage_Params * params)</span></span><br><span class="line"></span><br><span class="line">`<span class="title function_">RPMessage_init</span><span class="params">()</span>` 函数用于初始化 RPMessage 模块。</span><br><span class="line">参数：</span><br><span class="line">`params` [in] 初始化参数。</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RPMessage_deInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"></span><br><span class="line">`<span class="title function_">RPMessage_deInit</span><span class="params">()</span>` 函数用于反初始化 RPMessage 模块。</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">RPMessage_waitForLinuxReady</span><span class="params">(<span class="type">uint32_t</span> timeout)</span></span><br><span class="line"></span><br><span class="line">`<span class="title function_">RPMessage_waitForLinuxReady</span><span class="params">()</span>` 函数用于等待 Linux 端的 RPMessage 准备就绪。</span><br><span class="line">在启用了 Linux 端的 RPMessage 之前，不应该向 Linux 发送消息，直到这个函数返回成功。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">当在 RTOS/非RTOS 核心之间使用 RPMessage 时，不需要调用这个 API。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">`timeout` [in] 超时时间，以系统时钟周期为单位。</span><br><span class="line">返回值：</span><br><span class="line">`SystemP_SUCCESS`，表示 Linux 端的 RPMessage 已经初始化完成。</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RPMessage_controlEndPtCallback</span><span class="params">(RPMessage_ControlEndPtCallback</span></span><br><span class="line"><span class="params">controlEndPtCallback,</span></span><br><span class="line"><span class="params"><span class="type">void</span> * controlEndPtCallbackArgs</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line"></span><br><span class="line">`<span class="title function_">RPMessage_controlEndPtCallback</span><span class="params">()</span>` 函数用于设置一个回调，当在控制端点接收到控制消息</span><br><span class="line">时调用。</span><br><span class="line">参数：</span><br><span class="line">`controlEndPtCallback` [in] 用户定义的回调函数，当控制消息到达时将被调用。</span><br><span class="line">`controlEndPtCallbackArgs` [in] 传递给用户控制端点回调的参数。</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">RPMessage_construct</span><span class="params">(RPMessage_Object * obj,</span></span><br><span class="line"><span class="params"><span class="type">const</span> RPMessage_CreateParams * createParams</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line"></span><br><span class="line">`<span class="title function_">RPMessage_construct</span><span class="params">()</span>` 函数用于创建一个 RPMessage 对象，以便在指定的端点接收消息。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">- 每个新创建的对象必须有一个唯一的本地端点。</span><br><span class="line">- 本地端点必须小于 `RPMESSAGE_MAX_LOCAL_ENDPT`。</span><br><span class="line">- 用户必须选择一个值，不支持使用 ANY 值。</span><br><span class="line">- 如果在 `RPMessage_CreateParams` 中注册了回调，则不能使用 `RPMessage_recv`。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">`obj` [out] 创建的对象。</span><br><span class="line">`createParams` [in] 创建对象时的参数。</span><br><span class="line">返回值：</span><br><span class="line">`SystemP_SUCCESS` 表示成功，否则表示失败。</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RPMessage_destruct</span><span class="params">(RPMessage_Object * obj)</span></span><br><span class="line"></span><br><span class="line">`<span class="title function_">RPMessage_destruct</span><span class="params">()</span>` 函数用于删除之前创建的 RPMessage 对象。</span><br><span class="line">参数：</span><br><span class="line">`obj` [in] 要删除的对象。</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RPMessage_unblock</span><span class="params">(RPMessage_Object * obj)</span></span><br><span class="line"></span><br><span class="line">`<span class="title function_">RPMessage_unblock</span><span class="params">()</span>` 函数用于解除对输入对象的 `RPMessage_recv` 调用的阻塞，如果它</span><br><span class="line">正在等待消息并且用户想要退出该任务。</span><br><span class="line">参数：</span><br><span class="line">`obj` [in] 要解除阻塞的对象。</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">RPMessage_getLocalEndPt</span><span class="params">(<span class="type">const</span> RPMessage_Object * obj)</span></span><br><span class="line"></span><br><span class="line">`<span class="title function_">RPMessage_getLocalEndPt</span><span class="params">()</span>` 函数用于返回一个 `RPMessage_Object` 的本地端点。</span><br><span class="line">返回的值将与之前创建该对象时使用的值相同。</span><br><span class="line">参数：</span><br><span class="line">`obj` [in] 对象。</span><br><span class="line">返回值：</span><br><span class="line">输入对象的本地端点。</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">RPMessage_announce</span><span class="params">(<span class="type">uint16_t</span> remoteProcId,</span></span><br><span class="line"><span class="params"><span class="type">uint16_t</span> localEndPt,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> * name</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line"></span><br><span class="line">`<span class="title function_">RPMessage_announce</span><span class="params">()</span>` 函数用于向远程核心宣告一个本地端点，该端点上创建了一个服务。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">- 宣告端点是可选的，IPC RPmessage不会以任何方式内部使用它。</span><br><span class="line">- 用户必须逐个向所有感兴趣的远程核心宣告。没有向所有核心宣告的选项。</span><br><span class="line">- 为了处理宣告消息，确保用户在 `RPMessage_init` 期间通过 `RPMessage_Params` 注册了</span><br><span class="line">用户处理程序。</span><br><span class="line">- 由最终用户决定如何使用回调来发出信号或等待直到远程服务被宣告。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">`remoteProcId` [in] 要宣告的远程核心。</span><br><span class="line">`localEndPt` [in] 正在宣告的服务的本地端点。</span><br><span class="line">`name` [in] 正在宣告的服务的名称。</span><br><span class="line">返回值：</span><br><span class="line">如果宣告消息已发送，则返回 `SystemP_SUCCESS`，否则表示失败。</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">RPMessage_send</span><span class="params">(<span class="type">void</span> * data,</span></span><br><span class="line"><span class="params"><span class="type">uint16_t</span> dataLen,</span></span><br><span class="line"><span class="params"><span class="type">uint16_t</span> remoteCoreId,</span></span><br><span class="line"><span class="params"><span class="type">uint16_t</span> remoteEndPt,</span></span><br><span class="line"><span class="params"><span class="type">uint16_t</span> localEndPt,</span></span><br><span class="line"><span class="params"><span class="type">uint32_t</span> timeout</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line"></span><br><span class="line">`<span class="title function_">RPMessage_send</span><span class="params">()</span>` 函数用于向指定远程端点的远程核心发送消息。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">- `dataLen` 必须小于等于RPMessage_Params::vringMsgSize - 16字节，以留出内部头部的</span><br><span class="line">空间。</span><br><span class="line">- 为了让远程核心能够接收到消息，远程核心上要有一个与 `remoteEndPt` 相同值的端点。</span><br><span class="line">- `localEndPt` 不是必需的，但是这个值在远程核心上是可用的，并且可以用作回复端点。使用</span><br><span class="line">`RPMessage_getLocalEndPt` 来设置监听回复的 RPMessage 对象的本地端点。</span><br><span class="line">- 当超时时间设置为 0 时，如果不可用的传输缓冲区，将⽴即返回 `SystemP_TIMEOUT`。否则，</span><br><span class="line">它将等待指定的超时时间，直到有可用的传输缓冲区。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">`data` [in] 要发送的消息数据的指针。</span><br><span class="line">`dataLen` [in] 要发送的消息数据的大小。</span><br><span class="line">`remoteCoreId` [in] 消息被发送到的远程核心ID。</span><br><span class="line">`remoteEndPt` [in] 消息被发送到的远程核心端点ID。</span><br><span class="line">`localEndPt` [in] 发送消息的本地端点。</span><br><span class="line">`timeout` [in] 等待时间，以系统时钟周期为单位。</span><br><span class="line">返回值：</span><br><span class="line">`SystemP_SUCCESS`，当发送消息成功时返回。</span><br><span class="line">`SystemP_TIMEOUT`，由于没有可用的传输缓冲区且超时发生，消息未被发送。</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">RPMessage_recv</span><span class="params">(RPMessage_Object * obj,</span></span><br><span class="line"><span class="params"><span class="type">void</span> * data,</span></span><br><span class="line"><span class="params"><span class="type">uint16_t</span> * dataLen,</span></span><br><span class="line"><span class="params"><span class="type">uint16_t</span> * remoteCoreId,</span></span><br><span class="line"><span class="params"><span class="type">uint32_t</span> * remoteEndPt,</span></span><br><span class="line"><span class="params"><span class="type">uint32_t</span> timeout</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line"></span><br><span class="line">`<span class="title function_">RPMessage_recv</span><span class="params">()</span>` 函数是一个阻塞式 API，直到在指定的本地端点接收到来自任何CPU的消</span><br><span class="line">息。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">- 本地端点在 `RPMessage_construct` 期间指定。</span><br><span class="line">- 如果注册了回调，则不应使用此 API。</span><br><span class="line">- 用户传递的 `dataLen` 包含用户消息缓冲区的大小，即指向 `data` 的缓冲区大小。如果接收</span><br><span class="line">到的消息大小超过了 `*dataLen`，则会被截断。如果接收到的消息大小小于等于 `*dataLen`，则</span><br><span class="line">所有接收到的字节都会被复制到 `data` 中，并且 `*dataLen` 表示 `data` 中有效字节的大</span><br><span class="line">小。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">`obj` [in] 使用 `RPMessage_construct` 创建的RPMessage端点对象。</span><br><span class="line">`data` [in] 指向接收到的消息内容的指针。</span><br><span class="line">`dataLen` [in] 用户消息缓冲区的⻓度，以字节为单位。</span><br><span class="line">[out] 接收到的消息的大小，以字节为单位。</span><br><span class="line">`remoteCoreId` [out] 发送方的核ID。</span><br><span class="line">`remoteEndPt` [out] 发送方的端点。</span><br><span class="line">`timeout` [in] 阻塞等待消息接收的时间，以系统时钟周期为单位。</span><br><span class="line">返回值：</span><br><span class="line">- `SystemP_SUCCESS`，接收到新消息，所有输出参数都是有效的。</span><br><span class="line">- `SystemP_TIMEOUT`，由于超时，API被解除阻塞，输出参数不应被使用。</span><br></pre></td></tr></table></figure>

<p><strong>API for Task</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TaskP_Params_init</span><span class="params">(TaskP_Params * params)</span></span><br><span class="line"></span><br><span class="line">`<span class="title function_">TaskP_Params_init</span><span class="params">()</span>` 函数用于为 `TaskP_Params` 结构体设置默认值。</span><br><span class="line">强烈建议在设置 `TaskP_Params` 中的值之前调用此函数。</span><br><span class="line">参数：</span><br><span class="line">`params` [out] 要设置为默认值的参数结构体。</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">TaskP_construct</span><span class="params">(TaskP_Object * obj,</span></span><br><span class="line"><span class="params">TaskP_Params * params</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line"></span><br><span class="line">`<span class="title function_">TaskP_construct</span><span class="params">()</span>` 函数用于创建一个任务对象。</span><br><span class="line">参数：</span><br><span class="line">`obj` [out] 创建的对象。</span><br><span class="line">`params` [in] 创建任务的参数。</span><br><span class="line">返回值：</span><br><span class="line">如果成功，返回 `SystemP_SUCCESS`。</span><br><span class="line">如果出错，返回 `SystemP_FAILURE`。</span><br></pre></td></tr></table></figure>

<h2 id="共享内存的使用"><a href="#共享内存的使用" class="headerlink" title="共享内存的使用"></a>共享内存的使用</h2><p>使用共享内存的通讯方式，数据是不通过 rpmsg 通道交换的，rpmsg主要起通知作用，并传递共享内存描述的相关信息。这一条通知消息，可以和其他rpmsg的处理区分开，也可以不区分，主要有几种方式：</p>
<ol>
<li><p>不新增 RPMessage 对象，和其他rpmsg一起处理，那么需要增加自定义交互协议，来交换包含共享内存描述的相关信息；</p>
</li>
<li><p>调用 <code>RPMessage_construct</code>创建一个新的 RPMessage 对象，和其他rpmsg分开处理。根据输入参数区分不同的RPMessage对象，做不同的处理。</p>
</li>
</ol>
<p><mark>注意：每个新创建的对象必须有一个唯一的本地端点。</mark></p>
<p>假如之前已经用了14端点，共享内存的RPMessage对象可以用16端点。这就需要在项目中添加多个端点。</p>
<p><strong>如何在MCU项目中添加多个RPMsg端点？</strong></p>
<p><a href="https://dev.ti.com/tirex/explore/node?node=A__AcOC0VpHUlAvx.sBVgyDVQ__AM62A-ACADEMY__WeZ9SsL__LATEST">TI Resource Explorer</a></p>
<p>实际上就是应用了下面的补丁：</p>
<p><a href="https://dev.ti.com/tirex/explore/content/am62ax_academy_10_01_00_00/_build_am62ax_academy_10_01_00_00/_downloads/8572acd8118b2273bb40546f07e38f56/0001-Linux_RPMsg_Echo-add-additional-endpoints.patch"><code>Linux_RPMsg_Echo-add-additional-endpoints.patch</code></a></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="ASSERT"><a href="#ASSERT" class="headerlink" title="ASSERT"></a>ASSERT</h3><p>在之前代码的基础上，把demo的代码移植过去，增加一个任务后，出现了断言，如下图:</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251018205540.png"></p>
<p>在 <code>queue.c </code>文件 <code>xQueueSemaphoreTake </code>函数1582行，<code>configASSERT</code>断言 <code>QueueHandle_t xQueue </code>是否为空。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251018205603.png"></p>
<p>出现断言打印，说明传了NULL。全局搜索没有直接调用 <code>xQueueSemaphoreTake </code>的地方，用的是<code>xSemaphoreTake </code>这个宏。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> xSemaphoreTake( xSemaphore, xBlockTime ) xQueueSemaphoreTake( (</span></span><br><span class="line">xSemaphore ), ( xBlockTime ) )</span><br></pre></td></tr></table></figure>

<p>使用的地方比较多，所以下一步要定位，是新增加了哪个函数调用，导致该问题。</p>
<p>最终定位是新加的任务，调用 <code>RPMessage_recv</code>函数出现的这个问题。</p>
<p>问题在于<code>RPMessage_recv</code>使用了，未经过<code>RPMessage_construct</code>创建的RPMessage对象。</p>
<p><strong>代码分析</strong></p>
<p>详细分析见注释。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IPC_RPMESSAGE_ENDPT_CHRDEV_PING (14U)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MCU_IPC_RECV_OBJ (1)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 在初始化的阶段，RPMessage_construct函数会创建一个RPMessage对象gIpcRecvMsgObject[1]，</span></span><br><span class="line"><span class="comment">* 用来在IPC_RPMESSAGE_ENDPT_CHRDEV_PING端点接收消息。</span></span><br><span class="line"><span class="comment">* 然后会调用SemaphoreP_constructBinary创建一个⼆进制信号量对象。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">RPMessage_CreateParams_init(&amp;createParams);</span><br><span class="line">createParams.localEndPt = IPC_RPMESSAGE_ENDPT_CHRDEV_PING;</span><br><span class="line">status = RPMessage_construct(&amp;gIpcRecvMsgObject[MCU_IPC_RECV_OBJ],</span><br><span class="line">&amp;createParams);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create the tasks which will handle the ping service */</span></span><br><span class="line">TaskP_Params_init(&amp;taskParams);</span><br><span class="line">taskParams.name = <span class="string">&quot;RPMESSAGE_CHAR_ZEROCOPY&quot;</span>;</span><br><span class="line">taskParams.stackSize = IPC_RPMESSAGE_TASK_STACK_SIZE;</span><br><span class="line">taskParams.<span class="built_in">stack</span> = gIpcTaskStack[<span class="number">0</span>];</span><br><span class="line">taskParams.priority = IPC_RPMESSAFE_TASK_PRI;</span><br><span class="line"><span class="comment">/* we use the same task function for echo but pass the appropiate rpmsg</span></span><br><span class="line"><span class="comment">handle to it, to echo messages */</span></span><br><span class="line">taskParams.args = &amp;gIpcRecvMsgObject[<span class="number">0</span>];<span class="comment">//gIpcRecvMsgObject[0]作为参数传递给</span></span><br><span class="line">ipc_recv_task_main</span><br><span class="line">taskParams.taskMain = ipc_recv_task_main;</span><br><span class="line">status = TaskP_construct(&amp;gIpcTask[<span class="number">0</span>], &amp;taskParams);</span><br><span class="line">DebugP_assert(status == SystemP_SUCCESS);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ipc_recv_task_main</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32_t</span> status;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_buf</span> <span class="title">ibuf</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">uint16_t</span> recvMsgSize, remoteCoreId;</span><br><span class="line">    <span class="type">uint32_t</span> remoteCoreEndPt;</span><br><span class="line">    RPMessage_Object *pRpmsgObj = (RPMessage_Object *)args;</span><br><span class="line"></span><br><span class="line">    DebugP_log(<span class="string">&quot;[IPC RPMSG ZEROCOPY] Remote Core waiting for messages at endpoint %d ... !!!\r\n&quot;</span>,RPMessage_getLocalEndPt(pRpmsgObj));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wait for messages forever in a loop */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Set &#x27;recvMsgSize&#x27; to size of recv buffer, after return`recvMsgSize`</span></span><br><span class="line"><span class="comment">        * contains actual size of valid data in recv buffer.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        recvMsgSize = <span class="keyword">sizeof</span>(ibuf);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 前面在初始化的时候，创建的RPMessage对象是gIpcRecvMsgObject[1]，</span></span><br><span class="line"><span class="comment">        * 而gIpcRecvMsgObject[0]并没有做创建处理，对应的信号量是NULL。</span></span><br><span class="line"><span class="comment">        * 那么，在任务里面，gIpcRecvMsgObject[0]作为输入参数传给RPMessage_recv之后，</span></span><br><span class="line"><span class="comment">        * 会调用RPMessage_getEndPtMsg。当消息队列为空时，调用SemaphoreP_pend等待一个信号量对象</span></span><br><span class="line"><span class="comment">        * 或锁定一个互斥锁，最终调用xSemaphoreTake，检测信号量为NULL，于是出现了断言。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        status = RPMessage_recv(pRpmsgObj,</span><br><span class="line">                    &amp;ibuf, &amp;recvMsgSize,</span><br><span class="line">                    &amp;remoteCoreId, &amp;remoteCoreEndPt,</span><br><span class="line">                    SystemP_WAIT_FOREVER);</span><br><span class="line">        DebugP_assert(status==SystemP_SUCCESS);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MPU"><a href="#MPU" class="headerlink" title="MPU"></a>MPU</h3><p>MCU无法访问SOC发过来的地址，具体表现为，对地址进行读&#x2F;写操作，MCU会挂掉。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">IPC message: buffer address 0xXXXX, size 1M, pattern 0xaaaa5555</span><br></pre></td></tr></table></figure>

<p>可能原因有：</p>
<ol>
<li><p>内存权限和属性：R5F核可能没有足够的权限访问该内存区域，或者内存属性（如执行、写入、读取等）可能没有正确配置。检查共享内存区域的权限和属性设置。</p>
</li>
<li><p>内存对齐：如果共享内存的地址或大小没有正确对齐，可能会导致访问错误。</p>
</li>
</ol>
<p>实际排查是因为没有访问权限，MPU里面没有对相应内存区域进行设置，需要在syscfg设置如下：</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251018210125.png"></p>
<h1 id="核间同步"><a href="#核间同步" class="headerlink" title="核间同步"></a>核间同步</h1><p>两个CPU核同时访问同一个共享内存区域，如何实现同步，实现资源互斥访问是一个需要重点考虑的问题。</p>
<p><a href="https://blog.csdn.net/lyd0813/article/details/126825378">核间通信（IPC）的两种解决方案-CSDN博客</a></p>
<p>第一种通信的同步方案：</p>
<p>使用virtIO来实现，详见RPMSG-VirtIO。前面多次提到一次只能传递 496 字节的信息。</p>
<p>第⼆种通信的同步方案：</p>
<p><strong>方案工作流程</strong></p>
<ol>
<li><p>R5F核写入共享内存：</p>
<ul>
<li><p>R5F核准备好数据后，将数据写入到共享内存的指定位置。</p>
</li>
<li><p>R5F核通过RPMsg发送一个消息给A53核，通知它数据已经写入完成。</p>
</li>
<li><p>这个消息可以通过核间中断来触发A53核的处理，解除其阻塞状态。</p>
</li>
<li><p>可以将多个数据包批量写入共享内存，然后通过RPMsg通知一次，减少中断的频率，提升性能。</p>
</li>
</ul>
</li>
<li><p>A53核读取数据：</p>
<ul>
<li><p>A53核在收到中断后从阻塞状态恢复，读取共享内存中R5F核写入的数据。</p>
</li>
<li><p>数据处理完后，A53核发送RPMsg通知R5F核操作完成。</p>
</li>
</ul>
</li>
</ol>
<p>同样，A53也可以通过类似的方式（共享内存写入 -&gt; RPMsg 通知）将数据写给R5F核。</p>
<p><strong>优点</strong></p>
<ol>
<li><p>同步精确：通过核间中断来通知对方核，可以做到精确的同步，这种方式减少了忙等(不像自旋锁那样忙等)。</p>
</li>
<li><p>同步机制简单：不需要复杂的锁来控制共享内存的访问权限。因为在每个核被通知后才会进行读写操作，避免了数据竞争。</p>
</li>
<li><p>减少CPU开销：通过阻塞等待和通知机制，避免了轮询式的资源检查，大大减少了CPU资源的浪费。</p>
</li>
<li><p>减少中断频率：通过批量写入共享内存，能够减少核间中断的频率，降低处理器之间的通信开销。RPMsg只在批量数据处理完后触发一次通知，从而提高效率。</p>
</li>
</ol>
<p><strong>需要注意的点</strong></p>
<ol>
<li><p>共享内存的一致性：需要手动清除缓存，确保两个核访问的是同样的数据。</p>
</li>
<li><p>RPMsg 通知的延迟：核间中断和RPMsg通常比较高效，但仍需要关注实际场景中的通知延迟，尤其是在高频率通信场景下。</p>
</li>
</ol>
<p><strong>优化思考</strong></p>
<ol>
<li><p>双缓冲机制：使用双缓冲，保证读写操作互不影响。例如，当R5F核写入时，A53核可以读取另一块缓冲区，减少读写等待的时间。</p>
</li>
<li><p>异步处理机制：如果接收方的处理速度较慢，可能会影响整个数据传输的吞吐量。在这种情况下，可以考虑让接收方异步处理接收到的数据，而不阻塞发送方的后续传输。当然，异步机制需要更复杂的同步控制。</p>
</li>
</ol>
<p><strong>说明</strong></p>
<p>一个核心不同的task，访问同一个共享内存区域，也要考虑资源访问问题。</p>
<h1 id="共享内存划分"><a href="#共享内存划分" class="headerlink" title="共享内存划分"></a>共享内存划分</h1><p>假设共享内存传输的数据，都用同样一块地址空间。因为升级数据不是写一次就通知soc，是写满之后才通知，那么在升级数据传输过程中，如果有其他功能，需要使用共享内存来传输数据，会导致之前升级包的数据被覆盖。考虑到这种场景(实际可能不会这么操作)，可以对共享内存划分不同的区域。</p>
<h2 id="物理地址说明"><a href="#物理地址说明" class="headerlink" title="物理地址说明"></a>物理地址说明</h2><p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251018210408.png"></p>
<ol>
<li><p>上面接口获取的是soc app申请的内存的物理地址，而不能简单认为是一个首地址，它可以不是首地址。如果soc app上电初始化之后，去申请内存，并且永远只申请一次(要考虑申请的大小，是申请一整个区域，还是其他)，那么由于内存空间都是空闲的，此时的物理地址就是首地址。或者可以每次申请并在使用完后释放，那么下次再去申请，应该也还是首地址。</p>
</li>
<li><p>soc app是把申请的内存的fd， 通过 <code>mmap</code>函数把一个文件映射到进程的地址空间中，这样就可以直接通过内存操作来访问文件内容，也就是操作的就是app申请的空间。那么调用<code>dmabuf_get_phys</code>，获取到申请的内存的物理地址之后，发给mcu，这样两边访问的就是同一块地方。</p>
</li>
</ol>
<h1 id="TI官方资料"><a href="#TI官方资料" class="headerlink" title="TI官方资料"></a>TI官方资料</h1><p><a href="https://software-dl.ti.com/mcu-plus-sdk/esd/AM62AX/09_02_00_38/exports/docs/api_guide_am62ax/IPC_GUIDE.html">AM62Ax MCU+ SDK: Understanding inter-processor communication (IPC)</a></p>
<p><a href="https://software-dl.ti.com/processor-sdk-linux/esd/AM62AX/latest/exports/docs/linux/Foundational_Components_IPC62ax.html?highlight=rpmsg">3.7. IPC for AM62ax — Processor SDK AM62Ax Documentation</a></p>
<p><a href="https://software-dl.ti.com/jacinto7/esd/processor-sdk-rtos-jacinto7/06_02_00_21/exports/docs/psdk_rtos_auto/docs/user_guide/developer_notes_ipc.html">8.5. Developing IPC applications — Processor SDK RTOS Automotive</a></p>
]]></content>
      <categories>
        <category>异构多核通信</category>
      </categories>
      <tags>
        <tag>共享内存</tag>
        <tag>TI AM62A</tag>
      </tags>
  </entry>
  <entry>
    <title>AM62Ax 使用笔记</title>
    <url>/2025/prefix%20remember%20to%20change!!!-dcd52e3ffa20/</url>
    <content><![CDATA[<h1 id="TI-官方文档"><a href="#TI-官方文档" class="headerlink" title="TI 官方文档"></a>TI 官方文档</h1><h2 id="TRM"><a href="#TRM" class="headerlink" title="TRM"></a>TRM</h2><p><a href="https://www.ti.com/lit/ug/spruj16b/spruj16b.pdf?ts=1739778134507">spruj16b.pdf</a></p>
<ul>
<li><p>MCAN模块介绍查看12.5.1章节</p>
</li>
<li><p>MCAN寄存器查看14.9.5章节</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020192354.png"></p>
<h2 id="DataSheet"><a href="#DataSheet" class="headerlink" title="DataSheet"></a>DataSheet</h2><p><a href="https://www.ti.com.cn/cn/lit/ds/symlink/am62a7.pdf?ts=1739873018012&ref_url=https%253A%252F%252Fwww.ti.com.cn%252Fproduct%252Fcn%252FAM62A7">AM62Ax Sitara™ 处理器 datasheet (Rev. C)</a></p>
<p>pin脚属性查看DataSheet，表 6-1. Pin Attributes</p>
<h2 id="Application-Note"><a href="#Application-Note" class="headerlink" title="Application Note"></a>Application Note</h2><p><a href="https://www.ti.com/lit/ug/sprado2c/sprado2c.pdf?ts=1760959551494">AM62A7, AM62A7-Q1, AM62A3-Q1 and AM62D-Q1 Families Schematic, Design Guidelines and Review Checklist (Rev. C)</a></p>
<h2 id="SDK"><a href="#SDK" class="headerlink" title="SDK"></a>SDK</h2><p><a href="https://software-dl.ti.com/mcu-plus-sdk/esd/AM62AX/09_02_00_38/exports/docs/api_guide_am62ax/index.html">AM62Ax MCU+ SDK: Introduction</a></p>
<p>IPC性能参考：</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020192650.png"></p>
<h2 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h2><p><a href="https://dev.ti.com/tirex/explore/node?a=7qm9DIS__LATEST&node=AAz9Dxht0WlNjAge02XsaQ">Training</a></p>
<h1 id="链接文件"><a href="#链接文件" class="headerlink" title="链接文件"></a>链接文件</h1><p><a href="https://dev.ti.com/tirex/explore/content/am62ax_academy_9_02_00_00_v1/_build_am62ax_academy_9_02_00_00_v1/source/mcu/mcu-plus-sdk-fundamentals/linker_cmd_file.html#mcu-linker-cmd-file">Linker command file — AM62Ax Academy</a></p>
<p><a href="https://software-dl.ti.com/ccs/esd/documents/sdto_cgt_linker_special_section_types.html">Linker Special Section Types</a></p>
<p><a href="https://software-dl.ti.com/ccs/esd/documents/sdto_cgt_Linker-Command-File-Primer.html">TI Linker Command File Primer</a></p>
<p>从lib库中分配一个单一输入部分时，如果库文件名包含特殊字符，在链接脚本中，需要将包含特殊字符的文件名用双引号括起来，确保链接器将其视为整体路径：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This is used to store memory segments related to the TI SDK library files.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">GROUP</span><br><span class="line">&#123;</span><br><span class="line">.ti_lib_text: &#123;<span class="string">&quot;freertos.am62ax.r5f.ti-arm-clang.release.lib&quot;</span>&lt;tasks.obj&gt;</span><br><span class="line">(.text)&#125; align(<span class="number">8</span>)</span><br><span class="line">&#125; &gt; MSRAM</span><br></pre></td></tr></table></figure>

<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><blockquote>
<p>Bootloader是嵌入式系统在上电后执行的第一段代码，最终目标就是引导内核，启动内核。</p>
</blockquote>
<h2 id="SPL和SBL"><a href="#SPL和SBL" class="headerlink" title="SPL和SBL"></a>SPL和SBL</h2><p>AM62A7处理器支持两种主要类型的启动流程：SPL启动和SBL启动。</p>
<ul>
<li><p>SPL启动是Linux SDK的默认启动模式，其文件系统镜像均基于此模式开发并测试。<a href="https://dev.ti.com/tirex/explore/node?node=A__Aa8lmDzYbaW3Jkc-q3M5og__AM62A-ACADEMY__WeZ9SsL__LATEST&search=BOOT">Linux Boot Flow</a></p>
</li>
<li><p>SBL启动则主要应用于MCU+ SDK的开发与测试场景。</p>
<ul>
<li><p><a href="https://software-dl.ti.com/mcu-plus-sdk/esd/AM62AX/10_00_00_14/exports/docs/api_guide_am62ax/EXAMPLES_DRIVERS_SBL.html">AM62Ax MCU+ SDK: Secondary Bootloader (SBL)</a></p>
</li>
<li><p><a href="https://software-dl.ti.com/mcu-plus-sdk/esd/AM62AX/09_02_00_38/exports/docs/api_guide_am62ax/SBL_BOOTING_LINUX_OSPI.html">AM62Ax MCU+ SDK: SBL Booting Linux From OSPI</a></p>
</li>
</ul>
</li>
</ul>
<h2 id="ROM-Code"><a href="#ROM-Code" class="headerlink" title="ROM Code"></a>ROM Code</h2><p>ROM Code：或ROM bootloader (RBL)，是设备ROM中首先执行并实现引导的片上软件，是一种驻留在片上只读存储器（ROM）中的软件(出厂时固化，不可更改)，这段代码执行第一阶段的启动任务，用于帮助用户传输和执行其应用程序代码。AM62Ax有两套协同工作的 ROM 代码，公共 ROM 代码和 M4 ROM 代码。</p>
<p>AM62A7上电复位后，CPU从芯片内部的ROM（Boot ROM）开始执行固化代码（即ROM Code）。</p>
<p>ROM Code会读取启动引脚配置，然后根据配置情况决定以哪种方式加载接下来的外部启动代码。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020193152.png"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020193211.png"></p>
<h2 id="Bootloader-Modes"><a href="#Bootloader-Modes" class="headerlink" title="Bootloader Modes"></a>Bootloader Modes</h2><p>为了适应各种系统场景，ROM 代码支持多种引导模式。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020193248.png"></p>
<p>这些引导模式可分为以下两类：</p>
<ul>
<li><p>主机引导模式：AM62Ax通过所选接口（如 UART 或 USB（DFU））从主机接收第二引导加载程序。</p>
</li>
<li><p>内存引导模式：AM62Ax从非易失性存储器（如 SD 卡、eMMC、OSPI&#x2F;QSPI&#x2F;SPI 闪存或 GPMC 闪存）中传输第二引导加载程序。</p>
</li>
</ul>
<p>在 OSPI 启动模式下，ROM Code会初始化 OSPI 模块，然后从与选定片选信号相连的 OSPI 闪存中读取映像。如果无法正确从偏移量 0x0 处读取映像，将尝试在偏移量 0x400000 处获取映像。OSPI启动模式不支持XIP（原地执行），ROM Code首先将启动映像复制到片上RAM中，然后执行它。</p>
<h2 id="Booting-Parameter-Table"><a href="#Booting-Parameter-Table" class="headerlink" title="Booting Parameter Table"></a>Booting Parameter Table</h2><p>一种存储于片上 RAM 内存中的逻辑结构，其包含有启动所需的信息，诸如启动文件名或者用于启动的地址等。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020193346.png"></p>
<p><strong>更多参考：</strong></p>
<p>TRM Chapter 5 Initialization：<a href="https://www.ti.com/lit/ug/spruj16b/spruj16b.pdf?ts=1739778134507">spruj16b.pdf</a></p>
<p>DM R5F：<a href="https://dev.ti.com/tirex/explore/content/am62ax_academy_10_00_00_01/am62ax_academy_10_00_00_01/source/multicore/app-development/develop-dm-r5f.html#multicore-app-development-dm-r5f">Developing on the DM R5F</a></p>
<p>Boot Time Optimizations：<a href="https://software-dl.ti.com/processor-sdk-linux/esd/AM62AX/latest/exports/docs/linux/How_to_Guides/Target/How_to_boot_quickly.html">6.1.10. Boot Time Optimizations</a></p>
<p>其他：<a href="https://blog.csdn.net/zy812248258/article/details/39026081">ARM-Linux嵌入式系统启动流程_arm嵌入式开机启动流程简述题-CSDN博客</a></p>
<h1 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h1><p>如何查看当前MCU R5内核的时钟频率：</p>
<p><a href="https://e2echina.ti.com/support/machine-translation/mt-processors/f/mt-processors-forum/929438/sk-am62a-lp-mcu-r5-sk-am62a-lp">[参考译文] SK-AM62A-LP：需要 MCU-R5内核时钟频率相关信息(SK-AM62A-LP)</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">k3conf dump clock 9</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020193800.png"></p>
<p>临时修改时钟频率，使用<code>k3conf</code>直接从命令行更改 MCU R5F 内核频率。比如：修改为200Mhz。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">k3conf set clock 9 0 200000000</span><br></pre></td></tr></table></figure>

<p>如果要永久生效，可以在设备树里面增加如下配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&amp;mcu_r5fss0 &#123;</span><br><span class="line">    /* Set DEV_MCU_R5FSS0_CORE0_CPU0_CLK to 200MHz */</span><br><span class="line">    assigned-clocks = &lt;&amp;k3_clks 9 0&gt;;</span><br><span class="line">    assigned-clock-rates = &lt;200000000&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CCT"><a href="#CCT" class="headerlink" title="CCT"></a>CCT</h2><p><a href="https://xianren-wrd.github.io/2025/prefix%20remember%20to%20change!!!-0d2b6ccd334f/">CCS使用笔记</a></p>
<h1 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h1><p><a href="https://xianren-wrd.github.io/2025/prefix%20remember%20to%20change!!!-25bc31419109/">IPC共享内存调试</a></p>
<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>注意：凡是TI提供的接口，代码实现需要到SDK里面去找。</p>
<p><a href="https://software-dl.ti.com/mcu-plus-sdk/esd/AM62AX/09_02_00_38/exports/docs/api_guide_am62ax/KERNEL_DPL_HWI_PAGE.html">AM62Ax MCU+ SDK: HW Interrupts</a></p>
<p>R5f核心专用中断控制器，称为向量中断管理器（VIM）。详细内容查看TRM文档第10章。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020194422.png"></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>R5F的中断是通过 <code>HwiP_irq_handler</code>统一处理的， <code>HwiP_irq_handler</code>调用<code>vApplicationIRQHandlerConst</code>（ <code>HwiP_irq_handler_c </code>），然后根据 <code>HwiP_construct</code>注册的中断号和处理函数，执行对应的中断服务函数。对于上层应用来说，我们调用 <code>HwiP_construct</code>注册需要的中断就行了。</p>
<p><strong>中断向量表</strong></p>
<p><code>HwiP_armv7r_vectors_freertos_asm.S</code></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020201214.png"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020201242.png"></p>
<p><code>HwiP_disable()</code></p>
<blockquote>
<p>Disable all interrupts.</p>
<p>Note: In case of ARM R5F, ARM M4F, this only disables IRQ.FIQ is not disabled.</p>
<p>Returns: interrupt state before disable, typically used by HwiP_restore later</p>
</blockquote>
<p>TI的SDK有问题。这个禁用所有中断的函数不起作用，e2e有类似的帖子：</p>
<p><a href="https://e2e.ti.com/support/processors-group/processors/f/processors-forum/1368454/processor-sdk-am62x-m4-freertos-interrupt-disable-not-working-hwip_disable">PROCESSOR-SDK-AM62X: M4 FreeRTOS Interrupt Disable Not Working (HwiP_disable)</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* FUNCTION DEF: uint32_t HwiP_disable(void) */</span></span><br><span class="line">    .global HwiP_disable</span><br><span class="line">    .type HwiP_disable,%function</span><br><span class="line">    .section <span class="string">&quot;.text.hwi&quot;</span>,<span class="string">&quot;ax&quot;</span>,%progbits</span><br><span class="line">    .arm</span><br><span class="line">    .align <span class="number">2</span></span><br><span class="line">HwiP_disable:</span><br><span class="line">    mrs r0, cpsr</span><br><span class="line">    orr r12, r0, #<span class="number">0x80</span></span><br><span class="line">    msr cpsr_cf, r12</span><br><span class="line">    bx LR</span><br></pre></td></tr></table></figure>

<p><strong>HwiP_init()</strong></p>
<p><code>HwiP_armv7r_vim.c</code></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020201642.png"></p>
<h1 id="MCU-SDK替换"><a href="#MCU-SDK替换" class="headerlink" title="MCU+ SDK替换"></a>MCU+ SDK替换</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>遇到了<code>HwiP_disable()</code>禁用中断不起作用的问题，TI的回复是使用 MCU+SDK v10.01看是否还有问题。</p>
<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p><a href="https://xianren-wrd.github.io/2025/prefix%20remember%20to%20change!!!-0d2b6ccd334f/">CCS使用笔记</a> </p>
<h2 id="编译报错"><a href="#编译报错" class="headerlink" title="编译报错"></a>编译报错</h2><h3 id="CCS报错"><a href="#CCS报错" class="headerlink" title="CCS报错"></a>CCS报错</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">missing required argument <span class="string">&#x27;sw_version&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020202229.png"></p>
<p>从上面的信息可以看出 <code>source_code.out</code>已经生成了，但是在调用 <code>elf2rprc.js</code>，将<code>source_code.out</code>转换为 <code>source_code.rprc</code>时出现了错误。</p>
<p>对比两个SDK版本的js文件，发现10.01增加了一个 <code>sw_version</code>参数，所以导致了这个错误。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020202307.png"></p>
<p>解决方法：替换 <code>makefile_ccs_bootimage_gen</code>文件。</p>
<h3 id="Makefile报错"><a href="#Makefile报错" class="headerlink" title="Makefile报错"></a>Makefile报错</h3><ol>
<li><p>makefile需要修改SDK的路径为实际的安装路径</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020202951.png"></p>
<p>执行编译脚本，出现如下报错：</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020203225.png"></p>
</li>
<li><p>需要修改SDK下面的 <code>imports.mak</code>文件</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020203258.png"></p>
<p>修改工具安装路径，修改ccs的版本改为实际的版本：</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020203336.png"></p>
</li>
<li><p>修改完后，出现了和上面一样的错误</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">missing required argument <span class="string">&#x27;sw_version&#x27;</span></span><br></pre></td></tr></table></figure>

<p>需要修改makefile增加参数</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020203504.png"></p>
</li>
</ol>
<h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><h2 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h2><ol>
<li><p>out文件反汇编</p>
<p>检查 <code>ELF</code>文件头：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arm-none-eabi-readelf -h xxx.out</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ELF Header:</span><br><span class="line">Magic: 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">Class: ELF32</span><br><span class="line">Data: 2&#x27;s complement, little endian</span><br><span class="line">Version: 1 (current)</span><br><span class="line">OS/ABI: UNIX - System V</span><br><span class="line">ABI Version: 0</span><br><span class="line">Type: EXEC (Executable file)</span><br><span class="line">Machine: ARM</span><br><span class="line">Version: 0x1</span><br><span class="line">Entry point address: 0x0</span><br><span class="line">Start of program headers: 3755220 (bytes into file)</span><br><span class="line">Start of section headers: 3755444 (bytes into file)</span><br><span class="line">Flags: 0x5000000, Version5 EABI</span><br><span class="line">Size of this header: 52 (bytes)</span><br><span class="line">Size of program headers: 32 (bytes)</span><br><span class="line">Number of program headers: 7</span><br><span class="line">Size of section headers: 40 (bytes)</span><br><span class="line">Number of section headers: 39</span><br><span class="line">Section header string table index: 38</span><br></pre></td></tr></table></figure>

<p>反汇编，并将结果保存到<code>disassembly.txt</code>文件中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arm-none-eabi-objdump.exe -d --prefix-addresses -marm xxx.out &gt; disassembly.txt</span><br></pre></td></tr></table></figure>

<p>其中， <code>xxx.out</code>文件名需要按实际情况修改。</p>
</li>
<li><p>obj文件反汇编</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:\ti\ccs1240\ccs\tools\compiler\ti-cgt-armllvm_2.1.3.LTS\bin\tiarmobjdump.exe</span><br><span class="line">-d queue.obj &gt; disassembly_obj.txt</span><br></pre></td></tr></table></figure>

<p><code>tiarmobjdump.exe</code>需要替换为自己的安装路径。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:\ti\ccs1240\ccs\tools\compiler\ti-cgt-armllvm_2.1.3.LTS\bin\tiarmobjdump.exe</span><br><span class="line">-s -j .rodata queue.obj</span><br></pre></td></tr></table></figure>

<p><code>.rodata.str1.97075527348778053441</code>是目标文件 <code>queue.obj</code> 中的一个只读数据段，使用以下命令查看具体内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:\ti\ccs1240\ccs\tools\compiler\ti-cgt-armllvm_2.1.3.LTS\bin\tiarmobjdump.exe</span><br><span class="line">-s -j .rodata.str1.97075527348778053441 queue.obj</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020204445.png"></p>
</li>
</ol>
<h2 id="SDK编译"><a href="#SDK编译" class="headerlink" title="SDK编译"></a>SDK编译</h2><p>进入SDK安装目录，命令终端输入指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gmake -s libs PROFILE=release</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020203800.png"></p>
<p>clean指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gmake -s libs-clean PROFILE=release</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020203843.png"></p>
]]></content>
      <categories>
        <category>处理器与芯片</category>
      </categories>
      <tags>
        <tag>TI AM62Ax</tag>
      </tags>
  </entry>
  <entry>
    <title>Cache引发的数据一致性问题</title>
    <url>/2025/prefix%20remember%20to%20change!!!-a7530e697474/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>调试MCU(S32K312)和SOC之间的串口时，发现逻辑分析仪抓到的数据波形异常。</p>
<p>从逻辑分析仪的波形来看，SOC是前八个字节，后八个字节这样去发的。但是仿真查看MCU接收的数据，收到的要不就是全是前八个字节，要不就是后八个字节。数据接收不完整，所以ACK发不出去， ACK回复超时SOC会通知MCU Reset串口，如此循环…</p>
<h1 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h1><p>首先，怀疑是不是中断没有进入，但是增加了count去记录中断进入的次数，发现中断是正常进入的。考虑到SOC会发很多东西，而且收不到ACK会重发，所以让SOC先发一帧，这样调试起来比较清晰。</p>
<p>SOC端改为只发送一帧数据后，很明显的现象就是，明明逻辑分析仪抓到的是非0数据。但是，有时候仿真看收到的是全0数据；明明代码给发送的buffer赋值了，仿真也跑了赋值，但是实际发出去的是全0。从这个现象可以看出，这个问题是Cache的问题，开启Cache的RAM，CPU和DMA对RAM多主访问的情况，会有数据一致性问题。</p>
<p><strong>Cache介绍：<a href="https://xianren-wrd.github.io/2025/prefix%20remember%20to%20change!!!-b53a9b624865/">Cache扫盲</a></strong></p>
<h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><p>之前<code>bss段</code>是链接到DTCM的，MPU配置是<code>non_cacheable</code>的，所以之前用DMA的时候没有问题。后来，由于内存不足，UART相关的代码，链接到了SRAM，但是SRAM在启动代码里面的<code>SystemInit</code>函数配置MPU时，全部配置成了Cache，并且是写回策略，导致引发了数据一致性问题。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>解决该问题的方法有两种：</p>
<ol>
<li>手动更新Cache，在合适的时机清理或无效Cache。</li>
<li>将内存属性设置为<code>non-cacheable</code>的。</li>
</ol>
<h2 id="手动更新Cache"><a href="#手动更新Cache" class="headerlink" title="手动更新Cache"></a>手动更新Cache</h2><p><strong>手动更新Cache的接口函数在<code>core_cm7.h</code>文件可以找到。</strong></p>
<p>Cache函数的参数类似，介绍如下：</p>
<ul>
<li><p>addr：要清除内存的起始地址。地址要求32字节对齐，否则自动强制按照D-cache的行大小对齐。</p>
</li>
<li><p>dsize：清除内存大小，通常要求是32的整数倍，不是整数倍需要注意正确的操作顺序。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020224257.png"></p>
<p>图中高亮的DCIMVAC寄存器是一个ARM处理器中的寄存器，它用于执行无效目标地址操作。如果数据在集群内是脏的，则在无效之前执行清除操作。</p>
<p><strong>也可以使用RTD <code>Cache_Ip.c</code>里面的接口函数。</strong></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020224429.png"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020224446.png"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020224507.png"></p>
<p>由于参数要求32字节对齐，代码里面UART的数据结构体是没对齐的，需要在DMA使用到的接收buffer后面填充32个字节。不然，会把后面的Cache也更新了。因为从前面函数的定义可以看到，Cache的操作是连续的，每次操作32个字节，如果地址没有32字节对齐且buffer大小不是32的倍数，后面又定义了有效的变量，在执行invalid操作时我们并不希望invalid该变量，但由于invalid的操作是连续的，会导致该变量的值被覆盖。所以，需要对DMA接收的buffer做填充处理，发送的buffer可以不用处理。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020224957.png"></p>
<p>然后，在使用DMA发送数据前或者读取DMA收到的数据前，清理或无效化Cache就好了。</p>
<p>使用这种方法可以继续将UART变量链接到SRAM，不用改链接脚本，不用自定义段，也不用改MPU的属性。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020225216.png"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020225236.png"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020225254.png"></p>
<h2 id="修改内存属性"><a href="#修改内存属性" class="headerlink" title="修改内存属性"></a>修改内存属性</h2><p>将内存设置为<code>non-cacheable</code>的解决方法有两种：</p>
<ol>
<li><p>修改链接脚本，把int_sram section1的空间改小，把之前的<code>non-cacheable</code>空间改大。由于MPU区域的大小必须是2的次方大小，起始地址必须要是域大小的整数倍。这种方法改动量比较大，而且之前SRAM已经用了一些空间，很难凑出合适的数据，所以不采用这种方法。</p>
</li>
<li><p>把链接的段属性改成<code>non-cacheable</code></p>
<p>在链接脚本中增加自定义段：</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020225620.png"></p>
<p>把UART相关的变量链接到自定义段：</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020225641.png"></p>
<p>自定义段的地址处于int_sram section2的区域，再将section2配置为<code>non_cacheable</code>属性即可。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020225748.png"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>异常与故障分析</category>
      </categories>
      <tags>
        <tag>DMA</tag>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title>Cache扫盲</title>
    <url>/2025/prefix%20remember%20to%20change!!!-b53a9b624865/</url>
    <content><![CDATA[<h1 id="什么是Cache"><a href="#什么是Cache" class="headerlink" title="什么是Cache"></a>什么是Cache</h1><p>它是一种位于处理器核心和主存之间的高速缓冲存储器，用于存储频繁访问的数据以加速数据的检索。Cache的基本工作原理基于计算机程序执行的局部性特性，即在一定时间内，CPU会倾向于访问最近访问过的数据或附近的数据。</p>
<h1 id="为什么要用Cache"><a href="#为什么要用Cache" class="headerlink" title="为什么要用Cache"></a>为什么要用Cache</h1><p>Cache是为了提供快速的CPU存储访问而设计的，它的存在可以显著提高处理器的数据处理速度。在程序运行过程中CPU需要不断的从内存读取指令和数据，受限于内存访问速度，CPU需要等待指令或数据读取完成，这就造成了CPU的浪费。Cache就是用来减少CPU等待浪费的问题。Cache的读、写速度要比片内或片外内存快很多，使用Cache能大大提高程序的执行效率。</p>
<h1 id="Cache的机制"><a href="#Cache的机制" class="headerlink" title="Cache的机制"></a>Cache的机制</h1><p>Cache系统一般包括多个Cache line，每个Cache line通常包含一个数据块和一个标记。数据块是实际存储的数据，而标记则包含了该数据块的一些元信息，如数据块所在的内存地址、数据块的状态等。</p>
<p>当CPU需要读取某个内存地址的数据时，会首先查看对应的Cache line是否已被加载到Cache中。如果已经被加载，这个过程就被称为“命中”，则直接从Cache中读取该数据，这大大提高了处理速度；否则，如果Cache中没有所需的数据，这个过程被称为“未命中”，CPU则需要从主存储器中读取数据，并将其放入Cache中以备后用。</p>
<p>在写数据时，通常有两种主要的策略：write through(写通)和write back(写回)。</p>
<ul>
<li><p>在write through策略中，当CPU执行写操作并在Cache中命中时，不仅会更新Cache中的数据，还会直接更新主存中的数据。这样可以保证Cache和主存的一致性，但可能会降低处理器的处理能力和占用总线带宽。</p>
</li>
<li><p>在write back策略中，CPU向内存中写数据，首先检查Cache中是否有数据备份，如果有则数据写入操作只写入Cache并标记为dirty，而并不会立即将数据更新到内存中，等待合适的时机会自动将数据更新到内存。如果没有则将会在Cache中分配空间，备份写入到内存的数据。</p>
</li>
</ul>
<p>根据MPU设置的不同，Cache读、写不同属性的内存会采用不同的策略。</p>
<p><strong>MPU介绍：<a href="https://xianren-wrd.github.io/2025/prefix%20remember%20to%20change!!!-f119c37d2168/">MPU扫盲</a></strong></p>
<h1 id="S32K312-Cache简述"><a href="#S32K312-Cache简述" class="headerlink" title="S32K312 Cache简述"></a>S32K312 Cache简述</h1><p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020220919.png"></p>
<p>Cache属于内核外设，Cortex_M3与Cortex_M4没有Cache，Cortex_M7新增了Cache功能。</p>
<p>Cortex-M7内核Cache分为I-cache 和D-cache，在S32K312中，它们的大小均为8K。</p>
<ul>
<li><p>I-cache与D-cache 可以独立的打开和关闭</p>
</li>
<li><p>I-cache用于存储指令&#x2F;缓存代码，所以我们不必关心。</p>
</li>
<li><p>D-cache用于存储数据，因为涉及到DMA等问题，D-cache使用不当会导致一些错误。</p>
</li>
</ul>
<h1 id="D-Cache一致性问题"><a href="#D-Cache一致性问题" class="headerlink" title="D-Cache一致性问题"></a>D-Cache一致性问题</h1><p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020221353.png"></p>
<p>开启Cache的RAM，在CPU和DMA对RAM多主访问的情况下，会出现数据一致性问题。</p>
<p>问题原因是CPU和DMA短时间内访问同一块内存区域。主要分为以下两种情况。</p>
<ol>
<li><p>未及时更新内存：当CPU向内存中写数据，如果Cache策略是“write back”CPU会将数据写入到Cache并且不会立即更新到内存中，如果此时DMA读取内存中的数据则读取得到的是旧数据，即出现数据一致性问题。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020222128.png"></p>
</li>
<li><p>未及时更新Cache：DMA更新了地址N中的数据，并且没有将更改更新到Cache。CPU从地址N读数据，并且在Cache中找到了地址N的数据备份，此时CPU得到的是旧的数据。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020222144.png"></p>
</li>
</ol>
<p>解决该问题的方法有两种：</p>
<ol>
<li><p>手动更新Cache，这需要对外设的机制较为了解，且要找到合适的时机清理或无效Cache。</p>
<p>Note：</p>
<ul>
<li><p>Cache清理并不是删除Cache中的内容，而是将Cache中的内容更新到各自对应的内存中。</p>
</li>
<li><p>缓存无效化是指，Cache中的内容失效，效果如同删除了Cache中的数据备份，CPU再次读数据时将直接从内存中读取。</p>
</li>
</ul>
</li>
<li><p>将内存属性设置为<code>non-cacheable</code>的。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>嵌入式概念扫盲</category>
      </categories>
      <tags>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title>MPU扫盲</title>
    <url>/2025/prefix%20remember%20to%20change!!!-f119c37d2168/</url>
    <content><![CDATA[<h1 id="什么是MPU"><a href="#什么是MPU" class="headerlink" title="什么是MPU"></a>什么是MPU</h1><p>MPU：Memory Protection Unit，即内存保护单元。它是一种提供内存保护的计算机硬件单元，它是单片机内核中用于内存保护的可选组件，通常作为CPU的一部分来实现。主要负责定义内存空间的属性，例如特权指令和非特权指令以及Cache是否可访问。</p>
<h1 id="MPU的作用"><a href="#MPU的作用" class="headerlink" title="MPU的作用"></a>MPU的作用</h1><p>MPU可以将内存划分为不同的区域，并且可以设置每个区域的访问属性，提高系统的稳定性。</p>
<p>典型应用如下：</p>
<ul>
<li><p>划分特权用户访问区域和普通用户访问区域，在OS系统中提高系统稳定性。</p>
</li>
<li><p>设置只读区域，防止关键数据被意外修改。</p>
</li>
<li><p>检测堆、栈是否溢出。</p>
</li>
</ul>
<h1 id="相关寄存器"><a href="#相关寄存器" class="headerlink" title="相关寄存器"></a>相关寄存器</h1><p>和Cache一样，MPU也是内核外设，Cortex-M3、Cortex-M4以及Cortex-M7内核的微控制器可以选配MPU功能。这里介绍几个MPU相关的寄存器。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020221537.png"></p>
<h2 id="MPU区域基地址寄存器（MPU-RBAR）"><a href="#MPU区域基地址寄存器（MPU-RBAR）" class="headerlink" title="MPU区域基地址寄存器（MPU_RBAR）"></a>MPU区域基地址寄存器（MPU_RBAR）</h2><p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020221603.png"></p>
<h2 id="MPU区域属性和大小寄存器（MPU-RASR）"><a href="#MPU区域属性和大小寄存器（MPU-RASR）" class="headerlink" title="MPU区域属性和大小寄存器（MPU_RASR）"></a>MPU区域属性和大小寄存器（MPU_RASR）</h2><p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020221650.png"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020221702.png"></p>
<p>通常我们会在链接脚本里定义不同的<code>section</code>，将需要设为<code>non-cacheable</code>的内存块放置到特定的<code>section</code>里。在启动代码里对不同的<code>section</code>配置MPU相关寄存器。此后,<br>CPU在访问内存的时候，经过MPU，就会知道这块内存是<code>cacheable</code>还是<code>non-cacheable</code>的了。</p>
]]></content>
      <categories>
        <category>嵌入式概念扫盲</category>
      </categories>
      <tags>
        <tag>MPU</tag>
      </tags>
  </entry>
  <entry>
    <title>UART中断中释放信号量引发的HardFault</title>
    <url>/2025/prefix%20remember%20to%20change!!!-c139ec3b5aa2/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>项目需要增加一路串口，用来传输BAP IPC message。</p>
<blockquote>
<p>BAP：Operator And Display Protocol(Bedien und Anzeigeprotokoll)，操作和显示协议。BAP是大众汽车上一种ECU之间通信的协议。 BAP通常用于传输各种车辆信息，从而实现泊车交互、空调调节和仪表控制等功能。该协议通常运行在CAN、LIN总线上，但进年来也被部署到了新兴的车载以太网上。</p>
</blockquote>
<p>串口驱动不需要移植，之前代码屏蔽了，直接打开就能使用。只需要在初始化的时候，创建对应的ipc_uart thread即可。但是在实际调试的过程中，遇到了问题。</p>
<p>问题表现：接收到soc发送的串口数据后，进入了HardFault_Handler，进而看门狗复位。</p>
<h1 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h1><p>MCU重启后，查看串口复位原因的打印，关键字<code>rst_source</code>。</p>
<p>复位原因有：MCU_SWT0_RST_RESET: SWT0 Timeout，软件看门狗定时器0超时复位。</p>
<p>接上仿真器运行一段时间后，仿真进入了<code>HardFault_Handler</code>。</p>
<p>从IDE仿真窗口可以看到进入<code>HardFault_Handler</code>之前的函数调用关系，可以看出代码在<code>uxListRemove</code>这里挂了，这个是freertos模块的api。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020212609.png"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020212634.png"></p>
<p>Tips：暂停仿真时，S32DS可以查看之前的函数调用情况，不需要查看pc和lr寄存器。实际查看寄存器，得出的结论也是一样的， 在跑<code>uxListRemove</code>函数时出现了问题。</p>
<h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><p>UART Reset脚&#x2F;DMA产生中断后，中断服务函数里面调用了操作系统内核接口（…FromISR()），释放信号量。但是外设的中断优先级高于操作系统内核中断优先级，就会出现系统内核无法抢占当前中断的情况，从而导致系统出错。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020213018.png"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251020212822.png"></p>
<p>将FreeRTOS里面的调用中断安全的FreeRTOS API 函数的最高中断优先级调高。</p>
<p>因为FreeRTOS的应用手册中有明确说明，对于可以在中断中调用的api函数，必须保证中断优先级不高于<code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code>，违反操作会导致系统调度出现问题。</p>
]]></content>
      <categories>
        <category>异常与故障分析</category>
      </categories>
      <tags>
        <tag>HardFault</tag>
        <tag>看门狗复位</tag>
      </tags>
  </entry>
  <entry>
    <title>中断扫盲</title>
    <url>/2025/prefix%20remember%20to%20change!!!-e79f52ee8adb/</url>
    <content><![CDATA[<h1 id="什么是中断"><a href="#什么是中断" class="headerlink" title="什么是中断"></a>什么是中断</h1><p>CPU执行程序时，由于发生了某种随机的事件(外部或内部)，引起CPU暂时中断正在运行的程序，转去执行一段特殊的服务程序(中断服务子程序或中断处理程序)，以处理该事件，该事件处理完后又返回被中断的程序继续执行，这一过程称为中断。</p>
<p>在计算机科学中，中断（Interrupt）是指处理器接收到来自硬件或软件的信号，提示发生了某个事件，应该被注意，这种情况就称为中断。</p>
<p>通常，在接收到来自外围硬件（相对于中央处理器和内存）的异步信号，或来自软件的同步信号之后，处理器将会进行相应的硬件／软件处理。发出这样的信号称为进行中断请求（interrupt request，IRQ）。</p>
<p>硬件中断导致处理器通过一个运行信息切换（context switch）来保存执行状态（以程序计数器和程序状态字等寄存器信息为主）；软件中断则通常作为CPU指令集中的一个指令，以可编程的方式直接指示这种运行信息切换，并将处理导向一段中断处理代码。</p>
<p><strong>为什么要有中断？</strong></p>
<p>如果计算机系统没有中断，则处理器与外部设备通信时，它必须在向该设备发出指令后进行忙等待（Busy waiting），反复轮询该设备是否完成了动作并返回结果。这就造成了大量处理器周期被浪费。</p>
<p>引入中断以后，当处理器发出设备请求后就可以立即返回以处理其他任务，而当设备(如：定时器)完成动作后，发送中断信号给处理器，后者就可以再回过头获取处理结果。这样，在设备进行处理的周期内，处理器可以执行其他一些有意义的工作，而只付出一些很小的切换所引发的时间代价。</p>
<blockquote>
<p>下面以STM32为例介绍中断机制。</p>
</blockquote>
<h2 id="EXTI"><a href="#EXTI" class="headerlink" title="EXTI"></a>EXTI</h2><p>外部中断&#x2F;事件控制器包含多达 23 个用于产生事件&#x2F;中断请求的边沿检测器。</p>
<p>每根输入线都可单独进行配置，以选择类型（中断或事件）和相应的触发事件（上升沿触发、下降沿触发或边沿触发）。</p>
<p>每根输入线还可单独屏蔽。</p>
<p>注：挂起寄存器用于保持中断请求的状态线。</p>
<p><mark>外部中断&#x2F;事件才需要经过EXTI，芯片外设的中断不用经过EXTI，直接到达NVIC。 </mark></p>
<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116192105.png" alt="image-20200815143912180" style="zoom:80%;" />

<ul>
<li>下降沿：数字电路中，数字电平从高电平（数字“1”）变为低电平（数字“0”）的那一瞬间叫作下降沿。</li>
<li>上升沿：数字电路中，数字电平从低电平（数字“0”）变为高电平（数字“1”）的那一瞬间叫作上升沿。</li>
</ul>
<h3 id="外部中断-事件线映射"><a href="#外部中断-事件线映射" class="headerlink" title="外部中断&#x2F;事件线映射"></a>外部中断&#x2F;事件线映射</h3><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116192112.png" alt="image-20200815145501467" style="zoom: 80%;" />

<p><mark>注意：一条中断线在同一时间只能被一个IO口映射。</mark></p>
<p>比如：PA0占用了EXTI0，其他PB0~PI0是不能使用的。</p>
<hr>
<h2 id="NVIC"><a href="#NVIC" class="headerlink" title="NVIC"></a>NVIC</h2><p>嵌套向量中断控制器 (NVIC) ，有两个重要功能：通道的设置，优先级设置。</p>
<p><strong>NVIC特性</strong><br>嵌套向量中断控制器 NVIC 包含以下特性：</p>
<ul>
<li><p>STM32F405xx&#x2F;07xx 和 STM32F415xx&#x2F;17xx 具有 82 个可屏蔽中断通道，STM32F42xxx和STM32F43xxx 具有多达 86 个可屏蔽中断通道（不包括 Cortex™-M4F 的 16 根中断线）</p>
</li>
<li><p>16 个可编程优先级（使用了 4 位中断优先级）</p>
</li>
<li><p>低延迟异常和中断处理</p>
</li>
<li><p>电源管理控制</p>
</li>
<li><p>系统控制寄存器的实现</p>
</li>
</ul>
<p>嵌套向量中断控制器 (NVIC) 和处理器内核接口紧密配合，可以实现低延迟的中断处理和晚到中断的高效处理。</p>
<p><strong>中断向量表（中断通道）</strong></p>
<p>cortex-M处理器的异常中，编号1-15的为系统异常，16及以上的则为中断输入。</p>
<p>部分系统异常具有可编程的优先级，部分系统异常具有固定优先级。</p>
<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116192118.png" alt="image-20200815145124002" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116192126.png" alt="image-20200914125509271" style="zoom:80%;" />

<p>PENDSV和SYSTICK的中断优先级可以编程，一般要把PENDSV的优先级设置成最低。</p>
<p>SYSTICK的优先级：</p>
<ul>
<li>一般无需设置(高于外部中断的优先级)，毕竟这是系统的时钟源(ucos心脏)。</li>
<li>可根据项目需要(有些外部中断，项目上要求务必实时)，将SYSTICK优先级设置与合适的位置。很多项目对于实时没有很高的要求，干脆将PENDSV和SYSTICK的优先级都设置成0xFF。此时，因为PENDSV在中断向量表中排在SYSTICK前面，所以如果PENDSV，SYSTICK同时产生中断，PENDSV优先中断。</li>
</ul>
<h3 id="中断优先级分组"><a href="#中断优先级分组" class="headerlink" title="中断优先级分组"></a>中断优先级分组</h3><p>首先，对STM32中断进行分组，组0~4。同时，对每个中断设置一个抢占优先级和一个响应优先级值。分组配置是在寄存器SCB-&gt;AIRCR中配置。</p>
<ul>
<li>第0组：所有4位用于指定响应优先级</li>
<li>第1组：最高1位用于指定抢占式优先级，最低3位用于指定响应优先级</li>
<li>第2组：最高2位用于指定抢占式优先级，最低2位用于指定响应优先级</li>
<li>第3组：最高3位用于指定抢占式优先级，最低1位用于指定响应优先级</li>
<li>第4组：所有4位用于指定抢占式优先级</li>
</ul>
<p>抢占优先级 &amp; 响应优先级区别：</p>
<ul>
<li>高优先级的抢占优先级是可以打断正在进行的低抢占优先级中断的。</li>
<li>抢占优先级相同的中断，高响应优先级不可以打断低响应优先级的中断。</li>
<li>抢占优先级相同的中断，当两个中断同时发生的情况下，哪个响应优先级高，哪个先执行。</li>
<li>如果两个中断的抢占优先级和响应优先级都是一样的话，则看哪个中断先发生就先执行。抢占优先级相同且响应优先级相同的中断，假如同时发生，会按照硬件内部固定的优先级执行。见中断向量表。</li>
</ul>
<p><strong>中断优先级：无论是抢占优先级还是响应优先级，优先级数值越小，优先级别越高。</strong></p>
<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116192133.png" alt="image-20200815152456795" style="zoom:80%;" />

<hr>
<h2 id="中断实现案例"><a href="#中断实现案例" class="headerlink" title="中断实现案例"></a>中断实现案例</h2><p>按键库开发要添加库文件：<code>stm32f4xx_exti.c</code>和<code>stm32f4xx_syscfg.c</code></p>
<ol>
<li><p>理解按键输入原理图</p>
</li>
<li><p>NVIC分组（一个工程当中只能配置一次分组，否则优先级的设置可能会乱，因为不同的优先级组的抢占优先级和响应优先级取值范围是不一样的）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NVIC_PriorityGroupConfig</span><span class="params">(<span class="type">uint32_t</span> NVIC_PriorityGroup)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使能SYSCFG时钟，使能GPIOA组时钟</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);</span><br><span class="line">RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);<span class="comment">//这个函数非常重要，在使用外部中断的时候一定要先使能SYSCFG时钟</span></span><br><span class="line"><span class="comment">//函数说明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCC_AHB1PeriphClockCmd</span><span class="params">(<span class="type">uint32_t</span> RCC_AHB1Periph, FunctionalState NewState)</span></span><br><span class="line">    函数功能：使能AHB1外设时钟</span><br><span class="line">    <span class="type">uint32_t</span> RCC_AHB1Periph：外设</span><br><span class="line">    FunctionalState NewState：使能状态  ENABLE or DISABLE</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>初始化IO口为输入</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GPIO_Init</span><span class="params">(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)</span>；</span><br><span class="line">    函数功能：GPIO初始化</span><br><span class="line">    GPIO_TypeDef* GPIOx：GPIO组（A B C D E F ...）</span><br><span class="line">    GPIO_InitTypeDef* GPIO_InitStruct:GPIO结构</span><br><span class="line"></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">uint32_t</span> GPIO_Pin;                <span class="comment">//引脚</span></span><br><span class="line">            GPIOMode_TypeDef GPIO_Mode;       <span class="comment">//模式</span></span><br><span class="line">            GPIOSpeed_TypeDef GPIO_Speed;      <span class="comment">//速度</span></span><br><span class="line">            GPIOOType_TypeDef GPIO_OType;      <span class="comment">//输出类型</span></span><br><span class="line">            GPIOPuPd_TypeDef GPIO_PuPd;       <span class="comment">//上下拉</span></span><br><span class="line">        &#125;GPIO_InitTypeDef;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>设置IO口与中断线的映射关系</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SYSCFG_EXTILineConfig</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化线上中断，设置触发条件等</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EXTI_Init</span><span class="params">(EXTI_InitTypeDef* EXTI_InitStruct)</span>;</span><br><span class="line">函数说明：外部中断控制器初始化</span><br><span class="line">EXTI_InitTypeDef* EXTI_InitStruct：外部中断控制器结构体</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">uint32_t</span> EXTI_Line;                    <span class="comment">//中继线</span></span><br><span class="line">        EXTIMode_TypeDef EXTI_Mode;          <span class="comment">//中断模式</span></span><br><span class="line">        EXTITrigger_TypeDef EXTI_Trigger;    <span class="comment">//触发条件</span></span><br><span class="line">        FunctionalState EXTI_LineCmd;       <span class="comment">//中断线使能</span></span><br><span class="line">    &#125;EXTI_InitTypeDef;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>配置中断分组（NVIC），并使能中断</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">NVIC_Init</span><span class="params">(NVIC_InitTypeDef* NVIC_InitStruct)</span>;</span><br><span class="line">    函数说明：NVIC控制控制器初始化</span><br><span class="line">    NVIC_InitTypeDef* NVIC_InitStruct：NVIC初始化结构体</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">uint8_t</span> NVIC_IRQChannel;                      <span class="comment">//NVIC通道，在stm32f4xx.h可查看通道</span></span><br><span class="line">        <span class="type">uint8_t</span> NVIC_IRQChannelPreemptionPriority;    <span class="comment">//抢占优先级</span></span><br><span class="line">        <span class="type">uint8_t</span> NVIC_IRQChannelSubPriority;        <span class="comment">//响应优先级</span></span><br><span class="line">        FunctionalState NVIC_IRQChannelCmd;       <span class="comment">//通道使能  </span></span><br><span class="line">    &#125; NVIC_InitTypeDef;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><p>编写中断服务函数。（中断服务函数的名字在<code>startup_stm32f40_41xxx.s</code>文件中）</p>
<p><code>EXTIx_IRQHandler();</code></p>
</li>
<li><p>按键消抖</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断中断标志是否为1</span></span><br><span class="line"><span class="keyword">if</span>(EXTI_GetITStatus(EXTI_Line0) == SET)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Bit_RESET == GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//消抖</span></span><br><span class="line">        delayms(<span class="number">15</span>);</span><br><span class="line">        <span class="keyword">if</span>(Bit_RESET == GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//等待按键松开。如果按键一直按下不松开的话,程序会卡在这里,所以一般不需要加这一句</span></span><br><span class="line">            <span class="comment">//如果设置按键中断的触发模式为下降沿,当有按键按下的时候,有下降沿产生,延时15ms后,如果还是读取到低电平,则会往下执行,改变灯的状态。在去掉这一句的情况下,程序不会卡在这里。而且,即使松开按键的时候存在下降沿,也不会二次进入这里来改变灯的状态,因为二次进入中断处理函数的时候,经过15ms的延时,GPIO_ReadInputDataBit读取到的将会是高电平,所以,不会进入这里来改变灯的状态</span></span><br><span class="line">            <span class="comment">//while(Bit_RESET == GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0));</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//变更灯状态</span></span><br><span class="line">            GPIO_ToggleBits(GPIOF, GPIO_Pin_9);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清空标志位</span></span><br><span class="line">    EXTI_ClearITPendingBit(EXTI_Line0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>嵌入式概念扫盲</category>
      </categories>
      <tags>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title>数据通信</title>
    <url>/2025/prefix%20remember%20to%20change!!!-c32fb0d47bf1/</url>
    <content><![CDATA[<h1 id="基本组成"><a href="#基本组成" class="headerlink" title="基本组成"></a>基本组成</h1><p><strong>数据通信系统是软硬件的结合体。</strong></p>
<p>数据指对数字、字母以及其组合意义的一种表达。数据通信是两点或多点之间，借助某种传输介质以二进制形式进行信息交换的过程。</p>
<p>数据通信技术主要涉及通信协议、信号编码、接口、同步、数据交换、安全、通信控制与管理等。</p>
<h2 id="广义数据通信模型"><a href="#广义数据通信模型" class="headerlink" title="广义数据通信模型"></a>广义数据通信模型</h2><ul>
<li>信源：待传输数据信息的产生者</li>
<li>发送器：将信息变换为适合在信道上传输的信号，接收器则相反</li>
<li>信道：发送器与接收器之间用于传输信号的物理介质</li>
<li>信宿：接收到的信号在这里转换成信息</li>
</ul>
<p>发送设备、接收设备和传输介质属于硬件。</p>
<p>发送设备：匹配信息源和传输介质，即将信源产生的报文经过编码变换为便于传送的信号形式，送往传输介质。</p>
<h2 id="通信软件"><a href="#通信软件" class="headerlink" title="通信软件"></a>通信软件</h2><p>报文和通信协议都属于通信系统的软件。</p>
<p><strong>报文</strong>：一般把需要传送的信息，包括文本、图像、参数、命令、声音等称为报文，它们是经过数字化后的信息。</p>
<p><strong>通信协议</strong>：通信设备之间控制数据通信与理解通信数据意义的一组规则。要素如下：</p>
<ul>
<li>语法：通信中的数据的结构、格式及数据表达的顺序</li>
<li>语义：通信帧的位流中的每个部分的含义</li>
<li>时序：数据发送时间和数据发送速率。收发双方通常以某种方式校对时钟周期，协调数据处理速度。</li>
</ul>
<hr>
<h1 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h1><h2 id="有效性指标"><a href="#有效性指标" class="headerlink" title="有效性指标"></a>有效性指标</h2><p><strong>数据传输速率</strong>：单位时间内传送的数据量。在数据通信中，常用时间间隔相同的波形来表示一位二进制数字。这个间隔称码元长度，这样的间隔内的信号称为二进制码元。</p>
<ul>
<li>比特率：每秒传输数据的二进制位数。比特是数据信号的最小单位。</li>
<li>波特率：每秒传输码元的数目。每个码元可以包含一个或多个二进制位。</li>
</ul>
<p><mark>讨论传输频带宽度时，采用波特率；涉及实际的数据传输能力时，采用比特率。</mark></p>
<p><strong>频带利用率</strong>：每赫兹带宽所能实现的比特率。</p>
<p><strong>通信效率</strong>：数据帧的传输时间和用于发送报文的所有时间之比。用于发送报文的时间包括竞用总线或等待令牌的排队时间、数据帧的传输时间、发送维护帧等。</p>
<h2 id="可靠性指标"><a href="#可靠性指标" class="headerlink" title="可靠性指标"></a>可靠性指标</h2><p><strong>误码率</strong>：二进制码在数据传输系统中被传错的概率。</p>
<hr>
<h1 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h1><h2 id="串行传输和并行传输"><a href="#串行传输和并行传输" class="headerlink" title="串行传输和并行传输"></a>串行传输和并行传输</h2><p><strong>串行</strong></p>
<p>数据流以串行的方式逐位在一条信道上传输。每次发送一个数据位，发送方要明确先发送数据字节的高位还是低位，接收方要知道接收的字节的第一个数据位应在什么位置。</p>
<p>优点：易于实现、长距离传输中可靠性高。远距离数据通信，需要双方采取同步措施。</p>
<p><strong>并行</strong></p>
<p>数据以成组的形式在两条以上的并行通道上同时传输。需要的传输线多，在近距离的设备之间进行数据传输时采用。如：计算机和外围设备之间的通信。</p>
<p>串口类似于一条车道，而并口就是有8个车道同一时刻能传送8位（一个字节）数据。但并不是并口快，由于8位通道之间的互相干扰，传输时速度就受到了限制，而且当传输出错时，要同时重新传8个位的数据。串行接口没有干扰，传输出错后重发一位就可以了。故要比并口快。</p>
<h2 id="同步传输和异步传输"><a href="#同步传输和异步传输" class="headerlink" title="同步传输和异步传输"></a>同步传输和异步传输</h2><p>数据通信系统中，处理工作总是在一定的时序脉冲控制下进行的。收发端工作的协调一致性就是数据通信系统的传输同步问题。串行通信中，发送和接收方都要用时钟信号，通过时钟决定什么时候发送和读取每一位数据。</p>
<p><mark>同步传输和异步传输都是串行通信，只是使用时钟信号的方式不同。</mark></p>
<p><strong>同步传输</strong></p>
<p>所有设备使用同一个时钟，这个时钟可以是参与通信的设备产生，也可以是外部提供。所有传输的数据位都和这个时钟信号同步，即传输的每个数据位只在时钟信号的上升沿或下降沿之后的一个规定时间内有效。接收方利用时钟跳变决定什么时候读入一个数据位。</p>
<p>优点：传输效率比异步高，适合高速传输。长距离的数据通信，同步传输的代价较高，要一条额外的线来传输时钟信号，并且容易受到噪声的干扰。</p>
<p><strong>异步传输</strong></p>
<p>每个通信节点必须在通信速率上保持一致，误差不超过一定范围。当传输一个字节时，通常会包括一个起始位来同步时钟，不要求在传送信号的每一数据位时收发两端都同步。</p>
<p>当需要传输数据时，从不传输数据的状态转到起始位状态时，接收端检测出电平极性状态改变，启动定时器，实现同步。接收端收到停止时，定时器复位，为后面接收数据做准备。</p>
<p>优点：实现简单容易，对线路和收发器的要求较低。</p>
<h2 id="位同步、字符同步、帧同步"><a href="#位同步、字符同步、帧同步" class="headerlink" title="位同步、字符同步、帧同步"></a>位同步、字符同步、帧同步</h2><p>按传输数据的基本组织单位可以分为：</p>
<ul>
<li>位同步：收发两端的时钟同步，即位同步，每个数据位必须在收发两端保持同步。接收端可以从接收信号提取位同步信号。</li>
<li>字符同步：将字符组织成组后连续传输，每组字符前必须将上一个或多个同步字符SYN。接收端接收同步字符，并根据它来确定字符的起始位置。</li>
<li>帧同步：按事先约定的数据信息组织成组的形式。</li>
</ul>
<hr>
<h1 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h1><ol>
<li><p>单工：数据传输只支持数据在一个方向上传输(收音机、遥控器)</p>
</li>
<li><p>半双工：允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信；（对讲机）</p>
</li>
<li><p>全双工：允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合，它要求发送设备和接收设备都有独立的接收和发送能力。（电话机）</p>
<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116192320.png" alt="image-20200822095906898" style="zoom:67%;" /></li>
</ol>
<hr>
<h1 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h1><h2 id="差错控制方式"><a href="#差错控制方式" class="headerlink" title="差错控制方式"></a>差错控制方式</h2><p>接收端经过译码，能查出码中存在差错，但不知道差错的确切位置，称为检错译码；能判定差错位置并加以纠正，称为纠错译码。</p>
<ol>
<li><p>循环传送检错</p>
<p>信号源的同一信息被周期性地循环发送。发送端由信道编码器对信息进行抗干扰编码后发送出去（<strong>可检错</strong>），接收端收到数码后经检错译码判断有无错码。若无，则该组数码可用；若有，则丢弃不用，等下次循环再接收该组数码信息。检错方式简单，容易实现，信道利用率不高。只需单向信道。</p>
</li>
<li><p>前向纠错</p>
<p>发送端由信道编码形成<strong>可纠错</strong>的码发出去，接收端将收到的数码经信道译码器进行纠错译码。</p>
<p>优点：只需单向信道，可纠一定错，译码器复杂。</p>
</li>
<li><p>自动要求重传</p>
<p>发<strong>可检错</strong>码，接收端检错译码。判断有无错码，通过反馈信道把结果送到发送端。有错码，发送端要重传该数码，直到无错。要求有反馈信道，干扰严重时，重传数变多，影响通信的连贯性，传输效率低。编码译码比较简单。</p>
</li>
<li><p>信息反馈</p>
<p>接收端把收到的信息通过反馈信道原样送到发送端，发送端将反馈回来的信息与原来的信息进行比较，有错码，原信息再次传送。控制电路简单，需反馈信道，效率低。</p>
</li>
<li><p>混合纠错</p>
<p>前向纠错和自动重传的综合。发的数码可以检错和纠错。接收端首先进行纠错，错误码太多，超过其纠错能力，就要求发送端重发。</p>
</li>
</ol>
<h2 id="常用检错码"><a href="#常用检错码" class="headerlink" title="常用检错码"></a>常用检错码</h2><ol>
<li><p>奇偶校验</p>
<p>奇偶指数码中的“1”的个数是奇数还是偶数。在数码后面加一位奇偶校验位，加上后形成的数码中使“1”的个数为偶数，就称偶校验；为奇，称奇校验。接收端检查“1”的位数就可以发现错误。只加一位奇偶校验位，编码效率高，就能检出所有<strong>奇数</strong>个差错。</p>
</li>
<li><p>水平一致校验</p>
<p>将信息序列以长度L分成小组，依次排成m列，得到L行m列的表格。对水平方向每行进行奇偶校验，得到一列校验码元，附在各列之后，按列发送。接收端译码时把收到的码元按L*m排列，检查每行是否满足奇偶检验规则。校验位有L位，能检测出长度不大于L（因为是按列发送的）的单个突发错误及其它错误情况。</p>
</li>
<li><p>水平垂直一致校验</p>
<p>在水平一致校验的基础上，对列的码元进行奇偶校验组成水平垂直一致校验码。发送时，可以按行，也可以按列。接收端译码时，检查每行每列是否满足校验规则。水平校验码L位，垂直校验码m位，能发现长度不大于L+1（按列发送）或m+1（按行发送）的单个突发错误及其它错误情况。</p>
</li>
<li><p>校验和</p>
<p>把m个长位<code>l</code>的数码做为二进制数，按模相加，形成校验和。将校验和附在m个信息组之后一起传送。接收端同样的方式按模相加，得到的校验和与收到的校验和相比，是否一致。按模运算只保留<code>l</code>位，将溢出舍弃。</p>
</li>
<li><p>循环冗余校验</p>
<ul>
<li>多项式及其运算：n位二进制数，可用（n-1）阶多项式表示。多项式运算必须按照模2运算规则运算，即异或运算。</li>
<li>CRC算法<br><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201226200811.png" alt="image-20201226200800288"></li>
<li>求CRC字节的方法主要有软件直接求取和软件查表求取。<ul>
<li>软件运算直接求取，每处理一个字节要运算8次，较费时。</li>
<li>查表法：一个字节可以有256种组合。把这256种组合所对应的CRC字节事先算好，存在flash的CRC字节表中，需要时查表，耗时短。空间换时间。</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>嵌入式概念扫盲</category>
      </categories>
      <tags>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>IIC介绍</title>
    <url>/2025/prefix%20remember%20to%20change!!!-ad3df2fe07bc/</url>
    <content><![CDATA[<h1 id="什么是IIC"><a href="#什么是IIC" class="headerlink" title="什么是IIC"></a>什么是IIC</h1><p>I2C(IIC,Inter－Integrated Circuit)，<strong>两线式串行通信总线</strong>，其实是IICBus简称，所以中文应该叫<strong>集成电路总线</strong>，它是一种串行通信总线，使用多主从架构。由PHILIPS公司开发用于连接微控制器及其外围设备。它是由数据线SDA和时钟SCL构成的串行总线，可发送和接收数据。在CPU与被控IC之间、IC与IC之间进行双向传送，高速IIC总线一般可达<strong>400kbps</strong>。 </p>
<p>IIC是<strong>半双工</strong>通信方式，SDA 和 SCL 都是双向的；数据可以在主设备和从设备之间来回传送。主设备启动总线上的所有数据传输，并生成所有时钟信号。在开始传输数据之前，主设备必须先寻址一个特定的从设备并接收一条确认信息。</p>
<h1 id="协议层"><a href="#协议层" class="headerlink" title="协议层"></a>协议层</h1><p>每个I2C数据操作都由以下元素组成：启动（或重复启动）、寻址、数据和停止。</p>
<h2 id="空闲"><a href="#空闲" class="headerlink" title="空闲"></a>空闲</h2><p>I2C总线总线的SDA和SCL两条信号线同时处于高电平时，规定为总线的空闲状态。此时各个器件的输出级场效应管均处在截止状态，即释放总线，由两条信号线各自的上拉电阻把电平拉高。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116192906.png" alt="image-20200822161555286"></p>
<h2 id="启动或重复启动"><a href="#启动或重复启动" class="headerlink" title="启动或重复启动"></a>启动或重复启动</h2><p>主设备控制时钟线路，因此它启动总线上的所有通信。要控制总线并启动数据传输，主设备会首先发送一个启动条件。 </p>
<p>启动条件向总线上的所有器件发送信号，通知主设备已经控制了总线，并将发送一个地址。此时，总线即被视为繁忙，其他主设备必须等待停止条件使总线恢复空闲状态后，才能启动数据传输。  </p>
<p>重复启动条件在物理层面上与启动条件相同。它表示主设备已经维持对总线的控制而且该总线没有处于闲置状态。</p>
<p><strong>启动信号</strong></p>
<p>当SCL为高期间，SDA由高到低的跳变；启动信号是一种电平跳变时序信号，而不是一个电平信号。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116192911.png" alt="image-20200822161710522"></p>
<h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><p>主设备发出启动信号后，发送的第一个数据字节就是地址。每个从设备都有唯一的地址。</p>
<p>大多数I2C地址的长度都为七个数据位，加上一个读&#x2F;写（R&#x2F;W）位凑满8位，并指出接下来数据传输的通信方向。</p>
<p>“读”代表主设备希望从设备中读取数据；“写”表明主设备希望向从设备中写入数据。</p>
<p><strong>所有地址和数据字节都优先发送最高有效位 （MSB）。</strong></p>
<h2 id="ACK-NACK"><a href="#ACK-NACK" class="headerlink" title="ACK&#x2F;NACK"></a>ACK&#x2F;NACK</h2><p>主设备发送地址后，等待从设备发出确认（ACK）信息。总线上所有从设备都要读取接收到的地址，并将其与自己的内部地址进行比较。如果地址相匹配，从设备必须在第九个时钟循环发出ACK信息。如果地址不相匹配，从设备将不响应。</p>
<p>ACK是一个附加的状态位，位于每个数据字节的末尾，因此，所有I2C数据传输的长度都是九位。发送器每发送一个字节，就在时钟脉冲9期间释放数据线，由接收器反馈一个应答信号。应答信号为低电平时，规定为有效应答位（ACK简称应答位），表示接收器已经成功地接收了该字节；应答信号为高电平时，规定为非应答位（NACK），一般表示接收器接收该字节没有成功。</p>
<p>对于反馈有效应答位ACK的要求是，接收器在第9个时钟脉冲之前的低电平期间将SDA线拉低，并且确保在该时钟的高电平期间为稳定的低电平。 如果接收器是主控器，则在它收到最后一个字节后，发送一个NACK信号，以通知被控发送器结束数据发送，并释放SDA线，以便主控接收器发送一个停止信号。</p>
<p>释放数据线：<a href="https://www.cnblogs.com/CodeWorkerLiMing/p/10830778.html">IIC如何释放数据总线? 为什么&#x3D;1就是释放? - wdliming - 博客园</a></p>
<p><strong>ACK总结：</strong></p>
<ul>
<li>规定如果是发送一个字节，必须接受一个应答信号；同理，接受一个字节，必定发送一个应答信号。</li>
<li>规定应答信号：低电平是有效应答（也就是正常接受了一个字节数据），高电平为无效应答，也称为非应答（也就是接受字节异常，或者是用于结束接受）</li>
</ul>
<h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><p>主设备发送地址而且从设备确认后，后续每次可以传送八位数据。主设备和从设备都可以传送和接收，因此它们一起拥有SDA线的控制权。</p>
<h3 id="数据的有效性"><a href="#数据的有效性" class="headerlink" title="数据的有效性"></a>数据的有效性</h3><p>I2C总线进行数据传送时，时钟信号为高电平期间，数据线上的数据必须保持稳定，只有在时钟线上的信号为低电平期间，数据线上的高电平或低电平状态才允许变化。即：数据在SCL的上升沿到来之前就需准备好。并在在下降沿到来之前必须稳定。且仅当SCL为低电平时，才能更改SDA上的数据。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116192841.png" alt="image-20200823132727777" style="zoom:80%;" /><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116192927.png" alt="image-20200822162533199"></p>
<h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><p>在I2C总线上传送的每一位数据都有一个时钟脉冲相对应（或同步控制），即在SCL串行时钟的配合下，在SDA上逐位地串行传送每一位数据。数据位的传输是边沿触发。</p>
<p>主设备执行写入操作时，在SDA上写出八位的数据，并在SCL上提供八个时钟周期。主设备发送八位数据后，从设备负责在第九个时钟周期发送ACK或者NAK信号；请参考图7。</p>
<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116192846.png" alt="image-20200823133148069" style="zoom:67%;" />

<ul>
<li><p>ACK &#x3D; 从设备有足够空间容纳更多数据。</p>
</li>
<li><p>NAK &#x3D; 从设备无法容纳更多数据。</p>
</li>
</ul>
<p>交替条件表明主设备希望在从设备中读取数据。在这种情况下，主设备会提供八个时钟周期，但是从设备在SDA上传输八个数据位。传输八个数据位后，主设备必须发送ACK或NAK信号。</p>
<ul>
<li>ACK &#x3D; 主设备希望读取更多数据。</li>
<li>NAK &#x3D; 主设备读取完毕。</li>
</ul>
<p>注意：从设备无法通知主设备没有要发送的数据。</p>
<h2 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h2><p>发送所有字节后，主设备要发送一个停止条件，表明当前数据传输已完成，总线处于闲置状态。</p>
<p>除了发送停止条件之外，主设备还可以发送重复启动条件。重复启动条件在物理层面上与启动条件相同。</p>
<p>当主设备想要通知从设备开始新的数据传输或者更改数据流的方向时，主设备会发送重复启动条件，这样可以保持对总线的控制。当主设备想要向特定的从设备写入数据，然后反过来从该从设备中读取数据时，需要使用重复启动条件。</p>
<p>通过使用重复启动条件，主设备可以维持对总线的控制。如果使用停止条件，则总线可能由其他主设备控制。</p>
<p><strong>停止信号</strong></p>
<p>当SCL为高期间，SDA由低到高的跳变；停止信号也是一种电平跳变时序信号，而不是一个电平信号。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116192916.png" alt="image-20200822161737129"></p>
<h2 id="仲裁"><a href="#仲裁" class="headerlink" title="仲裁"></a>仲裁</h2><p>I2C协议允许多个主设备在同一总线上进行通信。两个主设备可以同时进行通信。为了防止数据丢失，每个I2C主设备都必须查看I2C总线，确保总线上的数据为自己所提供。如果数据不匹配，仲裁失败的I2C主设备必须停止驱动SDA线，并等待总线闲置后再重新尝试发送数据。</p>
<p>如图10所示，当一个主设备将SDA保持为高电平，而另一个主设备尝试将SDA驱动至低电平时，前者仲裁失败，必须等待。</p>
<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116192853.png" alt="image-20200823134806106" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116192859.png" alt="image-20200822160653691" style="zoom:67%;" />

<h2 id="模拟IIC"><a href="#模拟IIC" class="headerlink" title="模拟IIC"></a>模拟IIC</h2><p>MCU有部分引脚的复用功能，本身实现并支持IIC通信，但不是所有引脚都是这样。在IO资源有限的情况下，可以使用任意两个引脚模拟实现IIC时序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">引脚说明：(可以是任意两个引脚)</span></span><br><span class="line"><span class="comment">PB8 -- SCL</span></span><br><span class="line"><span class="comment">PB9 -- SDA</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Iic_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef  GPIO_InitStruct;</span><br><span class="line">    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);</span><br><span class="line"></span><br><span class="line">    GPIO_InitStruct.GPIO_Pin    = GPIO_Pin_8|GPIO_Pin_9;        <span class="comment">//引脚8 9</span></span><br><span class="line">    GPIO_InitStruct.GPIO_Mode    = GPIO_Mode_OUT;    <span class="comment">//输出模式</span></span><br><span class="line">    GPIO_InitStruct.GPIO_OType    = GPIO_OType_PP;    <span class="comment">//推挽</span></span><br><span class="line">    GPIO_InitStruct.GPIO_Speed    = GPIO_Speed_50MHz; <span class="comment">//快速</span></span><br><span class="line">    GPIO_InitStruct.GPIO_PuPd    = GPIO_PuPd_UP;     <span class="comment">//上拉</span></span><br><span class="line">    GPIO_Init(GPIOB, &amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//总线空闲</span></span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    SDA_OUT = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//切换SDA模式</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Iic_Sda_Mode</span><span class="params">(GPIOMode_TypeDef Mode)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef  GPIO_InitStruct;</span><br><span class="line"></span><br><span class="line">    GPIO_InitStruct.GPIO_Pin    = GPIO_Pin_9;        <span class="comment">//引脚9</span></span><br><span class="line">    GPIO_InitStruct.GPIO_Mode    = Mode;    </span><br><span class="line">    GPIO_InitStruct.GPIO_OType    = GPIO_OType_PP;    <span class="comment">//推挽</span></span><br><span class="line">    GPIO_InitStruct.GPIO_Speed    = GPIO_Speed_50MHz; <span class="comment">//快速</span></span><br><span class="line">    GPIO_InitStruct.GPIO_PuPd    = GPIO_PuPd_UP;     <span class="comment">//上拉</span></span><br><span class="line">    GPIO_Init(GPIOB, &amp;GPIO_InitStruct);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Iic_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Iic_Sda_Mode(GPIO_Mode_OUT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//总线空闲</span></span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    SDA_OUT = <span class="number">1</span>;</span><br><span class="line">    delay_us(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    SDA_OUT = <span class="number">0</span>;</span><br><span class="line">    delay_us(<span class="number">5</span>);</span><br><span class="line">    SCL = <span class="number">0</span>;  <span class="comment">//钳住总线</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//停止信号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Iic_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Iic_Sda_Mode(GPIO_Mode_OUT);</span><br><span class="line"></span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    SDA_OUT = <span class="number">0</span>;</span><br><span class="line">    delay_us(<span class="number">5</span>);    </span><br><span class="line"></span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    delay_us(<span class="number">5</span>);</span><br><span class="line">    SDA_OUT = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送一位数据 </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Iic_Send_Ack</span><span class="params">(u8 ack)</span></span><br><span class="line">&#123;</span><br><span class="line">    Iic_Sda_Mode(GPIO_Mode_OUT);</span><br><span class="line"></span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//准备数据</span></span><br><span class="line">    <span class="comment">//要发数据1</span></span><br><span class="line">    <span class="keyword">if</span>(ack == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        SDA_OUT = <span class="number">1</span>;     <span class="comment">//引脚输1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//要发数据0</span></span><br><span class="line">    <span class="keyword">if</span>(ack == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        SDA_OUT = <span class="number">0</span>;     <span class="comment">//引脚输0</span></span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    delay_us(<span class="number">5</span>);</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    delay_us(<span class="number">5</span>);<span class="comment">//两个延时5us,则为10us一个脉冲周期</span></span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发一个字节</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Iic_Send_Byte</span><span class="params">(u8 data)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i;</span><br><span class="line"></span><br><span class="line">    Iic_Sda_Mode(GPIO_Mode_OUT);</span><br><span class="line"></span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//准备数据 如数据 0x87 1 0 0 0 0 1 1 1 </span></span><br><span class="line">        <span class="keyword">if</span>(data &amp; (<span class="number">1</span>&lt;&lt;(<span class="number">7</span>-i)))  </span><br><span class="line">        &#123;</span><br><span class="line">            SDA_OUT = <span class="number">1</span>;     <span class="comment">//引脚输1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//要发数据0</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            SDA_OUT = <span class="number">0</span>;     <span class="comment">//引脚输0</span></span><br><span class="line">        &#125;    </span><br><span class="line">        delay_us(<span class="number">5</span>);</span><br><span class="line">        SCL = <span class="number">1</span>;</span><br><span class="line">        delay_us(<span class="number">5</span>);</span><br><span class="line">        SCL = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接受一位数据</span></span><br><span class="line">u8 <span class="title function_">Iic_Recv_Ack</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 ack = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Iic_Sda_Mode(GPIO_Mode_IN);<span class="comment">//模式设置为输入。这里就相当于释放了数据线</span></span><br><span class="line"></span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    delay_us(<span class="number">5</span>);</span><br><span class="line">    SCL = <span class="number">1</span>;</span><br><span class="line">    delay_us(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(SDA_IN == <span class="number">1</span>) <span class="comment">//判断引脚电平是否为高电平</span></span><br><span class="line">    &#123;</span><br><span class="line">        ack = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(SDA_IN == <span class="number">0</span>) <span class="comment">//判断引脚电平是否为低电平</span></span><br><span class="line">    &#123;</span><br><span class="line">        ack = <span class="number">0</span>;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接受一个字节</span></span><br><span class="line">u8 <span class="title function_">Iic_Recv_Byte</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i, data = <span class="number">0</span>;  <span class="comment">//0 0 0 0 0 0 0 0</span></span><br><span class="line"></span><br><span class="line">    Iic_Sda_Mode(GPIO_Mode_IN);</span><br><span class="line"></span><br><span class="line">    SCL = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//循环8次，接受一个字节</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">    &#123;    </span><br><span class="line">        delay_us(<span class="number">5</span>);</span><br><span class="line">        SCL = <span class="number">1</span>;</span><br><span class="line">        delay_us(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">if</span>(SDA_IN == <span class="number">1</span>) <span class="comment">//判断引脚电平是否为高电平</span></span><br><span class="line">        &#123;</span><br><span class="line">            data |= (<span class="number">1</span>&lt;&lt;(<span class="number">7</span>-i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SCL = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="AT24C02"><a href="#AT24C02" class="headerlink" title="AT24C02"></a>AT24C02</h1><p>AT24C02是一个串行CMOS EEPROM，该器件通过<strong>IIC</strong>总线接口进行操作，有一个专门的写保护功能。AT24C02的存储容量为2K bit，内容分成32页，每页8Byte，共256Byt。操作时有两种寻址方式：芯片寻址和片内子地址寻址。</p>
<ol>
<li>芯片寻址：AT24C02的芯片地址为1010，其地址控制字格式为1010+A2+A1+A0+R&#x2F;W。其中A2，A1，A0可编程地址选择位。A2，A1，A0引脚接高、低电平后得到确定的三位编码，与1010形成7位编码，即为该器件的地址码。R&#x2F;W为芯片读写控制位，该位为0，表示芯片进行写操作。</li>
<li>片内子地址寻址：芯片寻址可对内部256B中的任一个进行读&#x2F;写操作，其寻址范围为00~FF，共256个寻址单位。</li>
</ol>
<p><strong>电路原理图</strong></p>
<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116192943.png" alt="image-20200822161519605" style="zoom: 67%;" />

<p><strong>24C02简介</strong></p>
<ul>
<li><p>24C02是一个2K位串行CMOS 的EEPROM，内部含有256个8位字节。</p>
</li>
<li><p>与 400KHz I2C 总线兼容</p>
</li>
<li><p>1.8 到 6.0 伏工作电压范围</p>
</li>
<li><p>低功耗 CMOS 技术</p>
</li>
<li><p>写保护功能 当 WP 为高电平时进入写保护状态</p>
</li>
<li><p>页写缓冲器</p>
</li>
<li><p>自定时擦写周期 </p>
</li>
<li><p>1,000,000 编程&#x2F;擦除周期</p>
</li>
<li><p>可保存数据 100 年</p>
</li>
</ul>
<h2 id="AT24C02地址意义"><a href="#AT24C02地址意义" class="headerlink" title="AT24C02地址意义"></a>AT24C02地址意义</h2><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116192948.png" alt="image-20200822163957453" style="zoom: 80%;" />

<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116192954.png" alt="image-20200822164038218" style="zoom:80%;" />

<p>高四位1010是24Cxx系列的固定器件地址，接下来是A2、A1、A0是根据器件连接来决定，我们的原理图都接地所以是000。R&#x2F;W为是选择读还是写，1的时候是读，0的时候是写。</p>
<p>所以写操作的地址为0xA0，读操作的地址是A1。</p>
<h2 id="写时序"><a href="#写时序" class="headerlink" title="写时序"></a>写时序</h2><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193002.png" alt="image-20200822164301888" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193007.png" alt="image-20200822164829219" style="zoom:80%;" />

<h2 id="读时序"><a href="#读时序" class="headerlink" title="读时序"></a>读时序</h2><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193012.png" alt="image-20200822165654054" style="zoom:67%;" /> 

<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用前面所述的模拟IIC</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AT24C02_Write</span><span class="params">(u8 addr, u8 *write_buf, u8 len)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 ack;</span><br><span class="line">    <span class="comment">//开始信号</span></span><br><span class="line">    Iic_Start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送设备地址，并执行写操作</span></span><br><span class="line">    Iic_Send_Byte(<span class="number">0xA0</span>);</span><br><span class="line">    ack = Iic_Recv_Ack();</span><br><span class="line">    <span class="keyword">if</span>(ack == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ack failure\n&quot;</span>);</span><br><span class="line">        Iic_Stop();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送写数据的起始地址</span></span><br><span class="line">    Iic_Send_Byte(addr);</span><br><span class="line">    ack = Iic_Recv_Ack();</span><br><span class="line">    <span class="keyword">if</span>(ack == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ack failure\n&quot;</span>);</span><br><span class="line">        Iic_Stop();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(len--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//发送数据</span></span><br><span class="line">        Iic_Send_Byte(*write_buf);</span><br><span class="line">        ack = Iic_Recv_Ack();</span><br><span class="line">        <span class="keyword">if</span>(ack == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ack failure\n&quot;</span>);</span><br><span class="line">            Iic_Stop();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//地址加1</span></span><br><span class="line">        write_buf++;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Iic_Stop();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;write finish\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">AT24C02_Read</span><span class="params">(u8 addr, u8 *read_buf, u8 len)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 ack;</span><br><span class="line">    <span class="comment">//开始信号</span></span><br><span class="line">    Iic_Start();</span><br><span class="line">    <span class="comment">//发送设置地址，并执行写操作</span></span><br><span class="line">    Iic_Send_Byte(<span class="number">0xA0</span>);</span><br><span class="line">    ack = Iic_Recv_Ack();</span><br><span class="line">    <span class="keyword">if</span>(ack == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ack failure\n&quot;</span>);</span><br><span class="line">        Iic_Stop();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送读数据的起始地址</span></span><br><span class="line">    Iic_Send_Byte(addr);</span><br><span class="line">    ack = Iic_Recv_Ack();</span><br><span class="line">    <span class="keyword">if</span>(ack == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ack failure\n&quot;</span>);</span><br><span class="line">        Iic_Stop();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="comment">//开始信号</span></span><br><span class="line">    Iic_Start();<span class="comment">//重复启动条件。可能是启动条件后面发送的第一个字节一定是地址吧，不然就当普通数据处理了。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送设备地址，并执行读操作</span></span><br><span class="line">    Iic_Send_Byte(<span class="number">0xA1</span>);</span><br><span class="line">    ack = Iic_Recv_Ack();</span><br><span class="line">    <span class="keyword">if</span>(ack == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ack failure\n&quot;</span>);</span><br><span class="line">        Iic_Stop();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(len--)  <span class="comment">//len = 5</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// len 4 3 2 1 0</span></span><br><span class="line">        <span class="comment">//接受数据</span></span><br><span class="line">        *read_buf = Iic_Recv_Byte();</span><br><span class="line">        <span class="comment">//地址加1</span></span><br><span class="line">        read_buf++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">            Iic_Send_Ack(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送非应答</span></span><br><span class="line">    Iic_Send_Ack(<span class="number">1</span>);    </span><br><span class="line">    Iic_Stop();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;read finish\n&quot;</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="OLED"><a href="#OLED" class="headerlink" title="OLED"></a>OLED</h1><p><strong>硬件连接图</strong></p>
<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193019.png" alt="image-20200822172430274" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193027.png" alt="image-20200822172541989" style="zoom:67%;" />

<p>OLED本身是没有显存的，它的显存是依赖于SSD1306（驱动芯片）提供的，SSD1306本身是不带字库的，只能通过绘图扫描的方式来进行显示。</p>
<p>SSD1306的显存<strong>GDDRAM在串行模式下不提供数据读</strong>，总共为128 * 64bit大小，SSD1306将这些显存分为了8页。每页包含了128个字节，总共8页，这样刚好是128*64的点阵大小。</p>
<p>虽然不提供数据读，但是我们可以构建一个虚拟缓存<code>unsigned char GDDRAM[8][128]</code>，每次向SSD1306的显存中更新这个数组的值，而在程序中就只需要对数组做操作。</p>
<p><a href="https://blog.csdn.net/weixin_42415539/article/details/85212043">0.96寸OLED驱动（基于STM32f103）_0.96 tft ui-CSDN博客</a></p>
<h2 id="内存地址模式"><a href="#内存地址模式" class="headerlink" title="内存地址模式"></a>内存地址模式</h2><p>内存地址模式一共有三种：页地址模式，水平地址模式和垂直地址模式。需要使用命令将地址模式设置为以上三种之一。</p>
<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193035.png" alt="image-20200914232207021" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193040.png" alt="image-20200914233057167" style="zoom:67%;" />

<ul>
<li><p>页地址模式(A[1:0]&#x3D;10b)<br>当处于此模式时，在GDDRAM访问后(读&#x2F;写)，<strong>列地址</strong>指针将自动增加1。如果列地址指针到达列终止地址，列地址指针将复位到列起始地址，但页地址指针不会改变。为了访问GDDRAM中下一页的内容，用户必须设置新的页地址和列地址。通常在页地址模式下访问GDDRAM, 需要如下步骤来定义起始RAM访问指针指向:</p>
<ul>
<li>通过命令(B0h-B7h)设置目标显示位置页起始地址</li>
<li>通过命令(00h-0Fh)设置列起始地址低位</li>
<li>通过命令(10h-1Fh)设置列起始地址高位（移植的源码经过测试只用了三位）</li>
</ul>
<p>如果页地址是B2h，列地址低位是03h，列地址高位是10h，起始列将为PAGE2的SEG3。    </p>
<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201129213806.png" alt="image-20201129213806741" style="zoom:67%;" />
</li>
<li><p>水平地址模式(A[1:0]&#x3D;00b)<br>当处于此模式时, 在GDDRAM访问后(读&#x2F;写), <strong>列地址</strong>指针将自动增加1。如果列地址指针到达列终止地址, 列地址指针将复位到列起始地址, 且页地址指针将自动增加1。水平地址模式下页以及列地址指针的行为如下图所示, 如果列地址指针和页地址指针都到达各自的终止地址时, 他们都将复位到各自的起始地址。(图中虚线)</p>
<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193052.png" alt="image-20200914180435644" style="zoom:67%;" />
</li>
<li><p>垂直地址模式(A[1:0]&#x3D;01b)<br>当处于此模式时, 在GDDRAM访问后(读&#x2F;写), <strong>页地址</strong>指针将自动增加1。如果页地址指针到达页终止地址, 页地址指针将复位到页起始地址, 且列地址指针将自动增加1。垂直地址模式下页以及列地址指针的行为如下图所示, 如果列地址指针和页地址指针都到达各自的终止地址时, 他们都将复位到各自的起始地址。(图中虚线)</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193058.png" alt="image-20200914180516635"></p>
</li>
</ul>
<h2 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>使用移植核心文件中的代码（路径：D:\STM32\<span class="number">09</span>\移植核心文件），移植程序</span><br><span class="line">DelayInit();修改为STM32平台Delay_Init();</span><br><span class="line">I2C_Configuration();里面的初始化修改为模拟IIC初始化（PE8 PE10）</span><br><span class="line">OLED_Init();函数里面的延时函数修改为STM32F407的延时函数</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>修改函数</span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_WriteByte</span><span class="params">(<span class="type">uint8_t</span> addr,<span class="type">uint8_t</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//启动信号</span></span><br><span class="line">    I2C_GenerateSTART(I2C1, ENABLE);<span class="comment">//开启I2C1</span></span><br><span class="line">    <span class="keyword">while</span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT));<span class="comment">/*EV5,主模式*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送设备地址（一个字节）</span></span><br><span class="line">    I2C_Send7bitAddress(I2C1, OLED_ADDRESS, I2C_Direction_Transmitter);<span class="comment">//器件地址 -- 默认0x78</span></span><br><span class="line">    <span class="comment">//等待应答</span></span><br><span class="line">    <span class="keyword">while</span>(!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送寄存器地址（一个字节）</span></span><br><span class="line">    I2C_SendData(I2C1, addr);<span class="comment">//寄存器地址</span></span><br><span class="line">    <span class="comment">//等待应答</span></span><br><span class="line">    <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送数据（一个字节）</span></span><br><span class="line">    I2C_SendData(I2C1, data);<span class="comment">//发送数据</span></span><br><span class="line">    <span class="comment">//等待应答</span></span><br><span class="line">    <span class="keyword">while</span> (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED));</span><br><span class="line">    <span class="comment">//停止信号</span></span><br><span class="line">    I2C_GenerateSTOP(I2C1, ENABLE);<span class="comment">//关闭I2C1总线</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>修改主函数当中的延时函数，修改相关头文件</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span>头文件修改为 #<span class="keyword">include</span> <span class="string">&quot;stm32f4xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">WriteCmd(<span class="number">0xAE</span>); <span class="comment">//关闭显示 休眠</span></span><br><span class="line">WriteCmd(<span class="number">0x20</span>);    <span class="comment">//设置内存寻址模式    </span></span><br><span class="line">WriteCmd(<span class="number">0x10</span>);    <span class="comment">//00，水平寻址模式；01，垂直寻址模式；10，页面寻址模式（复位）；11，无效</span></span><br><span class="line"></span><br><span class="line">WriteCmd(<span class="number">0xb0</span>);    <span class="comment">//为页面寻址模式设置页面起始地址，0-7</span></span><br><span class="line">WriteCmd(<span class="number">0xc8</span>);    <span class="comment">//设置COM输出扫描方向。此指令用于设置列输出的扫描方向, 增强了OLED模块设计的布局的伸缩性。</span></span><br><span class="line">                <span class="comment">//注意, 此指令会立即生效。例如当屏幕正常显示时调用此指令, 屏幕将会立刻垂直翻转。</span></span><br><span class="line">WriteCmd(<span class="number">0x00</span>); <span class="comment">//设置低位列地址</span></span><br><span class="line">WriteCmd(<span class="number">0x10</span>); <span class="comment">//设置高位列地址</span></span><br><span class="line">WriteCmd(<span class="number">0x40</span>); <span class="comment">//设置起始行地址</span></span><br><span class="line"></span><br><span class="line">WriteCmd(<span class="number">0x81</span>); <span class="comment">//设置对比度控制寄存器</span></span><br><span class="line">WriteCmd(<span class="number">0xff</span>); <span class="comment">//亮度调节 0x00~0xff</span></span><br><span class="line"></span><br><span class="line">WriteCmd(<span class="number">0xa1</span>); <span class="comment">//--set segment re-map 0 to 127    设置段重映射</span></span><br><span class="line">               <span class="comment">//此指令用于改变屏幕数据列地址和段驱动器间的映射关系, 这增强和OLED模块设计的可伸缩性。此命令只影响其后的数据输入, 已存储在                  GDDRAM中的数据将保持不变。</span></span><br><span class="line">WriteCmd(<span class="number">0xa6</span>); <span class="comment">//设置正常显示</span></span><br><span class="line">WriteCmd(<span class="number">0xa8</span>); <span class="comment">//设置多路复用比率（1到64）</span></span><br><span class="line">WriteCmd(<span class="number">0x3F</span>); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">WriteCmd(<span class="number">0xa4</span>); <span class="comment">//0xa4，输出跟随RAM内容；0xa5，输出忽略RAM内容。命令A4h启用输出GDDRAM中的数据。如果命令A5h已被调用, 通过A4h指令, 可以将屏                    幕显示从全屏点亮状态中恢复。命令A5h通过忽略GDDRAM中的数据以点亮全屏</span></span><br><span class="line"></span><br><span class="line">WriteCmd(<span class="number">0xd3</span>); <span class="comment">//设置显示偏移</span></span><br><span class="line">WriteCmd(<span class="number">0x00</span>); <span class="comment">//不偏移</span></span><br><span class="line"></span><br><span class="line">WriteCmd(<span class="number">0xd5</span>); <span class="comment">//设置显示时钟分频比/振荡器频率</span></span><br><span class="line">WriteCmd(<span class="number">0xf0</span>); <span class="comment">//设置分割比</span></span><br><span class="line"></span><br><span class="line">WriteCmd(<span class="number">0xd9</span>); <span class="comment">//设置预充电周期</span></span><br><span class="line">WriteCmd(<span class="number">0x22</span>); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">WriteCmd(<span class="number">0xda</span>); <span class="comment">//设置com引脚硬件配置</span></span><br><span class="line">WriteCmd(<span class="number">0x12</span>);</span><br><span class="line"></span><br><span class="line">WriteCmd(<span class="number">0xdb</span>); <span class="comment">//set vcomh。设置VCOMH反压值</span></span><br><span class="line">WriteCmd(<span class="number">0x20</span>); <span class="comment">//0x20,0.77xVcc</span></span><br><span class="line"></span><br><span class="line">WriteCmd(<span class="number">0x8d</span>); <span class="comment">//设置DC-DC启用，设置电荷泵</span></span><br><span class="line">WriteCmd(<span class="number">0x14</span>); <span class="comment">//0x14开启电荷泵 0x10 关闭电荷泵</span></span><br><span class="line"></span><br><span class="line">WriteCmd(<span class="number">0xaf</span>); <span class="comment">//打开oled面板 OLED唤醒</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//示例代码</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_SetPos</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y)</span> <span class="comment">//设置起始点坐标</span></span><br><span class="line">&#123; </span><br><span class="line">    WriteCmd(<span class="number">0xb0</span>+y);<span class="comment">//相当于设置从哪一行开始</span></span><br><span class="line">    <span class="comment">//设置从哪一列开始</span></span><br><span class="line">    WriteCmd(((x&amp;<span class="number">0xf0</span>)&gt;&gt;<span class="number">4</span>)|<span class="number">0x10</span>);<span class="comment">//设置列起始地址高位</span></span><br><span class="line">    WriteCmd((x&amp;<span class="number">0x0f</span>)|<span class="number">0x01</span>);<span class="comment">//设置列起始地址低位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_Fill</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> fill_Data)</span><span class="comment">//全屏填充</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> m,n;</span><br><span class="line">    <span class="keyword">for</span>(m=<span class="number">0</span>;m&lt;<span class="number">8</span>;m++)</span><br><span class="line">    &#123;</span><br><span class="line">        WriteCmd(<span class="number">0xb0</span>+m);    <span class="comment">//page0-page1</span></span><br><span class="line">        WriteCmd(<span class="number">0x00</span>);        <span class="comment">//low column start address</span></span><br><span class="line">        WriteCmd(<span class="number">0x10</span>);        <span class="comment">//high column start address</span></span><br><span class="line">        <span class="keyword">for</span>(n=<span class="number">0</span>;n&lt;<span class="number">128</span>;n++)</span><br><span class="line">        &#123;</span><br><span class="line">            WriteDat(fill_Data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parameters     : x,y -- 起始点坐标(x:0~127, y:0~7); ch[] -- 要显示的字符串; TextSize -- 字符大小(1:6*8 ; 2:8*16)</span></span><br><span class="line"><span class="comment">// Description    : 显示codetab.h中的ASCII字符,有6*8和8*16可选择</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowStr</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y, <span class="type">unsigned</span> <span class="type">char</span> ch[], <span class="type">unsigned</span> <span class="type">char</span> TextSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c = <span class="number">0</span>,i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span>(TextSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(ch[j] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                c = ch[j] - <span class="number">32</span>;<span class="comment">//ascii码值-32 算出对应的索引</span></span><br><span class="line">                <span class="keyword">if</span>(x &gt; <span class="number">126</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    x = <span class="number">0</span>;</span><br><span class="line">                    y++;</span><br><span class="line">                &#125;</span><br><span class="line">                OLED_SetPos(x,y);</span><br><span class="line">                <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">                    WriteDat(F6x8[c][i]);</span><br><span class="line">                x += <span class="number">6</span>;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(ch[j] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                c = ch[j] - <span class="number">32</span>;</span><br><span class="line">                <span class="keyword">if</span>(x &gt; <span class="number">120</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    x = <span class="number">0</span>;</span><br><span class="line">                    y++;</span><br><span class="line">                &#125;</span><br><span class="line">                OLED_SetPos(x,y);</span><br><span class="line">                <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">                    WriteDat(F8X16[c*<span class="number">16</span>+i]);</span><br><span class="line">                OLED_SetPos(x,y+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">                    WriteDat(F8X16[c*<span class="number">16</span>+i+<span class="number">8</span>]);</span><br><span class="line">                x += <span class="number">8</span>;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parameters     : x,y -- 起始点坐标(x:0~127, y:0~7); N:汉字在codetab.h中的索引</span></span><br><span class="line"><span class="comment">// Description    : 显示codetab.h中的汉字,16*16点阵</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_ShowCN</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x, <span class="type">unsigned</span> <span class="type">char</span> y, <span class="type">unsigned</span> <span class="type">char</span> N)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> wm=<span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  adder=<span class="number">32</span>*N;</span><br><span class="line">    OLED_SetPos(x , y);</span><br><span class="line">    <span class="keyword">for</span>(wm = <span class="number">0</span>;wm &lt; <span class="number">16</span>;wm++)</span><br><span class="line">    &#123;</span><br><span class="line">        WriteDat(F16x16[adder]);</span><br><span class="line">        adder += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    OLED_SetPos(x,y + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(wm = <span class="number">0</span>;wm &lt; <span class="number">16</span>;wm++)</span><br><span class="line">    &#123;</span><br><span class="line">        WriteDat(F16x16[adder]);</span><br><span class="line">        adder += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parameters     : x0,y0 -- 起始点坐标(x0:0~127, y0:0~7); x1,y1 -- 起点对角线(结束点)的坐标(x1:1~128,y1:1~8)</span></span><br><span class="line"><span class="comment">// Description    : 显示BMP位图</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OLED_DrawBMP</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> x0,<span class="type">unsigned</span> <span class="type">char</span> y0,<span class="type">unsigned</span> <span class="type">char</span> x1,<span class="type">unsigned</span> <span class="type">char</span> y1,<span class="type">unsigned</span> <span class="type">char</span> BMP[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> x,y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(y1%<span class="number">8</span>==<span class="number">0</span>)</span><br><span class="line">        y = y1/<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y = y1/<span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(y=y0;y&lt;y1;y++)</span><br><span class="line">    &#123;</span><br><span class="line">        OLED_SetPos(x0,y);</span><br><span class="line">        <span class="keyword">for</span>(x=x0;x&lt;x1;x++)</span><br><span class="line">        &#123;</span><br><span class="line">            WriteDat(BMP[j++]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>取模软件的设置参考</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201129213444.png" alt="image-20201122202115798"></p>
]]></content>
      <categories>
        <category>板级通信协议</category>
      </categories>
      <tags>
        <tag>IIC</tag>
      </tags>
  </entry>
  <entry>
    <title>SPI介绍</title>
    <url>/2025/prefix%20remember%20to%20change!!!-ab00c8087bd4/</url>
    <content><![CDATA[<h1 id="什么是SPI"><a href="#什么是SPI" class="headerlink" title="什么是SPI"></a>什么是SPI</h1><p>SPI 是英语Serial Peripheral interface的缩写，顾名思义就是串行外围设备接口，是一种用于芯片通信的同步串行通信接口规范，是Motorola首先在其MC68HCXX系列处理器上定义的。</p>
<p>SPI，是一种<strong>高速的，全双工，同步</strong>的通信总线，并且在芯片的管脚上只占用<strong>四根线</strong>，节约了芯片的管脚，同时为PCB的布局上节省空间，提供方便。</p>
<p>SPI 接口主要应用在 EEPROM，FLASH，实时时钟，AD转换器，还有数字信号处理器和数字信号解码器之间。（M4高达37.5Mbps，不过很多外围设备往往只支持高达10Mbps，极少部分的设备能够超过10Mbps，例如W25Q128）</p>
<p>SPI设备之间使用全双工（一个信号线输入，一根信号线输出）模式通信，是一个主机和一个或多个从机的主从模式。主机负责初始化帧，这个数据传输帧可以用于读与写两种操作，片选线路可以从多个从机选择一个来响应主机的请求。</p>
<h2 id="SPI信号线"><a href="#SPI信号线" class="headerlink" title="SPI信号线"></a>SPI信号线</h2><ol>
<li>MOSI –》SPI总线主机输出&#x2F; 从机输入（SPI Bus Master Output&#x2F;Slave Input）；</li>
<li>MISO –》SPI总线主机输入&#x2F; 从机输出（SPI Bus Master Input&#x2F;Slave Output)；</li>
<li>SCLK –》串行时钟信号，由主设备产生；</li>
<li>CS –》从设备使能信号，由主设备控制（Chip select），有的IC此pin脚叫SS。低电平使能，选中这个芯片工作。</li>
</ol>
<p>对于多个从设备，每个从设备都需要一个独立的<strong>SS</strong>信号。大多数从属设备具有三态逻辑的特性，所以当器件未被选中时，它们的MISO信号变为高阻抗（逻辑断开）。没有三态输出的器件不能与其他器件共享SPI总线段，但是可以使用外接的三态逻辑缓存来解决这个问题。</p>
<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193109.png" alt="image-20200822202234453" style="zoom: 67%;" />

<p>SPI片选使能问题：<a href="https://bbs.csdn.net/topics/330225479">spi片选使能问题？？？-CSDN社区</a></p>
<h1 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h1><p>为了开始通信，总线上的主设备需要使用从设备支持的频率来配置时钟，这个频率最高为几兆赫兹左右。然后主设备将某根连接到从设备SS的线上的信号置为0来选中这个从设备。如果等待时间是必要的话（例如进行模数转换），主设备必须等待满这段时间之后，才可以发出时钟周期信号。</p>
<p>在每个SPI时钟周期内，都会发生全双工数据传输。主设备在MOSI线上发送一个位，从设备读取它，同时从机在MISO线上发送一位数据，主机读取它。即使只有单向数据传输的目的，主从机之间的通信工作方式仍然是双工的。</p>
<p>传输通常会使用给定字长的两个移位寄存器(通常包含8位)，一个在主设备中，一个在从设备中，它们之间的连接方式形成了一个虚拟的环形拓朴结构。数据通常先从最高位移出，在时钟信号边沿，主机和从机均移出一位，然后在传输线上输出给对方。在下一个时钟沿，每个接收器都从传输线接受对方发出的数据位，并且从移位寄存器的最低位推入。每完成这样一个移出推入的周期后，主机和从机就交换寄存器中的一位数据。当所有数据位都经过了这样的移出推入过程后，主机和从机就完成了寄存器上的数据交换。如果需要交换的数据比寄存器的位数还要长的话，则需要重新加载移位寄存器并重复该过程。传输可能会持续任意数量的时钟周期。传输完成后，主设备会停止发送时钟信号，并通常会取消选择从设备。</p>
<h2 id="SPI接口框图"><a href="#SPI接口框图" class="headerlink" title="SPI接口框图"></a>SPI接口框图</h2><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193120.png" alt="image-20200822204706092" style="zoom:67%;" />

<h2 id="数据帧格式"><a href="#数据帧格式" class="headerlink" title="数据帧格式"></a>数据帧格式</h2><p>移出数据时 MSB 在前还是 LSB 在前取决于 SPI_CR1 寄存器中 LSBFIRST 位的值。每个数据帧的长度均为 8 位或 16 位，具体取决于使用 SPI_CR1 寄存器中的 DFF 位。</p>
<p>注：所选的数据帧格式适用于发送和&#x2F;或接收。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193130.png" alt="image-20200822204746456"></p>
<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193145.png" alt="image-20200822205207927" style="zoom: 80%;" />

<h2 id="时钟相位和时钟极性"><a href="#时钟相位和时钟极性" class="headerlink" title="时钟相位和时钟极性"></a>时钟相位和时钟极性</h2><p>通过 SPI_CR1 寄存器中的 CPOL 和 CPHA 位的排列组合，可以用软件选择四种可能的时序关系，用于选择数据捕获时钟边沿。其中，使用的最为广泛的是<strong>模式0</strong>（00）和<strong>模式3</strong>方式。</p>
<p><strong>时钟极性</strong></p>
<p>CPOL（时钟极性）位控制不传任何数据时的时钟电平状态，此位对主器件和从器件都有作用。如果复位 CPOL， SCK 引脚在空闲状态处于低电平；如果将 CPOL 置 1， SCK 引脚在空闲状态处于高电平。</p>
<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193153.png" alt="image-20200822210149794" style="zoom: 80%;" />

<p><strong>时钟相位</strong></p>
<p>如果将 CPHA（时钟相位）位置 1，则 SCK 引脚上的第二个边沿对 MSBit 采样（如果将 CPOL 位复位，则为下降沿；如果将 CPOL 位置 1，则为上升沿）。即，在第二个时钟边沿锁存数据。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193200.png" alt="image-20200822210534709"></p>
<p>如果将 CPHA 位复位，则 SCK 引脚上的第一个边沿对 MSBit 采样（如果将 CPOL 位置 1，则为下降沿；如果复位 CPOL 位，则为上升沿）。即，在第一个时钟边沿锁存数据。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193207.png" alt="image-20200822210653432"></p>
<h2 id="SPI工作原理总结"><a href="#SPI工作原理总结" class="headerlink" title="SPI工作原理总结"></a>SPI工作原理总结</h2><ul>
<li>硬件上为4根线。</li>
<li>主机和从机都有一个串行移位寄存器，主机通过向它的SPI串行寄存器写入一个字节来发起一次传输。</li>
<li>串行移位寄存器通过MOSI信号线将字节传送给从机，从机也将自己的串行移位寄存器中的内容通过MISO信号线返回给主机。这样，两个移位寄存器中的内容就被交换。</li>
<li>外设的写操作和读操作是同步完成的。如果只进行写操作，主机只需忽略接收到的字节；反之，若主机要读取从机的一个字节，就必须发送一个空字节（任意字节）来引发从机的传输。</li>
</ul>
<h2 id="SPI配置流程"><a href="#SPI配置流程" class="headerlink" title="SPI配置流程"></a>SPI配置流程</h2><p>添加支持spi的<strong>库函数</strong>文件：<code>stm32f4xx_spi.c</code></p>
<ol>
<li><p>理解电路原理图</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CS -- PB14(普通输出功能)</span><br><span class="line">SCK -- PB3(复用SPI1)</span><br><span class="line">MOSI -- PB5(复用SPI1)</span><br><span class="line">MISO -- PB4(复用SPI1)</span><br></pre></td></tr></table></figure>

<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193214.png" alt="image-20200822211224230" style="zoom:80%;" />
</li>
<li><p>使能SPIx和IO口时钟</p>
<p>RCC_AHBxPeriphClockCmd();</p>
</li>
<li><p>初始化IO口为复用功能</p>
<p>void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);</p>
</li>
<li><p>设置引脚复用映射</p>
<p>GPIO_PinAFConfig();</p>
</li>
<li><p>初始化SPIx,设置SPIx工作模式</p>
<p>void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct);</p>
</li>
<li><p>使能SPIx</p>
<p>void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState);</p>
</li>
<li><p>SPI传输数据</p>
<p>void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data);</p>
<p>uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx);</p>
</li>
<li><p>查看SPI传输状态</p>
<p>SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_RXNE);</p>
<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193224.png" alt="image-20200822212432868" style="zoom:80%;" /></li>
</ol>
<h3 id="库函数配置SPI示例代码"><a href="#库函数配置SPI示例代码" class="headerlink" title="库函数配置SPI示例代码"></a>库函数配置SPI示例代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SpiFlash_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">    SPI_InitTypeDef  SPI_InitStruct;</span><br><span class="line">    <span class="comment">//1. 使能SPIx和IO口时钟</span></span><br><span class="line">    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB,ENABLE);</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1,ENABLE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 初始化IO口为复用功能</span></span><br><span class="line">    GPIO_InitStruct.GPIO_Pin     = GPIO_Pin_3 | GPIO_Pin_4| GPIO_Pin_5;     <span class="comment">//GPIOB 3 4 5为复用 </span></span><br><span class="line">    GPIO_InitStruct.GPIO_Mode     = GPIO_Mode_AF;                        <span class="comment">//配置IO口复用功能</span></span><br><span class="line">    GPIO_InitStruct.GPIO_Speed     = GPIO_Speed_50MHz;                     <span class="comment">//速度 50MHz</span></span><br><span class="line">    GPIO_InitStruct.GPIO_OType     = GPIO_OType_PP;                     <span class="comment">//推挽复用输出</span></span><br><span class="line">    GPIO_InitStruct.GPIO_PuPd     = GPIO_PuPd_UP;                         <span class="comment">//上拉</span></span><br><span class="line">    GPIO_Init(GPIOB,&amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">    GPIO_InitStruct.GPIO_Pin      = GPIO_Pin_14;                 <span class="comment">//配置CS为普通输出端口</span></span><br><span class="line">    GPIO_InitStruct.GPIO_Mode     = GPIO_Mode_OUT;            <span class="comment">//推挽输出</span></span><br><span class="line">    GPIO_InitStruct.GPIO_Speed     = GPIO_Speed_50MHz;         <span class="comment">//速度 50MHz</span></span><br><span class="line">    GPIO_InitStruct.GPIO_OType     = GPIO_OType_PP;             <span class="comment">//推挽复用输出</span></span><br><span class="line">    GPIO_InitStruct.GPIO_PuPd     = GPIO_PuPd_UP;             <span class="comment">//上拉</span></span><br><span class="line">    GPIO_Init(GPIOB,&amp;GPIO_InitStruct);    </span><br><span class="line">    <span class="comment">//3. 设置引脚复用映射</span></span><br><span class="line">    GPIO_PinAFConfig(GPIOB,GPIO_PinSource3,GPIO_AF_SPI1);</span><br><span class="line">    GPIO_PinAFConfig(GPIOB,GPIO_PinSource4,GPIO_AF_SPI1);</span><br><span class="line">    GPIO_PinAFConfig(GPIOB,GPIO_PinSource5,GPIO_AF_SPI1);</span><br><span class="line"></span><br><span class="line">    SPI_InitStruct.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_128;         <span class="comment">//分频</span></span><br><span class="line">    SPI_InitStruct.SPI_CPOL                 = SPI_CPOL_Low;                      <span class="comment">//时钟极性为低电平 ，低电平空闲</span></span><br><span class="line">    SPI_InitStruct.SPI_CPHA                 = SPI_CPHA_1Edge;                  <span class="comment">//时钟相位 第一边沿发送数据 </span></span><br><span class="line">    SPI_InitStruct.SPI_DataSize             = SPI_DataSize_8b;                 <span class="comment">//八位数据</span></span><br><span class="line">    SPI_InitStruct.SPI_Direction         = SPI_Direction_2Lines_FullDuplex; <span class="comment">//全双工</span></span><br><span class="line">    SPI_InitStruct.SPI_FirstBit             = SPI_FirstBit_MSB;                 <span class="comment">//高位在前</span></span><br><span class="line">    SPI_InitStruct.SPI_Mode                 = SPI_Mode_Master ;                <span class="comment">//主机模式</span></span><br><span class="line">    SPI_InitStruct.SPI_NSS                 = SPI_NSS_Soft;                    <span class="comment">//软件控制CS</span></span><br><span class="line">    SPI_InitStruct.SPI_CRCPolynomial     = <span class="number">7</span>;                                  <span class="comment">//校验位</span></span><br><span class="line">    <span class="comment">//4. 初始化SPIx,设置SPIx工作模式</span></span><br><span class="line">    SPI_Init(SPI1, &amp;SPI_InitStruct);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 使能SPI1</span></span><br><span class="line">    SPI_Cmd(SPI1,ENABLE);</span><br><span class="line"></span><br><span class="line">    F_CS = <span class="number">1</span>;  <span class="comment">//不使能芯片        </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送数据即可接收数据</span></span><br><span class="line">u8 <span class="title function_">Spi_Send_Byte</span><span class="params">(u8 data)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 rx_data;    <span class="comment">//定义变量接收数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断发送缓冲是否为空</span></span><br><span class="line">    <span class="keyword">while</span>(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);</span><br><span class="line">    SPI_I2S_SendData(SPI1, data);  <span class="comment">//发送数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断接收缓冲是否为非空</span></span><br><span class="line">    <span class="keyword">while</span>(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);</span><br><span class="line">    rx_data = SPI_I2S_ReceiveData(SPI1) ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rx_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="FLASH"><a href="#FLASH" class="headerlink" title="FLASH"></a>FLASH</h1><p>Flash存储器属于内存器件的一种，是一种非易失性（ Non-Volatile ）内存。可以对称为块的存储器单元块进行擦写和再编程。任何flash器件的写入操作只能在空或已擦除的单元内进行，所以大多数情况下，在进行写入操作之前必须先执行擦除。</p>
<p><strong>快闪存储器</strong>（英语：<strong>flash memory</strong>），是一种电子式可清除程序化只读存储器的形式，允许在操作中被多次擦或写的存储器。这种科技主要用于一般性资料存储，以及在电脑与其他数字产品间交换传输资料，如储存卡与U盘。闪存是一种特殊的、以宏块抹写的EEPROM。早期的闪存进行一次抹除，就会清除掉整颗芯片上的资料。闪存的写入速度往往明显慢于读取速度。</p>
<p>闪存的一种限制在于即使它可以单一字节的方式读或写入，但是抹除一定是一整个区块。一般来说都是设置某一区中的所有比特为“1”，刚开始区块内的所有部分都可以写入，然而当有任何一个比特被设为“0”时，就只能借由清除整个区块来恢复“1”的状态。换句话说闪存（特别是NOR Flash）能提供随机读取与写入操作，却无法提供任意的随机改写。</p>
<p>不过闪存的区块可以写入与既存的“0”值一样长的消息。例如：有一小区块的值已抹除为1111，然后写入1110的消息。接下来这个区块还可以依序写入1010、0010，最后则是0000。可是实际上少有算法可以从这种连续写入兼容性得到好处，一般来说还是整块抹除再重写。</p>
<h2 id="W25Q128"><a href="#W25Q128" class="headerlink" title="W25Q128"></a>W25Q128</h2><p>W25Q128将<strong>16M</strong>的容量分为256个块(Block)，每个块大小为64K字节，每个块又分为16个扇区(Sector)，每个扇区4K个字节。<strong>W25Q128 的最小擦除单位为一个扇区，也就是每次必须擦除4K个字节</strong>。这样我们需要给W25Q128开辟一个至少4K的缓存区，这样对SRAM要求比较高，要求芯片必须有4K以上SRAM才能很好的操作。</p>
<p>W25Q128的擦写周期多达10W次，具有20年的数据保存期限，支持电压为2.7~3.6V，W25Q128支持标准的SPI，还支持双输出&#x2F;四输出的SPI，最大SPI时钟可以到80Mhz (双输出时相当于160Mhz， 四输出时相当于320M)，更多的W25Q128的介绍，请参考W25Q128的datasheet。</p>
<p><strong>STM32F407ZET6的RAM主要由内部SRAM1(112KB) + 辅助内部 SRAM2 (16 KB) + 辅助内部 SRAM3 (64 KB)(CCM数据RAM)三部分组成。注：CCM只可以CPU访问，SRAM的话CPU和DMA等外设都可以访问。</strong></p>
<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193241.png" alt="image-20200913225155113" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193247.png" alt="image-20200822214330220" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193253.png" alt="image-20200822214728768" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193257.png" alt="image-20200822215846787" style="zoom:80%;" />

<p><strong>读取制造商&#x2F;设备ID（90h）</strong><br>“读取制造商&#x2F;设备ID”指令是“掉电&#x2F;设备ID释放”指令的替代方法，该指令同时提供JEDEC分配的制造商ID和特定的设备ID。</p>
<p>读取制造商&#x2F;设备ID指令与关机&#x2F;设备ID释放指令非常相似。通过将&#x2F;CS引脚驱动为低电平并转移指令代码“ 90h”，后跟000000h的24位地址（A23-A0），可以启动指令。之后，制造商ID（EFh）和设备ID在CLK的下降沿移出，<strong>最高有效位（MSB）首先出现</strong>，如图29所示。</p>
<p>W25Q128的设备ID值在制造商和设备标识表中列出。如果24位地址最初设置为000001h，则将首先读取设备ID，然后再读取制造商ID。</p>
<p>可以连续读取制造商和设备ID，彼此交替读取。 最后，通过将&#x2F;CS拉高来完成指令。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193308.png" alt="image-20200822220659066"></p>
<p><strong>写使能（06h）</strong><br>写使能指令将状态寄存器中的写使能锁存器（WEL）位置1。必须在扇区擦除，块擦除，芯片擦除，写入状态寄存器和擦除&#x2F;程序安全寄存器指令之前将WEL位置1。</p>
<p>通过将&#x2F;CS驱动为低电平，在CLK的上升沿将指令代码“ 06h”移入数据输入（DI）引脚，然后将&#x2F;CS驱动为高电平，即可输入WriteEnable指令。</p>
<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193315.png" alt="image-20200822221300060" style="zoom:80%;" />

<p><strong>读取状态寄存器1（05h）和读取状态寄存器2（35h）</strong><br>读取状态寄存器指令允许读取8位状态寄存器。通过将&#x2F;CS驱动为低电平，并在CLK的上升沿将状态寄存器1的指令代码“ 05h”或状态寄存器2的指令“ 35h”移入DI引脚来输入指令。然后，状态寄存器位在CLK下降沿的DO引脚上移出，最高有效位（MSB）首先移出，如图所示。</p>
<p>读取状态寄存器指令可在任何时候使用，即使在擦除或写入状态寄存器周期正在进行。这样可以检查<code>BUSY</code>状态位，以确定周期何时完成，以及器件是否可以接受另一条指令。</p>
<p>状态寄存器可以连续读取。通过将&#x2F;CS拉高来完成指令。</p>
<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193329.png" alt="image-20200822221929951" style="zoom: 80%;" />

<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193336.png" alt="image-20200822222944057" style="zoom:67%;" />

<p><strong>扇区擦除（20h）</strong><br>扇区擦除指令将指定扇区（4K字节）内的所有内存设置为全1（FFh）的擦除状态。在器件接受扇区擦除指令之前，必须先执行写使能指令（状态寄存器位WEL必须等于1）。通过将&#x2F;CS引脚驱动为低电平并将指令代码“ 20h”移至24位扇区地址（A23-A0），可以启动指令。</p>
<p>在最后一个字节的第八位被锁存后，必须将&#x2F;CS引脚驱动为高电平。 如果不这样做，将不执行扇区擦除指令。&#x2F;CS被驱动为高电平后，自定时扇区擦除指令将在<code>tSE</code>的持续时间内开始。</p>
<p>在扇区擦除周期进行期间，仍可以访问读取状态寄存器指令以检查<code>BUSY</code>位的状态。 在扇区擦除周期中，<code>BUSY</code>位为1；在周期结束且设备准备好再次接受其他指令时，<code>BUSY</code>位为0。扇区擦除周期结束后，状态寄存器中的写使能锁存（WEL）位被清除为0。</p>
<p>如果寻址的页面受块保护，则将不执行扇区擦除指令。</p>
<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193342.png" alt="image-20200822222910408" style="zoom:80%;" />

<p><strong>Page Program (02h)</strong></p>
<p>页面编程指令允许从一个字节到256字节（一页）的数据在先前擦除（FFh）的存储位置进行编程。在设备将接受页面编程指令（状态寄存器位WEL &#x3D; 1）之前，必须执行写使能指令。通过将&#x2F;CS引脚驱动为低电平，然后将指令代码“ 02h”紧随其后的是24位地址（A23-A0）和至少一个数据字节，移入DI引脚来启动指令。在将数据发送到设备时，&#x2F;CS引脚在整个指令期间必须保持低电平。</p>
<p>如果要对整个256字节页面进行编程，则最后一个地址字节（8个最低有效地址位）应设置为0。如果最后一个地址字节不为零，并且时钟数超过了剩余的页面长度，则寻址将换行到页面的开头。在某些情况下，可以编程少于256个字节（部分页），而不会影响同一页中的其他字节。执行部分页面编程的条件之一是时钟数不能超过剩余页面长度。如果发送给设备的字节数超过256个，则寻址将环绕到页面的开头，并覆盖先前发送的数据。</p>
<p>与写和擦除指令一样，必须将最后一个字节的第八位锁存后，将&#x2F;CS引脚驱动为高电平。如果不这样做，将不会执行页面编程指令。&#x2F;CS驱动为高电平后，自定时页面编程指令将开始持续<code>tpp</code>时间。</p>
<p>在页面编程周期进行期间，仍可以访问读取状态寄存器指令以检查<code>BUSY</code>位的状态。在页面编程周期中，<code>BUSY</code>位为1；在周期结束且设备准备好再次接受其他指令时，<code>BUSY</code>位为0。页面编程周期完成后，状态寄存器中的写使能锁存（WEL）位被清除为0。</p>
<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193347.png" alt="image-20200822223902567" style="zoom:80%;" />

<p><strong>读取数据（03h）</strong><br>读取数据指令允许从存储器中顺序读取一个或多个数据字节。通过将&#x2F;CS引脚驱动为低电平，然后将指令代码“ 03h”和随后的24位地址（A23-A0）移入DI引脚，可以启动指令。代码和地址位锁存在CLK引脚的上升沿。接收到地址后，寻址存储单元的数据字节将在CLK的下降沿的DO引脚上移出，最高有效位（MSB）在前。每个数据字节移出后，地址将自动递增到下一个更高的地址，从而允许连续的数据流。这意味着只要时钟继续，就可以用一条指令访问整个存储器。 通过将&#x2F;CS拉高来完成指令。读数据指令序列如图所示。</p>
<p>如果在执行擦除，编程或写周期（BUSY &#x3D; 1）时发出了读数据指令，则该指令将被忽略，并且不会对当前周期产生任何影响。</p>
<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193353.png" alt="image-20200822225006898" style="zoom: 67%;" />

<h3 id="模拟SPI示例代码"><a href="#模拟SPI示例代码" class="headerlink" title="模拟SPI示例代码"></a>模拟SPI示例代码</h3><p>在有些情况下没有硬件SPI的支持，只能通过IO口来模拟SPI时序，参考代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> F_CS     PBout(14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCK     PBout(3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MISO    PBin(4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOSI    PBout(5)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SpiFlash_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIO_InitTypeDef GPIO_InitStruct;</span><br><span class="line">    <span class="comment">//使能IO口时钟</span></span><br><span class="line">    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB,ENABLE);</span><br><span class="line"></span><br><span class="line">    GPIO_InitStruct.GPIO_Pin     = GPIO_Pin_3 | GPIO_Pin_14 | GPIO_Pin_5;     <span class="comment">//GPIOB 3 14 5</span></span><br><span class="line">    GPIO_InitStruct.GPIO_Mode     = GPIO_Mode_OUT;                        <span class="comment">//配置IO口输出</span></span><br><span class="line">    GPIO_InitStruct.GPIO_Speed     = GPIO_Speed_50MHz;                     <span class="comment">//速度 50MHz</span></span><br><span class="line">    GPIO_InitStruct.GPIO_OType     = GPIO_OType_PP;                         <span class="comment">//推挽复用输出</span></span><br><span class="line">    GPIO_InitStruct.GPIO_PuPd     = GPIO_PuPd_UP;                         <span class="comment">//上拉</span></span><br><span class="line">    GPIO_Init(GPIOB,&amp;GPIO_InitStruct);</span><br><span class="line"></span><br><span class="line">    GPIO_InitStruct.GPIO_Pin      = GPIO_Pin_4;</span><br><span class="line">    GPIO_InitStruct.GPIO_Mode     = GPIO_Mode_IN;</span><br><span class="line">    GPIO_InitStruct.GPIO_PuPd     = GPIO_PuPd_UP;</span><br><span class="line">    GPIO_Init(GPIOB,&amp;GPIO_InitStruct);    </span><br><span class="line"></span><br><span class="line">    F_CS = <span class="number">1</span>;  <span class="comment">//不使能芯片        </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送数据即可接收数据</span></span><br><span class="line">u8 <span class="title function_">Spi_Send_Byte</span><span class="params">(u8 data)</span> <span class="comment">//data = 0x87 1000 0111</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 i, rx_data = <span class="number">0x00</span>;    <span class="comment">//定义变量接收数据 0 0 0 0 0 0 0 0</span></span><br><span class="line"></span><br><span class="line">    SCK = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//准备数据</span></span><br><span class="line">        <span class="keyword">if</span>(data &amp; (<span class="number">1</span>&lt;&lt;(<span class="number">7</span>-i)))</span><br><span class="line">        &#123;</span><br><span class="line">            MOSI = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            MOSI = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        delay_us(<span class="number">2</span>);</span><br><span class="line">        SCK = <span class="number">1</span>;</span><br><span class="line">        delay_us(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//接受数据，SCK变为低电平之前</span></span><br><span class="line">        <span class="keyword">if</span>(MISO == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rx_data |= (<span class="number">1</span>&lt;&lt;(<span class="number">7</span>-i));</span><br><span class="line">        &#125;    </span><br><span class="line">        SCK = <span class="number">0</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rx_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u16 <span class="title function_">W25q128_Id</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u16 id;</span><br><span class="line">    F_CS = <span class="number">0</span>;  <span class="comment">//使能芯片        </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送读ID命令</span></span><br><span class="line">    Spi_Send_Byte(<span class="number">0x90</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发地址</span></span><br><span class="line">    Spi_Send_Byte(<span class="number">0x00</span>);</span><br><span class="line">    Spi_Send_Byte(<span class="number">0x00</span>);</span><br><span class="line">    Spi_Send_Byte(<span class="number">0x00</span>);</span><br><span class="line"></span><br><span class="line">    id |= Spi_Send_Byte(<span class="number">0xFF</span>)&lt;&lt;<span class="number">8</span>;     <span class="comment">//生产商ID</span></span><br><span class="line">    id |= Spi_Send_Byte(<span class="number">0xFF</span>);        <span class="comment">//设备ID</span></span><br><span class="line"></span><br><span class="line">    F_CS = <span class="number">1</span>;  <span class="comment">//不使能芯片    </span></span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Write_Enable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    F_CS = <span class="number">0</span>;  <span class="comment">//使能芯片    </span></span><br><span class="line">    <span class="comment">//发送写使能命令</span></span><br><span class="line">    Spi_Send_Byte(<span class="number">0x06</span>);</span><br><span class="line">    F_CS = <span class="number">1</span>;  <span class="comment">//不使能芯片</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读状态寄存器1</span></span><br><span class="line">u8 <span class="title function_">W25Q128_Read_status1</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    u8 status1;</span><br><span class="line">    F_CS = <span class="number">0</span>;  <span class="comment">//使能芯片</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送命令</span></span><br><span class="line">    Spi_Send_Byte(<span class="number">0x05</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送任意字节</span></span><br><span class="line">    status1 = Spi_Send_Byte(<span class="number">0xFF</span>); </span><br><span class="line"></span><br><span class="line">    F_CS = <span class="number">1</span>;  <span class="comment">//不使能芯片</span></span><br><span class="line">    <span class="keyword">return</span> status1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q128_Erase_Sector</span><span class="params">(u32 addr)</span> <span class="comment">//0x01BF01</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="comment">//写使能</span></span><br><span class="line">    Write_Enable();</span><br><span class="line"></span><br><span class="line">    F_CS = <span class="number">0</span>;  <span class="comment">//使能芯片</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送擦除命令</span></span><br><span class="line">    Spi_Send_Byte(<span class="number">0x20</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//拆分地址发送</span></span><br><span class="line">    Spi_Send_Byte((addr&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xFF</span>);</span><br><span class="line">    Spi_Send_Byte((addr&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xFF</span>);</span><br><span class="line">    Spi_Send_Byte(addr&amp;<span class="number">0xFF</span>);     </span><br><span class="line"></span><br><span class="line">    F_CS = <span class="number">1</span>;  <span class="comment">//不使能芯片</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否擦除完成</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断BUSY位是否为0</span></span><br><span class="line">        <span class="keyword">if</span>((W25Q128_Read_status1() &amp; <span class="number">0x01</span>) == <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q128_Writer_data</span><span class="params">(u32 addr,u8 *buf, u32 len)</span></span><br><span class="line">&#123;</span><br><span class="line">    Write_Enable();</span><br><span class="line">    <span class="comment">//芯片使能</span></span><br><span class="line">    F_CS = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//写页命令</span></span><br><span class="line">    Spi_Send_Byte(<span class="number">0x02</span>);</span><br><span class="line"></span><br><span class="line">    Spi_Send_Byte((addr&gt;&gt;<span class="number">16</span>) &amp;<span class="number">0xFF</span>);</span><br><span class="line">    Spi_Send_Byte((addr&gt;&gt;<span class="number">8</span>) &amp;<span class="number">0xFF</span>);</span><br><span class="line">    Spi_Send_Byte(addr&amp;<span class="number">0xFF</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写数据</span></span><br><span class="line">    <span class="keyword">while</span>(len--)</span><br><span class="line">    &#123;</span><br><span class="line">        Spi_Send_Byte(*buf);</span><br><span class="line">        buf++;</span><br><span class="line">    &#125;</span><br><span class="line">    F_CS = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否写完成</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((W25Q128_Read_status1() &amp; <span class="number">0x01</span>) == <span class="number">0</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q128_Read_data</span><span class="params">(u32 addr,u8 *buf, u32 len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//芯片使能</span></span><br><span class="line">    F_CS = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Spi_Send_Byte(<span class="number">0x03</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读数据地址</span></span><br><span class="line">    Spi_Send_Byte((addr&gt;&gt;<span class="number">16</span>) &amp;<span class="number">0xFF</span>);</span><br><span class="line">    Spi_Send_Byte((addr&gt;&gt;<span class="number">8</span>) &amp;<span class="number">0xFF</span>);</span><br><span class="line">    Spi_Send_Byte(addr&amp;<span class="number">0xFF</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读数据</span></span><br><span class="line">    <span class="keyword">while</span>(len--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//发送任意数据</span></span><br><span class="line">        *buf= Spi_Send_Byte(<span class="number">0xff</span>);</span><br><span class="line">        buf++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    F_CS = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="RFID"><a href="#RFID" class="headerlink" title="RFID"></a>RFID</h1><p><strong>ISO14443协议</strong></p>
<p>ISO14443协议是Contactless card standards (非接触式IC卡标准)协议。</p>
<p><strong>REQA和WAKE-UP帧(P13，18)</strong></p>
<p>请求和唤醒帧用来初始化通信并按以下次序组成：</p>
<p>通信开始。</p>
<ul>
<li><p>7个数据位发送</p>
</li>
<li><p>LSB首先发送</p>
</li>
<li><p>标准REQA的数据内容是0x26，WAKE UP请求的数据内容是0x52</p>
</li>
</ul>
<p>通信结束不加奇偶校验位。</p>
<p><strong>NVB</strong></p>
<p>整个数据包里的数据的个数。长度: 1字节。</p>
<ul>
<li><p>较高4位称为字节计数，指定所有有效数据位(包括被PCD发送的NVB和SEL，不包括CRC)的数目被8除后所得的整数。这样，字节计数的最小值是2而最大值是7。</p>
</li>
<li><p>较低4位称为比特计数，指定所有有效数据位(包括被PCD发送的NVB和SEL)的数目被8除后所得的余数。</p>
</li>
</ul>
<p>基于14443-A的操作帧格式</p>
<ul>
<li>请求卡: 0x26。返回两字节的卡类型</li>
<li>唤醒所有卡: 0x52。返回两字节的卡类型</li>
<li>防冲突: 0x93+0x20得到卡ID。返回四字节卡ID，一字节的校验（异或）</li>
<li>选择卡片: 0x93+0x70+4字节卡ID+1字节校验+2字节CRC16校验。返回卡校验0x08</li>
</ul>
<p><strong>RFID中间件的概念</strong></p>
<p>为解决分布异构问题，人们提出了中间件(middleware)的概念。中间件是位于平台(硬件和操作系统)和应用之间的通用服务（如：DNS，DHCP），这些服务具有标准的程序接口和协议。针对不同的操作系统和硬件平台，它们可以有符合接口和协议规范的多种实现。</p>
<p><strong>RFID微波2.4GHz频段的无线技术标准</strong></p>
<ul>
<li>ZigBee&#x2F;IEEE 802.15.4: ZigBee技术是一项新兴的短距离无线通信技术，主要面向的应用领域是低速率无线个人局域网(LRWPAN)，典型特征是近距离、低功耗、低成本、低传输速率，主要适用于自动控制以及远程控制领域，目的是为了满足小型廉价设备的无线联网和控制。</li>
<li>Wi-Fi&#x2F;IEEE 802.11b: Wi-Fi即无线局域网，工作在2.4GHz频段，用于学校、商业等办公区域的无线连接技术，传输速率可达11Mbit&#x2F;s，工作距离100m，采用直接序列扩频(DSSS) 的方式。采用Wi-Fi的主要推动因素是数据吞吐量，Wi-Fi-般用来将计算机与本地局域网相连或直接与互联网相连。</li>
</ul>
<p><strong>RC522概述</strong></p>
<p>MF RC522是应用于13.56MHz非接触式通信中，高集成度读写卡系列芯片中的一员。是NXP公司针对“三表”应用推出的一款低电压、低成本、体积小的非接触式读写卡芯片。</p>
<ul>
<li>读写器，支持ISO 14443A&#x2F; MIFARER</li>
<li>可实现各种不同主机接口的功能：SPI接口；串行UART(类似RS232,电压电平取决于提供的管脚电压)；I2C接口</li>
<li>64字节的发送和接收FIFO缓冲区。</li>
<li>内部振荡器，连接27.12MHz的晶体。</li>
</ul>
<p><strong>RC522寄存器</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CommandReg启动和停止命令的执行。</span><br><span class="line">ComIrqReg包含中断请求标志</span><br><span class="line">ErrorReg错误标志，指示执行的上个命令的错误状态</span><br><span class="line">Status2Reg包含接收器和发送器的状态标志</span><br><span class="line">FIFODtataReg <span class="number">64</span>字节FIFO缓冲区的输入和输出</span><br><span class="line">FIFOLevelReg指示FIFO中存储的字节数</span><br><span class="line">ControlReg不同的控制寄存器</span><br><span class="line">BitFramingReg面向位的帧的调节</span><br><span class="line">CollReg RF接口上检测到的第一个位冲突的位的位置</span><br><span class="line"></span><br><span class="line"><span class="comment">//spi地址字节按下面的格式传输。</span></span><br><span class="line"><span class="comment">//第一个字节的MSB位设置使用的模式。MSB位为1时从MFRC522读出数据;MSB位为0时将数据写入MFRC522。第一个字节的位6-1定义地址， 最后一位应当设置为0</span></span><br></pre></td></tr></table></figure>

<p><strong>FIFO缓冲区</strong></p>
<p>FIFO缓冲区的输入和输出数据总线连接到FIFODataReg寄存器。通过写FIFODataReg寄存器来将一个字节的数据存入FIFO缓冲区，之后内部FIFO缓冲区写指针加1。除了读写FIFO缓冲区外，FIFO 缓冲区指针还可通过置位寄存器FIFOLevelReg的FlushBuffer位来复位。从而，FIFOLevel 位被清零，寄存器ErrorReg的BufferOvfl位被清零，实际存储的字节不能再访问。已经存放在FIFO缓冲区中的字节数：可以查看寄存器FIFOLevelReg的FIFOLevel字段。</p>
<p><strong>RFID原理分析</strong>    </p>
<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193402.png" alt="image-20200915141638442" style="zoom:67%;" />

<h2 id="M1卡"><a href="#M1卡" class="headerlink" title="M1卡"></a>M1卡</h2><p>所谓的M1芯片，是指恩智浦出品的芯片缩写，全称为NXP Mifare1系列，常用的有<strong>S50及S70</strong>两种型号，属于非接触式IC卡。优点是可读可写的多功能卡，缺点是:价格稍贵，感应距离短，适合非定额消费系统、停车场系统、门禁考勤系统等。</p>
<p><strong>工作原理</strong></p>
<p>读写器向 M1 卡发一组固定频率的电磁波，卡片内有一个 LC 串联谐振电路，其频率与读写器发射的频率相同，在电磁波的激励下， LC 谐振电路产生共振，从而使电容内有了电荷，在这个电容的另一端，接有一个单向导通的电子泵，将电容内的电荷送到另一个电容内储存，当所积累的电荷达到 2V 时，此电容可做为电源为其它电路提供工作电压，将卡内数据发射出去或接取读写器的数据。  </p>
<p><strong>主要指标</strong></p>
<ul>
<li>容量为 8K 位 EEPROM（1KB）</li>
<li>分为 16 个扇区，每个扇区为 4 块，每块 16 个字节，以块为存取单位</li>
<li>每个扇区有独立的一组密码及访问控制</li>
<li>每张卡有唯一序列号，为 32 位</li>
<li>具有防冲突机制，支持多卡操作（可以同时读取多个电子标签）</li>
<li>无电源，自带天线（线圈），内含加密控制逻辑和通讯逻辑电路</li>
<li>工作频率： 13.56MHZ（高频）</li>
<li>通信速率： 106 KBPS</li>
</ul>
<p><strong>存储结构</strong></p>
<p>M1卡分为16个扇区，每个扇区由4块（块 0、块 1、块 2、块 3）组成，我们也将16个扇区的64个块按绝对地址编号为0~63，存贮结构如下图所示。</p>
<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193632.png" alt="image-20200829113220206" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193639.png" alt="image-20200829113441226" style="zoom:67%;" />

<p><strong>M1 射频卡与读写器的通讯</strong>  </p>
<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193645.png" alt="image-20200829113609029" style="zoom:67%;" />

<p><strong>复位应答（ Answer to request）</strong>：M1 射频卡的通讯协议和通讯波特率是定义好的，当有卡片进入读写器的操作范围时，读写器以特定的协议与它通讯，从而确定该卡是否为 M1 射频卡，即验证卡片的卡型。</p>
<p>**防冲突机制 (Anticollision Loop)**：当有多张卡进入读写器操作范围时，防冲突机制会从其中选择一张进行操作，未选中的则处于空闲模式等待下一次选卡，该过程会返回被选卡的序列号。</p>
<p>**选择卡片(Select Tag)**：选择被选中的卡的序列号，并同时返回卡的容量代码。</p>
<p>**三次互相确认(3 Pass Authentication)**：选定要处理的卡片之后，读写器就确定要访问的扇区号，并对该扇区密码进行密码校验，在三次相互认证（硬件完成）之后就可以通过加密流进行通讯。（在选择另一扇区时，则必须进行另一扇区密码校验。）  </p>
<p><strong>加值和减值</strong></p>
<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193653.png" alt="image-20200915175932051" style="zoom: 67%;" />

<p>初始化想要的值段后，调用加值和减值的函数即可。</p>
<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193659.png" alt="image-20200915180518781" style="zoom:67%;" />

<p><strong>面向比特的防冲突机制</strong></p>
<p>卡片有一个全球唯一的序列号。 比如Mifare1卡， 每张卡片有一个全球唯一的32位二进制序列号。 显而易见，卡号的每一位上不是“1”就是“0”，而且由于是全世界唯一，所以任何两张卡片的序列号总有一位的值是不一样的，也就说总存在某一位，一张卡片上是“0”，而另一张卡片上是“1”。硬件自动完成。</p>
<p><strong>S50读卡命令</strong></p>
<ul>
<li>请求0x26</li>
<li>防冲突0x93,0x70</li>
<li>A认证0x60, addr, keyA, ID</li>
<li>读0x30,addr CRC16</li>
</ul>
<p><strong>硬件连接图</strong></p>
<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193707.png" alt="image-20200822230556168" style="zoom:67%;" />

<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193717.png" alt="image-20200822230515354" style="zoom: 67%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 主函数中的修改对应的头文件和LCD及Touch初始化全部改为串口初始化</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> main主函数只留下Delay_Init、串口及RMFRC522_Initializtion()初始化</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 将MFRC522_Initializtion();<span class="comment">//初始化MFRC522里面函数STM32_SPI3_Init()初始化程序改为模拟SPI引脚初始化</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 在MFRC522.h中修改相关的头文件</span><br><span class="line">将下面宏定义修改为对引脚的定义（CS:PD15   RST:PE15）</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MFRC522_CS(x)   x ? GPIO_SetBits(GPIOB,GPIO_Pin_2):GPIO_ResetBits(GPIOB,GPIO_Pin_2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MFRC522_Rst(x)  x ? GPIO_SetBits(GPIOB,GPIO_Pin_1):GPIO_ResetBits(GPIOB,GPIO_Pin_1)</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 修改<span class="type">void</span> <span class="title function_">SPI3_Send</span><span class="params">(u8 val)</span> 及u8 <span class="title function_">SPI3_Receive</span><span class="params">(<span class="type">void</span>)</span>为模拟SPI发送接收数据</span><br><span class="line"></span><br><span class="line">6. 修改MFRC522.c相关的延时函数</span><br><span class="line"></span><br><span class="line">7. 修改主函数当中的<span class="title function_">MFRC522Test</span><span class="params">()</span>;获取RFID相关的卡ID 写入数据等</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MFRC522Test();</span><br><span class="line">        delay_s(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">8.</span> 屏幕显示全部改为串口打印即可</span><br><span class="line"> <span class="comment">//命令有两种类型，一种是传给RC522的，对RC522进行操作；一种是先传给RC522，RC522再传给卡片   </span></span><br><span class="line"><span class="comment">//MF522命令字</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD_IDLE              0x00               <span class="comment">//取消当前命令 空闲模式</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD_AUTHENT           0x0E               <span class="comment">//验证密钥</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD_RECEIVE           0x08               <span class="comment">//接收数据</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD_TRANSMIT          0x04               <span class="comment">//发送数据</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD_TRANSCEIVE        0x0C               <span class="comment">//发送并接收数据</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD_RESETPHASE        0x0F               <span class="comment">//复位</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCD_CALCCRC           0x03               <span class="comment">//CRC计算</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Mifare_One卡片命令字</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_REQIDL           0x26               <span class="comment">//寻天线区内未进入休眠状态 REQA请求</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_REQALL           0x52               <span class="comment">//寻天线区内全部卡     唤醒</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_ANTICOLL1        0x93               <span class="comment">//防冲撞</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_ANTICOLL2        0x95               <span class="comment">//防冲撞</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_AUTHENT1A        0x60               <span class="comment">//验证A密钥</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_AUTHENT1B        0x61               <span class="comment">//验证B密钥</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_READ             0x30               <span class="comment">//读块</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_WRITE            0xA0               <span class="comment">//写块</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_DECREMENT        0xC0               <span class="comment">//扣款</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_INCREMENT        0xC1               <span class="comment">//充值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_RESTORE          0xC2               <span class="comment">//调块数据到缓冲区</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_TRANSFER         0xB0               <span class="comment">//保存缓冲区中数据</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PICC_HALT             0x50               <span class="comment">//休眠</span></span></span><br></pre></td></tr></table></figure>

<h1 id="NFC"><a href="#NFC" class="headerlink" title="NFC"></a>NFC</h1><p>NFC (Near Field Communication)近场通信，这个技术由非接触式射频识别(RFID) 演变而来，由飞利浦半导体(现恩智浦半导体公司)、诺基亚和索尼共同研制开发，其基础是RFID及互连技术。</p>
<p>NFC是一种短距离高频的无线电技术，在13.56MHz频率运行于20cm距离内。其传输速度有106Kbit&#x2F;s，212Kbit&#x2F;s或者424Kbit&#x2F;s三种。NFC采用主动和被动两种读取模式。</p>
<p><strong>工作模式</strong></p>
<ul>
<li>卡模式：这个模式其实就是相当于一张采用RFID技术的IC卡。可以替代大量的IC卡(包括信用卡)场合商场刷卡、公交卡、门禁管制，车票，门票等等。此种方式下，有一个极大的优点，那就是卡片通过非接触读卡器的RF域来供电，即便是寄主设备(如手机)没电也可以工作。</li>
<li>读写器模式：这个模式可以模拟读卡器功能，读取MIFARE和FeliCa卡的信息</li>
<li>点对点模式：这个模式和红外线差不多，可用于数据交换，只是传输距离较短，传输创建速度较快，传输速度可快些，功耗低(蓝牙也类似)。将两个具备NFC功能的设备链接，能实现数据点对点传输，如下载音乐、交换图片。</li>
</ul>
<p><strong>PN532</strong></p>
<p>PN532，它是一款高度集成的非接触式通讯收发模块，基于8051单片机核心。它支持6个不同的操作模式(硬件集成的)：</p>
<ul>
<li><p>ISO&#x2F;IEC14443A&#x2F;MIFARE 读&#x2F;写器</p>
</li>
<li><p>FeliCa 读&#x2F;写器</p>
</li>
<li><p>ISO&#x2F;IEC14443B读&#x2F;写器</p>
</li>
<li><p>ISO&#x2F;IEC14443A MIFARE卡模拟模式</p>
</li>
<li><p>FeliCa卡模拟模式</p>
</li>
<li><p>ISO&#x2F;IEC 18092 ECMA 340点对点</p>
</li>
</ul>
<p>这款芯片提供3中和主机通信的接口: <code>SPI\|I2C\USART</code>。</p>
<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193726.png" alt="image-20200915155342037" style="zoom:80%;" />

<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116193731.png" alt="image-20200915155453638" style="zoom:80%;" />

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pn532Cmd</span>&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> Preamble;<span class="comment">//前序</span></span><br><span class="line">    <span class="type">uint8_t</span> StartCode[<span class="number">2</span>];<span class="comment">//包头</span></span><br><span class="line">    <span class="type">uint8_t</span> LEN;<span class="comment">//包长 TFI+PD0... PDn</span></span><br><span class="line">    <span class="type">uint8_t</span> LCS;<span class="comment">//长度校验LEN + LCS = 0x00</span></span><br><span class="line">    <span class="type">uint8_t</span> TFI;<span class="comment">//命令帧识别位(0xD4: input) (0xD5: output)</span></span><br><span class="line">    <span class="type">uint8_t</span> *data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="type">uint8_t</span> DCS;<span class="comment">//数据校验[TFI+PDO+PD1+...+PDn+DCS]=0x00</span></span><br><span class="line">    <span class="type">uint8_t</span> Postamble;<span class="comment">//后序</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> AUTHOR[<span class="number">14</span>] = &#123;<span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0x60</span>, <span class="number">0x02</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, Oxff, <span class="number">0xff</span>, <span class="number">0x01</span>, <span class="number">0x02</span>, <span class="number">0x03</span>, <span class="number">0x04</span>);</span><br><span class="line"><span class="comment">/*41 0应答，无措*/</span></span><br><span class="line"><span class="type">uint8_t</span> READ[<span class="number">4</span>] = &#123;<span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0x30</span>, <span class="number">0x07</span>&#125;;<span class="comment">//交换数据，1号卡，读取块，2地址</span></span><br><span class="line"><span class="comment">/*41, 0，16bytes 应答，16个数据*/</span></span><br><span class="line"><span class="type">uint8_t</span> WRITE[<span class="number">20</span>] = &#123;<span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xa0</span>, <span class="number">0x02</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;<span class="comment">//交換数据，1号卡，写入块</span></span><br><span class="line"><span class="comment">/*41, 0应答，无错*/</span></span><br><span class="line"><span class="type">uint8_t</span> INCREMENT[<span class="number">8</span>] = &#123;<span class="number">0x40</span>, <span class="number">0x01</span>, <span class="number">0xc1</span>, <span class="number">0x02</span>, <span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;<span class="comment">//交换数据， 1号卡，充值，2地址，数据</span></span><br><span class="line"><span class="type">uint8_t</span> DECREMENT[<span class="number">8</span>] = &#123;<span class="number">0x40</span>, <span class="number">0x01</span>,<span class="number">0xc0</span>,<span class="number">0x02</span>, <span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;<span class="comment">//交换数据， 1号卡，扣款，2地址，数据</span></span><br><span class="line"><span class="type">uint8_t</span> TRANSFER[<span class="number">4</span>] = &#123;<span class="number">0x40</span>, <span class="number">0x01</span>,<span class="number">0xB0</span>,<span class="number">0x02</span>&#125;;<span class="comment">//交换数据，1号卡，保存，2地址 回写</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Wake_Card</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(rx_buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(rx_buffer));<span class="comment">//串口缓存器清零</span></span><br><span class="line">    SendCmd(WAKE, <span class="number">24</span>) ;</span><br><span class="line">    HAL_Delay(<span class="number">100</span>) ;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">memcmp</span>(rx_buffer.WAKEBACK, <span class="number">9</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;wake ok\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;wake failed\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">Scan_Card</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    menset(rx_buffer, <span class="number">0</span>, <span class="number">128</span>):</span><br><span class="line">    GetCmd(SCAN, <span class="number">3</span>);</span><br><span class="line">    SendCmd(buf, len);</span><br><span class="line">    HAL_Delay(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span>(rx_buffer[<span class="number">5</span>]==<span class="number">0xd5</span> &amp;&amp; rx_buffer[<span class="number">6</span>]==<span class="number">0x4b</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;get card\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>: i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ID[i]=rx_buffer[<span class="number">13</span>+i];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%x &quot;</span>,ID[i]);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>板级通信协议</category>
      </categories>
      <tags>
        <tag>SPI</tag>
      </tags>
  </entry>
  <entry>
    <title>看门狗扫盲</title>
    <url>/2025/prefix%20remember%20to%20change!!!-5323449eed0c/</url>
    <content><![CDATA[<blockquote>
<p>下面以STM32为例介绍</p>
</blockquote>
<h1 id="独立看门狗"><a href="#独立看门狗" class="headerlink" title="独立看门狗"></a>独立看门狗</h1><p>在由单片机构成的微型计算机系统中，由于单片机的工作常常会受到来自外界电磁场的干扰，（造成各种寄存器和内存的数据混乱，导致程序指针错误，不在程序区，取出错误的程序指令等）造成程序的跑飞，而陷入死循环，程序的正常运行被打断，由单片机控制的系统无法继续工作，会造成整个系统陷入停滞状态，发生不可预料的后果，所以出于对单片机运行状态进行实时监测的考虑，便产生了一种专门用于监测单片机程序运行状态的模块或者芯片，俗称“看门狗”(watchdog)。 </p>
<p>看门狗是一个定时器电路， 一般有一个输入，叫喂狗，一个输出到MCU的RST端，MCU正常工作的时候，每隔一段时间输出一个信号到喂狗端，给WDT清零，如果超过规定的时间不喂狗，(一般在程序跑飞时，不在程序正常的状态)，WDT 定时超过，就会给出一个复位信号到MCU，使MCU复位，防止MCU死机。所以，看门狗的作用就是防止程序发生死循环，或者说程序跑飞。</p>
<p>独立看门狗(IWDG)由专用的低速时钟(LSI)驱动，即使主时钟发生故障它仍有效。换句话说，独立看门狗拥有自己的时钟源。假如PLL崩溃了，负责运行程序的硬件单元ALU就无法工作，也就无法喂狗。独立看门狗依然能够正常工作，检测到其计数值为0，认为软件故障，则触发系统复位。</p>
<p>注：看门狗命令在程序的中断中拥有最高的优先级。</p>
<p><strong>场景</strong></p>
<p>独立看门狗适合应用于需要看门狗作为一个在主程序之外能够完全独立工作，并且对时间精度要求低的场合。</p>
<p>以STM32为例：</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116192745.png" alt="image-20200822145753829"></p>
<p>STM32F4的独立看门狗由内部专门的 32Khz 低速时钟（LSI）驱动，即使主时钟发生故障，它也仍然有效。这里需要注意独立看门狗的时钟是一个内部RC时钟，所以并不是准确的32Khz，而是在15~47Khz 之间的一个可变化的时钟，只是我们在估算的时候，以 32Khz 的频率来计算，独立看门狗对时间的要求不是很精确，所以，时钟有些偏差都是接受的范围。</p>
<p>当通过对关键字寄存器 (IWDG_KR) 写入值 0xCCCC 启动独立看门狗时，计数器开始从复位值 0xFFF 递减计数。当计数器计数到终值 (0x000) 时会产生一个复位信号（ IWDG 复位）。任何时候将关键字 0xAAAA 写到 IWWDG_KR 寄存器中， IWDG_RLR 的值就会被重载到计数器，从而避免产生看门狗复位。</p>
<p><strong>寄存器访问保护</strong><br>IWDG_PR 和 IWDG_RLR 寄存器具有写访问保护。若要修改寄存器，必须首先对 IWDG_KR寄存器写入代码 0x5555，而写入其他值则会破坏该序列，从而使寄存器访问保护再次生效。这意味着重装载操作（即写入 0xAAAA）也会启动写保护功能。注：状态寄存器指示预分频值和递减计数器是否正在被更新。</p>
<ol>
<li><p>在键值寄存器（IWDG_KR)中写入0xCCCC，开始启用独立看门狗。此时计数器开始从其复位值0xFFF递减，当计数器值计数到尾值0x000时会产生一个复位信号（IWDG_RESET)。</p>
</li>
<li><p>无论何时，只要在键值寄存器IWDG_KR中写入0xAAAA（通常说的喂狗）, 自动重装载寄存器IWDG_RLR的值就会重新加载到计数器，从而避免看门狗复位。</p>
</li>
<li><p>如果程序异常，就无法正常喂狗，从而系统复位。</p>
<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116192758.png" alt="image-20200822150407952" style="zoom:80%;" /></li>
</ol>
<h2 id="独立看门狗配置流程"><a href="#独立看门狗配置流程" class="headerlink" title="独立看门狗配置流程"></a>独立看门狗配置流程</h2><p>添加支持独立看门狗的库函数文件：<code>stm32f4xx_iwdg.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Iwdg_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1、 取消寄存器写保护：</span></span><br><span class="line">    IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);</span><br><span class="line">    <span class="comment">//2、设置独立看门狗的预分频系数，确定时钟:125HZ (32000/256=125)</span></span><br><span class="line">    IWDG_SetPrescaler(IWDG_Prescaler_256);</span><br><span class="line">    <span class="comment">//3、设置看门狗重装载值，确定溢出时间:2s</span></span><br><span class="line">    IWDG_SetReload(<span class="number">250</span>);</span><br><span class="line">    <span class="comment">//4、使能看门狗</span></span><br><span class="line">    IWDG_Enable();</span><br><span class="line">    <span class="comment">//5、喂狗</span></span><br><span class="line">    IWDG_ReloadCounter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在裸机代码实现喂狗，放在定时器里面，因为定时器与看门狗是使用不同的时钟源，允许这么做！</p>
<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116192810.png" alt="image-20200913213928315" style="zoom: 67%;" />

<p>如果<strong>有实时的操作系统</strong>，可以在<strong>任务里面添加喂狗动作</strong>，如果操作系统崩溃了，能够检测到软件的错误，触发CPU的复位。</p>
<h1 id="窗口看门狗"><a href="#窗口看门狗" class="headerlink" title="窗口看门狗"></a>窗口看门狗</h1><p>窗口看门狗通常被用来监测，由外部干扰或不可预见的逻辑条件造成的应用程序背离正常的运行序列而产生的软件故障。除非递减计数器的值在T6位变成0前被刷新，看门狗电路在达到预置的时间周期时，会产生一个MCU复位。如果在递减计数器达到窗口寄存器值之前刷新控制寄存器中的递减计数器值，也会产生MCU复位。这意味着必须在限定的时间窗口内刷新计数器。</p>
<p><strong>WWDG主要特性</strong></p>
<ul>
<li>可编程的自由运行递减计数器</li>
<li>复位条件<ul>
<li>当递减计数器值小于0x40时复位(如果看门狗已激活)。</li>
<li>在窗口之外重载递减计数器时复位(如果看门狗已激活)。</li>
</ul>
</li>
<li>提前唤醒中断(EWI)：当递减计数器等于0x40时触发( 如果已使能且看门狗已激活)</li>
</ul>
<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20201116192818.png" alt="image-20200913214821839" style="zoom: 67%;" />

<h2 id="窗口看门狗配置流程"><a href="#窗口看门狗配置流程" class="headerlink" title="窗口看门狗配置流程"></a>窗口看门狗配置流程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//窗口看门狗的时钟频率1281Hz，每进行减一计数，所花的时间</span></span><br><span class="line">     T=<span class="number">1</span>/f=<span class="number">1</span>/<span class="number">1281</span>Hz≈<span class="number">780u</span>s</span><br><span class="line"></span><br><span class="line"><span class="comment">//从127减到80，要进行47次的计数，所花的时间</span></span><br><span class="line">     T=<span class="number">780u</span>s * (<span class="number">127</span><span class="number">-80</span>) =<span class="number">36.66</span>ms</span><br><span class="line"></span><br><span class="line"><span class="comment">//从127减到64，要进行64次的计数，所花的时间</span></span><br><span class="line">     T=<span class="number">780u</span>s * (<span class="number">127</span><span class="number">-64</span>+<span class="number">1</span>) =<span class="number">49.92</span>ms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 窗口看门狗的配置 */</span></span><br><span class="line"><span class="comment">/* 使能窗口看门狗的时钟 */</span></span><br><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 窗口看门狗的时钟 = (PCLK1 (42MHz)/4096)/8 = 1281 Hz (~780 us)  */</span></span><br><span class="line">WWDG_SetPrescaler(WWDG_Prescaler_8);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*     设置窗口的上限值为80 */</span></span><br><span class="line">WWDG_SetWindowValue(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置计数值的初值为127，则窗口看门狗的最大超时时间 = 780 us * 64 = 49.92 ms </span></span><br><span class="line"><span class="comment">        这个时候窗口刷新时间如下</span></span><br><span class="line"><span class="comment">        ~780 * (127-80) = 36.66ms &lt; refresh window &lt; ~780 * 64 = 49.9ms */</span></span><br><span class="line">WWDG_Enable(<span class="number">127</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//WWDG NVIC 配置</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannel = WWDG_IRQn;            <span class="comment">//窗口看门狗中断通道</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="number">0</span>;        <span class="comment">//抢占优先级0</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelSubPriority =<span class="number">0</span>;        <span class="comment">//子优先级0</span></span><br><span class="line">NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;            <span class="comment">//IRQ通道使能</span></span><br><span class="line">NVIC_Init(&amp;NVIC_InitStructure);                    <span class="comment">//根据指定的参数初始化VIC寄存器    </span></span><br><span class="line"><span class="comment">//清空提前唤醒中断标志位</span></span><br><span class="line">WWDG_ClearFlag();</span><br><span class="line"></span><br><span class="line"><span class="comment">//使能提前唤醒中断</span></span><br><span class="line">WWDG_EnableIT();</span><br><span class="line"></span><br><span class="line"><span class="comment">//看门狗中断服务函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">WWDG_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(WWDG_GetFlagStatus()==SET)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//进行喂狗</span></span><br><span class="line">        WWDG_SetCounter(<span class="number">127</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清空提前唤醒中断标志位</span></span><br><span class="line">        WWDG_ClearFlag();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>嵌入式概念扫盲</category>
      </categories>
      <tags>
        <tag>看门狗</tag>
      </tags>
  </entry>
</search>
