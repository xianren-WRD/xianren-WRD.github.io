<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CANoe 使用问题汇总</title>
    <url>/2023/CANoe-Usage-5b23d9c22076/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>记录日常工作中使用CANoe遇到的问题的解决方法。</p>
<h1 id="CANoe安装"><a href="#CANoe安装" class="headerlink" title="CANoe安装"></a>CANoe安装</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECREPAIR: Failed to open the file:E:\CANoe11.0 SP3\canoe\Files\2d2d758a-571d-4239-ba27-ceca9435a110\Data1.cab for computing its hash. Error:2</span><br><span class="line">SECUREREPAIR: Failed to CreateContentHash of the file: Data1.cab: for computing its hash. Error: 2</span><br></pre></td></tr></table></figure>

<p>之前在公司安装CANoe 11时，出现了错误，导致安装进行不下去。通过上面的错误提示，在查看本地电脑的路径后，可以大致看出问题出现是因为少了一个文件夹。在官网下载对应的SP4升级包后，能够找到缺失的文件夹。由此可以推断，公司放在共享盘的安装包是有问题的。于是，选择使用官方的升级包进行安装，最终安装成功。</p>
<h1 id="J1939-Options"><a href="#J1939-Options" class="headerlink" title="J1939 Options"></a>J1939 Options</h1><p>由于缺少相应的License，无法使用 J1939 Options 插件。因此，在导入J1939的DBC后，启动CANoe时出错，提示<code>Required bus system options: J1939 (missing)</code>，详见下图。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812173933.png" alt="J1939 Option.png"></p>
<p>对策方法是禁用DBC的J1939功能，也就是修改DBC的Networks属性，将ProtocolType这个属性的值删除&#x2F;置空即可，详见下图。注意，该操作是不可逆的，如有需要，可以先将原始文件备份一下。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812173949.png" alt="Disable J1939 Func.png"></p>
<h1 id="Graphics"><a href="#Graphics" class="headerlink" title="Graphics"></a>Graphics</h1><p>在CANoe的Graphics窗口，修改左边图例的Name，只是相应修改了右边坐标轴显示的名字，实际解析的信号和Name无关，不会因为Name的改变而改变。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812175128.png" alt="Graphics.png"></p>
<h1 id="报文回放"><a href="#报文回放" class="headerlink" title="报文回放"></a>报文回放</h1><p>PCAN导出的trc格式的报文，经过PEAK-Converter转换成asc格式之后，不能直接导入CANoe回放。但是，可以先拖到CANoe Trace窗口里面，右键导出保存为blf格式，然后再回放。</p>
<h1 id="CAPL"><a href="#CAPL" class="headerlink" title="CAPL"></a>CAPL</h1><h2 id="加密问题"><a href="#加密问题" class="headerlink" title="加密问题"></a>加密问题</h2><p>在工作中，有时候需要将CANoe工程外发，如果不想让别人查看我们编写的CAPL源码，那么这个时候就可以通过CAPL Browser的加密功能对源码进行加密。具体如何加密，网上已经有了很多教程。这里主要想说的是，之前在工作中发现：</p>
<ul>
<li><p>CANoe 10.0加密CAPL后，在Simulation Setup界面右键编辑ECU节点，会自动生成一个与加密前的CAPL源文件同名的文件，但是文件内容是空的。这样会导致后续再启动CANoe会出问题，ECU节点的CAPL不起作用了，不符合我们的预期；</p>
</li>
<li><p>CANoe 11.0加密则不同，同样去编辑节点会弹框提示已加密，并不会生成文件，后续再启动CANoe工程，所有的功能和加密前的一样，符合预期。</p>
</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>依次点击<code>CANoe Options--General--License</code>，即可设置，在打开CANoe时，显示license检查对话框。</p>
]]></content>
      <categories>
        <category>CAN总线工具</category>
      </categories>
      <tags>
        <tag>CANoe</tag>
      </tags>
  </entry>
  <entry>
    <title>J1939设计注意点</title>
    <url>/2025/prefix%20remember%20to%20change!!!-9a9c4e5c1e4f/</url>
    <content><![CDATA[<h1 id="需求规范检查"><a href="#需求规范检查" class="headerlink" title="需求规范检查"></a>需求规范检查</h1><h2 id="标准规范"><a href="#标准规范" class="headerlink" title="标准规范"></a>标准规范</h2><p><strong>OSI层级</strong></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013203758.png"></p>
<table>
<thead>
<tr>
<th align="left">规范类别</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">J1939-Year</td>
<td>Year指特定的版本，比如：J1939-2005。描述了网络的概况 、OSI分层结构、下属文档结构，并为所有预分配的值和名称提供管控。</td>
</tr>
<tr>
<td align="left">J1939-0x</td>
<td>⼀个应用文档，其中 x 指代网络的特定网络&#x2F;应用版本。该文档将说明其适用的行业或应用，并列出了构成此网络的各层的具体版本。 <br/>• J1939&#x2F;01: 卡车和客车控制与通信网络 (Truck and Bus Control and Communications Network)。<br/>• J1939&#x2F;02 (草案): 农业设备控制与通信网络 (Agricultural Equipment Control and Communications Network)。</td>
</tr>
<tr>
<td align="left">J1939-1x</td>
<td>物理层文档，其中 x 指特定的物理层不同内容。<br/>• J1939&#x2F;11：物理层，250K 比特&#x2F;秒，屏蔽双绞线。<br/>• J1939&#x2F;16：自动选择波特率<br/>• J1939&#x2F;17：CAN FD-500 kbit&#x2F;s | 2 Mbit&#x2F;s</td>
</tr>
<tr>
<td align="left">J1939-2x</td>
<td>详细规定数据链路层的具体实现。<br/>• J1939&#x2F;21：Data Link Layer on Classic CAN<br/>• J1939&#x2F;22：Data Link Layer on CAN FD</td>
</tr>
<tr>
<td align="left">J1939-31</td>
<td>网络层：定义了在更复杂的网络拓扑中（如多个网段通过网桥&#x2F;网关连接）如何路由J1939消息</td>
</tr>
<tr>
<td align="left">J1939-7x</td>
<td>应用层文档，其中 x 指代应用层的特定版本。<br/>• 1939&#x2F;71: 车辆应用层。定义了车辆中各种具体功能所需的数据参数、消息（PGN）及其格式、语义和传输要求。<br/>• J1939&#x2F;73: 应用层 - 诊断</td>
</tr>
<tr>
<td align="left">J1939-81</td>
<td>网络管理 - 地址配置与参数配置</td>
</tr>
</tbody></table>
<h2 id="客户规范"><a href="#客户规范" class="headerlink" title="客户规范"></a>客户规范</h2><ul>
<li><p>明确客户参考的标准规范版本 ，OEM规范引用的J1939⼀般都很旧</p>
</li>
<li><p>明确实施J1939规范的适用内容&#x2F;范围，定义在OEM规范</p>
</li>
<li><p>确认Vector协议栈⽀持的OEM规范和J1939版本及对应的OEM功能</p>
</li>
</ul>
<h1 id="SAE分层设计考虑"><a href="#SAE分层设计考虑" class="headerlink" title="SAE分层设计考虑"></a>SAE分层设计考虑</h1><h2 id="J1939-11"><a href="#J1939-11" class="headerlink" title="J1939-11"></a>J1939-11</h2><p>规定了最常用的J1939物理层实现标准。</p>
<ul>
<li>关键点： 基于ISO 11898-2 (高速CAN) 的电气特性（电压电平、阻抗、终端电阻）、电缆要求（屏蔽双绞线）、连接器（推荐9针Deutsch DT或等效）、总线拓扑（主干线-支线结构）、最大线缆长度（40米 250kbps）、通信速率（250 kbps）。</li>
</ul>
<p><strong><mark>设计考虑</mark></strong></p>
<ol>
<li>需要考虑波特率和采样点的配置。</li>
</ol>
<h2 id="J1939-16"><a href="#J1939-16" class="headerlink" title="J1939-16"></a>J1939-16</h2><p>介绍了车辆通信网络中自动波特率检测的流程。该流程使网络设备能够自动识别并适应 SAE J1939- 11、SAE J1939-14 或 SAE J1939-15 物理层标准所指定的 CAN 经典网络的通信速率（波特率）。</p>
<p>其核心目的是实现设备间无需预先配置波特率即可互联互通，从而提升通信的灵活性和效率，并最大限度地减少或消除因波特率不匹配对现有网络设备造成的通信中断。</p>
<p>标准里面提到两种实现，大致如下：</p>
<ul>
<li><p>设置某个波特率，如果发送报文时，检测到总线上有错误，⼀段时间后切到另⼀个波特率，重复这个过程。</p>
</li>
<li><p>CAN控制器设置为监听模式，只接收，不发送报文，如果检测到总线上有错误，⼀段时间后切到另⼀个波特率，重复这个过程。</p>
</li>
</ul>
<p><strong><mark>设计考虑</mark></strong></p>
<ol>
<li>需要明确的是，此流程仅适用于使用ISO 11898-1:2015 定义的经典基本帧格式 (CBFF) 和经典扩展帧格式 (CEFF) 数据帧的 CAN 经典网络。基于 SAE J1939-17 物理层（唯⼀⽀持的 SAE J1939 CAN FD 物理层选项）的 SAE J1939 CAN FD 网络不在此流程适用范围内，因为该标准仅指定了⼀种波特率组合（500 kbit&#x2F;s 仲裁段+2000 kbit&#x2F;s 数据段）。</li>
</ol>
<h2 id="J1939-21"><a href="#J1939-21" class="headerlink" title="J1939-21"></a>J1939-21</h2><p>详细规定了J1939协议栈中数据链路层的具体实现。定义了数据如何在物理层之上可靠地打包、寻址、传输和接收，是通信可靠性的核心保障。</p>
<h3 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h3><p>协议数据单元PDU格式：优先级、保留位、数据页、PDU格式PF、PDU特定PS、源地址SA。 </p>
<p><strong>PGN的定义</strong></p>
<p>PGN是24位，⼀共三个字节，第⼀个字节高六位都是0填充。PGN是唯⼀的。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013210628.png"></p>
<p><strong>PDU的详细解析规则</strong></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013210755.png"></p>
<p>扩展CAN ID是29位标识符，各部分含义如下：</p>
<table>
<thead>
<tr>
<th>CAN ID域</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>P</td>
<td>优先级。用来优化报文延迟，所有控制报文缺省优先级是3。其他所有报文、专用、请求和ACK 报文的缺省优先级是6。</td>
</tr>
<tr>
<td>EDP</td>
<td>扩展数据页</td>
</tr>
<tr>
<td>DP</td>
<td>数据页</td>
</tr>
<tr>
<td>PF</td>
<td>PDU格式段（0-239：PDU1格式；240-255：PDU2格式）</td>
</tr>
<tr>
<td>PS</td>
<td>PDU特定域（PDU1格式：DA 目的地址；PDU2格式：GE 群扩展）</td>
</tr>
<tr>
<td>SA</td>
<td>源地址。网络中⼀个特定源地址只能匹配⼀个设备</td>
</tr>
</tbody></table>
<p><strong>CanId解析举例</strong></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013211018.png"></p>
<p><strong><mark>设计考虑</mark></strong></p>
<p>需要检查AUTOSAR过滤器的配置，包括<u>硬件过滤（Can）和软件过滤（CanIf）</u>。</p>
<p>目前购买的vector AUTOSAR的硬件过滤会自动mask掉优先级，要自己检查filter是否正确，并且在实际项目还是需要自测不同优先级是否能接收。</p>
<p>确保：</p>
<p><strong>PDU2格式和PDU1格式</strong></p>
<ul>
<li><p>相同PGN和相同SA，不同优先级，能被正常接收（即，优先级位必须被接收器屏蔽）。</p>
</li>
<li><p>相同PGN和不同SA，不同优先级，是否要被正常接收取决于客户需求。比如：DAF要求源地址位不应被接收器屏蔽。（其他国内有遇到过，不同车型会发送不同的SA，通过PGN区分）-&gt; 确认vector是否支持mask SA</p>
</li>
</ul>
<p>如果不同的SA要被支持，硬件过滤需要mask SA！</p>
<p><strong>PDU1格式特有</strong></p>
<ul>
<li>相同PGN，不同优先级，只接收报文DA与自己DA⼀致的报文。</li>
</ul>
<p><strong>UDS DTC</strong></p>
<p>DTC timeout检测要考虑mask优先级，避免DBC定义之外的报文优先级没有考虑，导致误报</p>
<p>timeout DTC；</p>
<h3 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h3><p>多包报文在连接管理报文（TP.CM）的协调下进行多帧传输。它可再细分为两个主要功能：消息的拆装和重组； 和连接管理。</p>
<p>连接管理是用于处理在特定目标地址传输时，节点间虚拟连接的打开、使用和关闭。虚拟连接，是指在 SAE J1939 的网络环境中，为了传送⼀条由⼀个单独的PGN描述的长消息，在两个节点间建立的临时连接。</p>
<p>在连接是⼀点到多点的情况下(广播)，不提供数据流控制和关闭的管理功能。</p>
<p><strong>广播BAM</strong></p>
<p>TP.CM_BAM和TP.DT。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013213749.png"></p>
<p><strong>RTS&#x2F;CTS</strong></p>
<p>TP.CM_RTS和TP.CM_CTS。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013213842.png"></p>
<p>需要注意：RTS&#x2F;CTS是有错误处理和重传机制的。</p>
<p><strong><mark>设计考虑</mark></strong></p>
<ul>
<li><p>需要考虑数据包DT的传输间隔，默认是50ms。</p>
</li>
<li><p>⼀些特定的报文当它们≤ 8 个字节时，会使用非TP的形式来发送，而当它们＞8个字节时，则使用TP的形式来发送。这两种形式可能同时进行发送。</p>
</li>
<li><p>PGN TP形式长数据正在发送(使用TP PGN)，此时PGN的数据长度更新为≤ 8 个字节需要非TP形式发送(本身报文的PGN)，非TP形式不能打断前面的TP发送，理论上因为使用不同的PGN在发送，所以无影响。但是需要考虑这种发送是否会影响到应用逻辑或时序。比如应用先发送长数据，再发送短数据，接收端可能会先收到短数据，再收到长数据！</p>
</li>
<li><p>发送&gt;1785字节数据，验证：发送端是否拒绝；接收端是否丢弃并报错。</p>
</li>
</ul>
<h3 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h3><p>J1939⽀持五种类型的报文，分别为：命令、请求、广播&#x2F;响应、确认和群扩展。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013214226.png"></p>
<ol>
<li><p>命令报文：从某个源地址向特定目标地址或全局目标地址发送命令的参数组。PDU1 格式和PDU2格式都能用作命令。命令类型的消息可能包括传动控制、地址请求、扭矩&#x2F;速度控制等等。</p>
</li>
<li><p>请求报文：从全局范围或从特定目标地址请求信息。最典型的⼀个报文是请求PGN报文。</p>
</li>
<li><p>广播&#x2F;响应报文：此消息类型可能是某设备主动提供的消息广播，也可能是命令或请求的响应，总线上的数据交换大多采用这类报文。</p>
</li>
<li><p>确认报文：对于特定命令、请求的“普通广播”或“ACK” 或“NACK”响应。</p>
</li>
<li><p>群扩展：这种类型报文用于⼀组特殊功能(如专用功能、网络管理功能、多包传输功能等)。</p>
</li>
</ol>
<p><strong><mark>设计考虑</mark></strong></p>
<p>确认DaVinci中五种报文的PGN范围配置正确（如命令PGN: 0-57343，请求PGN: 59904）。</p>
<p>对于请求报文：</p>
<ul>
<li>根据需求，在DaVinci中注册本节点需要响应的PGN列表，避免响应非法PGN请求。如果发送未注册PGN的请求，需要返回NACK。对于要支持的PGN需要勾选，默认发送的都需要：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013214834.png"></p>
<ul>
<li><p>仅对点对点请求发送ACK（校验目标地址DA 匹配本机地址），全局广播报文不响应ACK(vector协议栈已处理)。</p>
</li>
<li><p>需要考虑ACK超时时间（默认200ms），实现重传机制（≤3次），vector可配置。</p>
</li>
<li><p>请求发送需要管理⼀个队列，队列大小需要确保所有需要发送的确认PG都可以按照顺序排队等待发送，vector可配置。</p>
</li>
</ul>
<h2 id="J1939-31"><a href="#J1939-31" class="headerlink" title="J1939-31"></a>J1939-31</h2><p>定义了在更复杂的网络拓扑中（如多个网段通过网桥&#x2F;网关连接）如何路由J1939消息。</p>
<ul>
<li><p>关键点：网桥&#x2F;网关的功能要求、网络分段原则、基于目标地址的路由规则、报文过滤、地址管理（网桥自身的地址声明）、网络层协议NLP（用于网桥间通信）。</p>
</li>
<li><p>重要性：使J1939网络能够扩展到大型或复杂的车辆架构（如带挂车的牵引车、大型工程机械），实现不同网段间的通信。</p>
</li>
</ul>
<p>仅适用于旨在提供网络服务的 ECU。</p>
<h2 id="J1939-71"><a href="#J1939-71" class="headerlink" title="J1939-71"></a>J1939-71</h2><p>定义了车辆中各种具体功能所需的数据参数、消息（PGN）及其格式、语义和传输要求。</p>
<ul>
<li><p>关键点： 包含海量的标准PGN定义（如发动机转速、车速、油压、故障码DTC、巡航控制状态、变速箱档位等）、每个PGN包含哪些SPN（具体参数）、每个SPN的数据长度、分辨率、偏移量、单位、范围、数据更新周期或传输触发条件。这是内容最庞大且不断更新的部分。</p>
</li>
<li><p>重要性： 规定了车辆各ECU之间交换的具体数据内容及其含义，是实现互操作性的关键。仪表显示、控制逻辑、诊断信息都依赖于此。</p>
</li>
</ul>
<p>SAE J1939 的报文格式使用PGN作为⼀组参数的标号。⼀组参数称为“参数组”，PGN是其唯⼀的标识号。参数组内有⼀个或多个具体的参数，每个具体参数都有⼀个唯⼀的标号，称为“可疑参数编号”，即SPN。PGN类似于报文ID，SPN则类似于信号ID。</p>
<h3 id="信号参数值范围"><a href="#信号参数值范围" class="headerlink" title="信号参数值范围"></a>信号参数值范围</h3><p>标准的参数值范围定义如下，包括：有效值，错误值，无效值等。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013215516.png"></p>
<h3 id="标准PGN定义"><a href="#标准PGN定义" class="headerlink" title="标准PGN定义"></a>标准PGN定义</h3><p>有些时候客户只提供某个具体的PGN&#x2F;SPN，而不提供信号的layout以及属性定义。</p>
<p>如果PGN是标准PGN（不属于自定义PGN范围）的情况下，我们就可以在 J1939.dbc 里面找到对应的layout定义。</p>
<p>注意： J1939.dbc 在安装CANoe的时候就会携带，或者在SIP包里面也可以找到。查看J1939网络的属性，可以看到引用的版本。也可以在J1939-Year的规范里面找到标准PGN定义。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013215710.png"></p>
<h3 id="自定义报文原则"><a href="#自定义报文原则" class="headerlink" title="自定义报文原则"></a>自定义报文原则</h3><p>自定义报文通过选定SAE J1939协议中预留的PDU2格式中的“<u>私有(专用)B段</u>”，即 PF&#x3D;255， PS&#x3D;0~255 来编制PGN。</p>
<p>参数组定义的原则：</p>
<ol>
<li><p>按照参数的功能分组而不是按照参数的类型分组</p>
</li>
<li><p>按照参数的刷新频率分组</p>
</li>
<li><p>按照参数所属的子系统</p>
</li>
</ol>
<p>所以，同⼀子系统的相同功能的刷新率接近的若干参数可以构成⼀个参数组。</p>
<p>SPN选择SAE J1939 在预留段 520192~524287 中定义，并从520192开始顺序地为每个参数分配SPN。</p>
<h2 id="J1939-73"><a href="#J1939-73" class="headerlink" title="J1939-73"></a>J1939-73</h2><p>定义车辆诊断相关的消息、参数和流程。在商用车网络设计领域，诊断常用组合如下：J1939-73的DM报文或DM1报文+UDS的组合。</p>
<p>关键内容：</p>
<ol>
<li><p>诊断故障码 (DTC - Diagnostic Trouble Code)：</p>
<ul>
<li><p>定义了 DTC 的结构：由 SPN (可疑参数编号) + FMI (故障模式标识符) + OC (发生次数) 组成。</p>
</li>
<li><p>规定了如何报告、存储和清除 DTC。</p>
</li>
</ul>
</li>
<li><p>诊断消息 (Diagnostic Messages - DM)：</p>
<ul>
<li><p>提供了⼀系列标准化的 PGN (参数组编号) 用于诊断通信：</p>
<ul>
<li><p>DM1: 报告当前检测到并激活的故障。</p>
</li>
<li><p>DM13: 停止&#x2F;启动广播消息 (比如DM1)。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="DM1"><a href="#DM1" class="headerlink" title="DM1"></a>DM1</h3><p>作用：报告当前检测到并激活的故障。</p>
<p><strong>发送方式</strong></p>
<ul>
<li><p>故障首次激活（持续 ≥ 1秒）：</p>
<ul>
<li><p>⼀旦某个 DTC 从“不激活”变成“激活”状态，并且这个激活状态持续了 1 秒或更⻓时间，ECU 会立即开始传输 DM1 报文。</p>
</li>
<li><p>之后，只要该故障（或其它故障）仍处于激活状态，DM1 报文就以每秒⼀次的速率持续更新。</p>
</li>
</ul>
</li>
<li><p>故障从不激活变为激活（短于1秒）：</p>
<ul>
<li>如果故障激活的时间非常短（少于 1 秒），然后立刻又变回不激活，这种情况可能不会触发⼀次单独的 DM1 传输来报告“激活”，因为它没有持续到触发传输的最小时间（1秒）。</li>
</ul>
</li>
<li><p>故障从激活变为不激活：</p>
<ul>
<li>如果⼀个激活状态持续了 1 秒或更长的故障，随后变为不激活状态，那么 ECU 必须在状态改变后的下⼀个传输机会（即下⼀次正常的每秒更新点）发送⼀个新的 DM1 报文，以表明这个DTC 不再处于激活状态。</li>
</ul>
</li>
<li><p>同⼀秒内发生多次状态变化（防抖&#x2F;限流）：（DM1本身是固定1S周期，本身就已经防抖）</p>
<ul>
<li><p>为了防止某个 DTC 在极短时间内（比如 1 秒内）反复在激活和不激活状态之间快速切换，导致DM1 报文发送过于频繁（高传输率），引入了⼀个限制规则：每个 DTC 每秒最多只报告⼀次状态改变。</p>
</li>
<li><p>具体处理：</p>
<ul>
<li><p>如果某个 DTC 在 1 秒内发生了两次状态改变（例如：先激活，然后在不激活），ECU 会：</p>
<ol>
<li><p>在检测到第⼀次状态改变（激活） 后的下⼀个传输机会（T1 时刻）发送 DM1，报告该DTC为激活状态。</p>
</li>
<li><p>在下⼀秒的传输机会（T2 时刻），再发送⼀个 DM1，报告该 DTC 为不激活状态。</p>
</li>
</ol>
</li>
<li><p>这样，无论 1 秒内实际状态切换了多少次，对于网络来说，每个 DTC 每秒最多只看到⼀次状态变化报告（要么激活，要么不激活），降低了传输负载。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>无激活故障时不主动发送：</p>
<ul>
<li><p>当没有任何 DTC 处于激活状态时，ECU 不会主动发送 DM1 报文。</p>
</li>
<li><p>例外：当诊断工具主动请求 DM1 信息时，即使没有激活故障，ECU 也必须响应这个请求并发送 DM1 报文（通常报告无激活故障或包含历史故障信息）。</p>
</li>
</ul>
</li>
<li><p>多故障处理（多包传输）：</p>
<ul>
<li><p>如果同时有多个激活的 DTC 需要报告，单个标准的 DM1 报文无法容纳所有信息。</p>
</li>
<li><p>此时，ECU 必须使用 “多包传输” 机制（例如 J1939 的传输协议功能 TP，使用 BAM ）。这意味着 DM1 的信息会被拆分成多个数据包（帧）在总线上传输。</p>
</li>
</ul>
</li>
</ul>
<p><mark><strong>设计考虑</strong></mark></p>
<p>UDS 28服务不能关闭DM1，DM1不在BSWM规则里面控制，DM1只受控于DM13控制。</p>
<p>BSWM的 J1939规则，只判断网络状态，控制整个J1939 DCM和J1939 RM模块通信。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013222021.png"></p>
<h3 id="DM13"><a href="#DM13" class="headerlink" title="DM13"></a>DM13</h3><p>停止&#x2F;启动广播消息 (比如DM1)。每当需要停止或开始广播事件时发送。</p>
<p><strong><mark>设计考虑</mark></strong></p>
<p>需要确认DM13影响的bus类型。一般，只需要支持current data link。</p>
<p>Autosar配置必须要选择⼀种，下图选择NETWORK_1，所以最终current data link(AUTOSAR没有选项，静态代码默认支持)或NETWORK_1都会生效：</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013222345.png"></p>
<h4 id="Hold-signal"><a href="#Hold-signal" class="headerlink" title="Hold signal"></a>Hold signal</h4><p>指示所有节点，DM13操作过的通信端口保持在修改状态。为了维持车辆网络的修改状态，保持信号必须每5秒广播⼀次，允许±1s的误差。请求停止广播的设备必须每5秒发送⼀次保持信号，如果在6秒内未收到该消息，则所有相关节点将恢复到其正常状态。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013222602.png"></p>
<p>保持信号允许DM13消息的发送者不必将DM13发送到特定地址，而是发送给已修改的控制器组或所有设备。这减少了需要发送的消息数量，从而使每个单独控制器的修改广播状态保持有效。</p>
<h4 id="Suspend-signal"><a href="#Suspend-signal" class="headerlink" title="Suspend signal"></a>Suspend signal</h4><p>向所有节点发出指示，当前J1939数据链路上的广播消息由于除了J1939 DM13之外的命令（比如： UDS 28）而被暂停。因此，接收节点应暂停对来自发送设备的所有消息的超时诊断。</p>
<p>暂停信号应广播⼀次，但发送设备可以选择重复发送（如果其具备该能力），以增加正确接收的机会，可以在暂停的第⼀秒内重复发送⼀到两次。如果发送设备发送⼀条将暂停信号设置为“1110”的DM13消息，则指示其正在恢复到完整的广播状态。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013222851.png"></p>
<p><strong><mark>设计考虑</mark></strong></p>
<p>Vector AUTOSAR包不支持suspend signal配置，静态代码也没有。</p>
<p>因为这个规范已经过时，目前接触的项目不要求实施，可以和客户确认是否需要实施。</p>
<h2 id="J1939-81"><a href="#J1939-81" class="headerlink" title="J1939-81"></a>J1939-81</h2><p>定义了如何为ECU分配网络地址以及如何配置ECU内部参数的标准化方法。不定义网络唤醒和休眠，网络管理机制采用OSEK或AUTOSAR NM。</p>
<ul>
<li><p>关键点：地址配置协议（通过专用工具或特定ECU）、参数配置协议（读取&#x2F;写入配置参数）、服务工具到ECU的通信机制。</p>
</li>
<li><p>重要性：简化了车辆生产线上ECU的初始化和维修过程中的ECU更换、参数调整，确保ECU能在网络上正确工作（获得地址）并按需设置（如车辆VIN号、轮胎尺寸、后桥速比等）</p>
</li>
</ul>
<p>控制器应用程序（CA）的基本概念：控制器由硬件和软件组成，其中软件叫作CA。⼀个ECU可以有多个CA，每个CA都有可以唯⼀识别的名字（称为CA NAME）和地址。</p>
<h3 id="地址的配置和作用"><a href="#地址的配置和作用" class="headerlink" title="地址的配置和作用"></a>地址的配置和作用</h3><p>地址的配置，定义了⼀个 ECU如何获得并保留它的源地址。地址配置与地址声明程序不同，后者是 ECU 想要使用某个地址时进行广播声明的程序。有四种不同地址配置可供 ECU使用。</p>
<ul>
<li><p>Non-Configurable Address CA&#x2F;固定地址配置</p>
<p>不可配置地址的ECU，是指那些已由OEM提供了源地址的ECU。在地址域中，包括服务工具在内的任何方法都不可改变它的地址。</p>
</li>
<li><p>Service Configurable Address CA&#x2F;服务可配置地址</p>
<p>可由维护人员配置地址的ECU，是指那些在地址域中源地址可以由维护的技术人员进行更改的ECU。这种 ECU 的 CA 可以在车辆下线时或维修时，使用外部的诊断工具（Service Tool） 通过 J1939 定义的诊断服务（通常是 DM15 - DTC Configuration，或者 DM16 - Binary Data Transfer）来进行更改或配置。</p>
<p>地址更改机制：</p>
<ul>
<li><p>需要离线或在特定配置模式下进行（通常车辆点火开关在 OFF 或 ACC 状态）。</p>
</li>
<li><p>诊断工具发送特定的 J1939 诊断服务报文到 ECU。</p>
</li>
<li><p>ECU 接收并验证请求后，将新的值存储到非易失性存储器（NVRAM）中。</p>
</li>
<li><p>下次启动时，ECU 使用新配置的值。</p>
</li>
</ul>
</li>
<li><p>Command Configurable Address CA&#x2F;J1939 Command修改地址</p>
<p>命令配置地址的ECU，是指那些在正常操作模式（相对于维护操作模式）下，可以通过命令地址报文（ PGN 65240 (0xFEC8)）来更改源地址的ECU。在上电时改变地址，不需要服务工具或者运行于特殊模式。实现运行时、自动化的地址分配和冲突解决，无需人工干预或诊断工具。</p>
<p>地址更改机制：</p>
<ul>
<li><p>⼀个具有地址分配权限的 ECU在网络上广播 Commanded Address 消息。</p>
</li>
<li><p>消息指定目标 ECU 的 NAME 和要分配给它的新 CA。</p>
</li>
<li><p>目标 ECU 接收到该命令（匹配其 NAME），验证命令合法性后，立即或在下⼀个启动周期使用新的 CA。</p>
</li>
<li><p>更改通常需要存储到 NVRAM。</p>
</li>
</ul>
</li>
<li><p>Self-Configurable Address CA&#x2F;动态地址配置</p>
<p>可自配置地址的ECU，是指那些根据内部计算确定它的源地址并自己声明该地址的ECU。如果可自配置地址的ECU在声明第⼀个计算出来的地址时失败，那么ECU会重新计算并声明另⼀地址。实现 ECU的“即插即用”，最大程度减少人工配置需求。ECU 自己负责在网络上找到⼀个不冲突的地址。</p>
<p>地址更改机制：</p>
<ul>
<li><p>ECU 启动时，检查其存储的 CA。</p>
</li>
<li><p>如果无效或冲突，它广播 Request for Address Claim (PGN 59904 &#x2F; 0xEA00) 或直接参与 Address Claim 过程。</p>
</li>
<li><p>在 Address Claim 过程中，ECU 广播其 NAME 和它希望使用的 CA（通常是之前存储的或⼀个默认值）。</p>
</li>
<li><p>如果发生冲突（有另⼀个 ECU 声明了相同 CA 且 NAME 优先级更高），该 ECU 会尝试选择另⼀个 CA，并重新声明，直到找到⼀个不冲突的 CA 或者尝试失败。</p>
</li>
<li><p>成功获取的 CA 会存储到 NVRAM 供下次使用。</p>
</li>
</ul>
</li>
</ul>
<p><strong><mark>关于地址</mark></strong></p>
<p>大部分基于 SAE J1939 网络的 ECU 都将拥有⼀个设置好的首选地址（参阅 SAE J1939， 表B2到B9），ECU 必须尝试首先使用。</p>
<h3 id="NAME"><a href="#NAME" class="headerlink" title="NAME"></a>NAME</h3><p>J1939定义了⼀套ECU命名方法，用于地址管理、网络出错管理等功能。</p>
<p>在J1939网络中，每个ECU都必须声明⼀个唯⼀的地址，以便其他节点能够准确地识别和与其通信。地址的声明过程涉及到在总线上广播声明消息，其中包含ECU的唯⼀地址。</p>
<p>地址声明消息包含⼀个源地址和⼀个NAME，可在网络中用于把⼀个NAME和⼀个特定的地址关联起来，也使地址和功能关联起来。</p>
<p>在 SAE J1939 网络中，传输消息的ECU需要⼀个NAME，作用有两个：</p>
<ul>
<li><p>为模块提供⼀个功能描述；</p>
</li>
<li><p>提供⼀个编号值用于地址仲裁(当ECU有出现使用相同地址时仲裁)。编号越小，优先级越高。</p>
</li>
</ul>
<p>从左到右的优先次序排列如下：</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013224404.png"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013224509.png"></p>
<table>
<thead>
<tr>
<th>NAME 域</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>仲裁地址能力域</td>
<td>这个 1 位的域表示⼀个 ECU是否可自配置地址，声明地址发生冲突时，可以在可仲裁的源地址（128~ 247）范围中选择⼀个地址将其声明为其源地址。如果这位被设为“1”，那么当该 ECU 与⼀个具有较高优先级（编号值较小）标称符的 ECU发生地址声明冲突时，它可以通过采用⼀个新的源地址来解决。如果⼀个 ECU 计算它的地址后，只能声明某个特定的地址，那么这个 ECU并不具有仲裁地址能力。</td>
</tr>
<tr>
<td>产业类群域</td>
<td>由SAE定义并分配的⼀个 3 位的域。其定义可以在 SAE J1939 基础文档的附录B.7 中找到。</td>
</tr>
<tr>
<td>汽车系统实例域</td>
<td>是⼀个 4 位的域，用来区别某汽车系统中的子系统，例如，0表示第⼀个子系统。注意，如果是网络中唯⼀⼀个或第⼀个特定的汽车系统域，则要把实例域置为零，以表示这是第⼀个实例。</td>
</tr>
<tr>
<td>汽车系统域</td>
<td>是由SAE定义和设置的⼀个 7 位的域，它和产业类群域组合起来， 可以和⼀个共用名相关联。这样，汽车系统域在网络中为⼀系列功能提供了共用名。</td>
</tr>
<tr>
<td>保留域</td>
<td>这是 SAE 为以后的定义保留的。保留位应置为零。</td>
</tr>
<tr>
<td>功能域</td>
<td>功能实例域是⼀个 5 位的域。表示⼀个具体的功能实例，例如，0表示第⼀个功能实例。</td>
</tr>
<tr>
<td>ECU实例域</td>
<td>是⼀个 3 位的域，它可以显示同特定功能域相关联的⼀组电子控制模块中哪⼀个被引用了。即用来区别相同功能域中的⼀组电控单元。例如，当两个分开的控制单元去控制同⼀台发动机时，每个控制单元都附属于相同的 SAE J1939 网络，这时对于第⼀个ECU，ECU 实例域的值设为0；对于第⼆个ECU, 设为1。注意，如果是网络中唯⼀⼀个或第⼀个特定的 ECU，则要把实例域置为零，以表示这是第⼀个实例。</td>
</tr>
<tr>
<td>制造商代码域</td>
<td>是⼀个 11 位的域，它可以显示哪⼀家公司对使用这种标称符的电子控制模块产品承担责任。制造商代码是由SAE设置的，并可以在 SAE J1939 基础文档中找到。</td>
</tr>
<tr>
<td>⾝份编号域</td>
<td>其值由ECU 制造商设置，当名字不唯⼀时，必须使用ID编号，这个域必须是唯⼀的，并且在断电的情况下保持不变。</td>
</tr>
</tbody></table>
<p>除了仲裁地址能力域以外，如果任⼀标称符域的数据不可知或不可用，那么该域将被设为⼆进制1，表示不可知或不可用。仲裁地址能力域应该被设置为适当的值。</p>
<h3 id="地址声明消息"><a href="#地址声明消息" class="headerlink" title="地址声明消息"></a>地址声明消息</h3><p>任何⼀种 ECU 都可以使用地址声明请求消息，来请求NAME，以及同一个网络下，其他ECU的地址。每个ECU都可以发送⼀个包含了它的地址和NAME的地址声明消息，来响应这个请求。如果 ECU 不能够声明地址，那它就会响应⼀条“不能声明地址”的消息。</p>
<p>还没有尝试声明地址的 ECU 要等到这个尝试声明地址为止，然后才能够参与网络通讯，才能够发送不能够声明地址消息或者其他任何的消息。</p>
<p>ECU 还可以通过向全局目标地址（255）发送地址声明请求并检验响应，从而确定在网络上其他正在工作的 ECU。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251013224648.png"></p>
]]></content>
      <categories>
        <category>汽车与工业网络</category>
      </categories>
      <tags>
        <tag>J1939</tag>
      </tags>
  </entry>
  <entry>
    <title>Keil 使用问题汇总</title>
    <url>/2023/Keil-Usage-12a1a959c43e/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>记录日常工作中使用Keil遇到的问题的解决方法。</p>
<h1 id="keil仿真相关"><a href="#keil仿真相关" class="headerlink" title="keil仿真相关"></a>keil仿真相关</h1><h2 id="添加芯片flash型号"><a href="#添加芯片flash型号" class="headerlink" title="添加芯片flash型号"></a>添加芯片flash型号</h2><p>在用仿真器烧录时，需要在flash download列表下，选择待烧写设备的芯片对应的flash型号。如果flash download添加列表中，没有我们要的芯片flash型号，则需要去官网下载相应系列的芯片包，如STM32F4xx_DFP。这里面会包含我们需要的FLM文件，将FLM文件复制到<code>keil安装路径\ARM\flash</code>目录下即可。</p>
<h2 id="烧录异常"><a href="#烧录异常" class="headerlink" title="烧录异常"></a>烧录异常</h2><p>在安装JLink驱动时，最后一步会检测本地电脑中，使用 JLinkARM.dll 的第三方应用程序，并提示是否要将它们使用的dll替换为当前安装的版本，详见下图。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812152342.png" alt="jLink.png"></p>
<p>如果错误的替换了dll，则可能导致第三方应用程序使用异常，比如：keil烧录、仿真异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The firmware of the connected J-link does not support the following memory access(Cannot load driver \ARM\Segger\JL2CM3.dll)。</span><br></pre></td></tr></table></figure>

<p>解决方法：进入<code>Keil安装目录下的\ARM\Segger</code>，将里面的JLinkARM.dll用合适的JLinkARM.dll替换即可。如：JLink驱动安装目录下，或者从其他正常使用keil的电脑，在同样的路径里面找到dll，复制出来替换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JLink Warning: Mis-aligned memory write: Address: 0x20000000, NumBytes: 2, Alignment: 2 (Halfword-aligned)</span><br></pre></td></tr></table></figure>

<p>这个是JL2CM3.dll的问题，把它换成其他版本的（版本不要过低），也可以安装MDK其他的低版本解决，或者同上一个问题一样复制替换。</p>
<h2 id="编译报错"><a href="#编译报错" class="headerlink" title="编译报错"></a>编译报错</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.\Output\Stm32_MCU_FBL.axf: error: L6050U: The code size of this image (42994 bytes) exceeds the maximum allowed for this version of the linker.</span><br></pre></td></tr></table></figure>

<p>原因是没有注册，还是试用版，对编译文件的大小有限制。解决方法：keil注册（破解）</p>
<h1 id="Keil工程相关"><a href="#Keil工程相关" class="headerlink" title="Keil工程相关"></a>Keil工程相关</h1><p>当电脑安装了Keil4与Keil5两个软件时，打开工程文件会默认选择Keil5打开，而用Keil4创建的工程，用keil5打开会崩溃。通过修改注册表可以实现，不同的工程文件类型用指定的Keil版本打开。即Keil4建立的工程用Keil4打开，Keil5建立的工程用Keil5打开。</p>
<p>打开注册表，展开<code>HKEY_CLASSER_ROOT</code>，找到<code>UVPROJFILE</code>目录（Keil4工程文件类型）和<code>UVPROJXFILE</code>目录（Keil5工程文件类型）。在右侧窗口双击名称下面的条目，出现编辑框后，将数值数据填写为对应的Keil应用程序路径即可。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812145104.png" alt="keil注册表.png"></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>之前遇到过一个问题，在win10环境下，Keil4启动时会有类型闪退的现象，卡在启动界面一段时间后会自动退出。调出任务管理器，查看程序的运行状态，发现启动时会自动被挂起。后续，安装高版本的keil4之后不再出现。</p>
]]></content>
      <categories>
        <category>嵌入式IDE</category>
      </categories>
      <tags>
        <tag>Keil</tag>
        <tag>JLink</tag>
      </tags>
  </entry>
  <entry>
    <title>PCAN 使用笔记</title>
    <url>/2023/PCAN-Usage-4b8805394c51/</url>
    <content><![CDATA[<h1 id="PCAN-Explorer回放报文"><a href="#PCAN-Explorer回放报文" class="headerlink" title="PCAN-Explorer回放报文"></a>PCAN-Explorer回放报文</h1><ol>
<li><p>打开工程，如何新建工程详见<a href="https://peak-system.com.cn/wp-content/uploads/2022/06/PCAN-Explorer6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.pdf">PCAN-Explorer6基本使用方法.pdf</a></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812204403.png" alt="工程文件.png"></p>
</li>
<li><p>添加连接，如何新建连接详见说明文档</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812204754.png" alt="添加连接.png"></p>
</li>
<li><p>导入DBC，双击打开，全选并Apply</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812204904.png" alt="导入DBC.png"></p>
</li>
<li><p>打开Plotter插件，并导入报文。Plotter插件中显示的是具体的信号值，所以在工程中必须有相应的解析文件如：sym、dbc，把CAN报文解析为具体的信号值才能正常把trc文件导入到Plotter插件。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812205653.png" alt="import from tracer.png"></p>
</li>
<li><p>选择信号。导入报文后选择要查看的信号，提供选择的信号是导入的报文所包含的信号，可以一次选择多个。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812210321.png" alt="选择信号.png"></p>
</li>
<li><p>调整样式</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812210420.png" alt="样式调整.png"></p>
</li>
<li><p>回放查看</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812210535.png" alt="报文查看.png"></p>
</li>
</ol>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p>PCAN-Explorer打开PCAN-View录制的trc格式报文，显示出来的内容为空；Plotter插件导入同一份报文，提示无信号。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812210836.png" alt="no signal.png"></p>
<p>原因为两者的文件版本不一致，解析错误。我用的PCAN-Explorer文件版本为1.3，PCAN-View文件版本为2.0。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812211812.png" alt="PCAN-Explorer Version.png"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812211826.png" alt="PCAN-View Version.png"></p>
<p>解决方法：使用PEAK-Converter，将PCAN-View导出的trc报文转为1.3版本，格式不变，这样可以继续导入到Plotter插件中，进行后续回放。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812212213.png" alt="Format.png"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230812212222.png" alt="Target Version.png"></p>
]]></content>
      <categories>
        <category>CAN总线工具</category>
      </categories>
      <tags>
        <tag>PCAN</tag>
      </tags>
  </entry>
  <entry>
    <title>S32DS 使用问题汇总</title>
    <url>/2023/S32DS-Usage-31bfab119a51/</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>记录日常工作中使用S32 Design Studio IDE遇到的问题的解决方法。问题大多比较久远，因此没有附图。</p>
<h1 id="S32DS安装"><a href="#S32DS安装" class="headerlink" title="S32DS安装"></a>S32DS安装</h1><h2 id="安装出错"><a href="#安装出错" class="headerlink" title="安装出错"></a>安装出错</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The installation of S32 Design Studio for ARM Version 2018.R1 has been rolle back</span><br></pre></td></tr></table></figure>

<p>原因：没有安装权限，以管理身份重新安装即可解决。</p>
<h2 id="离线激活"><a href="#离线激活" class="headerlink" title="离线激活"></a>离线激活</h2><ol>
<li><p>在官网下载需要的安装包，点击下载需要注册账号，根据提示注册即可。然后在下载界面找到License Keys，记录下Activation code，安装过程要用到；</p>
</li>
<li><p>安装过程会要求输入Activation code，激活类型选择offline。生成request.xml，然后将该文件上传到<a href="https://nxp.flexnetoperations.com/control/frse/offlineActivation">链接</a>，点击process生成activation.xml，通过安装指导上传activation.xml后，继续后续的安装。</p>
</li>
</ol>
<h1 id="S32DS仿真报错"><a href="#S32DS仿真报错" class="headerlink" title="S32DS仿真报错"></a>S32DS仿真报错</h1><h2 id="JLinkGDBServerCL-exe"><a href="#JLinkGDBServerCL-exe" class="headerlink" title="JLinkGDBServerCL.exe"></a>JLinkGDBServerCL.exe</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error in services launch sequence</span><br><span class="line">Launching command [C:/NXP/S32DS_ARM_v2.0/Drivers/Segger/JLinkGDBServerCL.exe -if swd -device S32K144 -endian little -speed auto -port 2331 -swoport 2332 -telnetport 2333 -vd -ir -localhostonly 1 -singlerun -strict -timeout 0 -nogui] failed.</span><br><span class="line">Cannot run program &quot;C:/NXP/S32DS_ARM_v2.0/Drivers/Segger/JLinkGDBServerCL.exe&quot;: Launching failed。</span><br></pre></td></tr></table></figure>

<p>从报错提示来看应该是JLinkGDBServerCL.exe出现错误了，查看之后发现本地并没有这个路径。</p>
<p>解决方法如下：进入S32DS对应的Debug配置界面，在executable设置中点击Variables，修改里面的<code>$&#123;jlink_path&#125;</code>（Path to J-Link installation folder），可以选择为S32DS安装路径下的<code>\Drivers\Segger\</code>路径，这样一来Launching command里面的可执行程序的路径就变为我们所设置的路径了。</p>
<h2 id="PEmicro-GDB-Launch-Failure"><a href="#PEmicro-GDB-Launch-Failure" class="headerlink" title="PEmicro GDB Launch Failure"></a>PEmicro GDB Launch Failure</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Another GDB Server debug session is alreadyusing the same Server Port number. To run simultaneous debug sessions, please specify a unique Server Port and GDBMI Port in the Debug Configuration for each project. If another session is not running simultaneously, make sure that the pegdbserver_console and the arm-none-eabi-gdb processes have terminated.</span><br></pre></td></tr></table></figure>

<p>解决如下：通过任务管理器，关闭pegdbserver_console.exe进程。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230811202451.png" alt="pegdb.png"></p>
<h2 id="J-Link-GDB-Server-failed"><a href="#J-Link-GDB-Server-failed" class="headerlink" title="J-Link GDB Server failed"></a>J-Link GDB Server failed</h2><p><img title="" src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230811203342.png" alt="could not connect to J-Link.png" width="329"><img title="" src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20230811203351.png" alt="could not connect to target.png" width="320"></p>
<p>出现这个问题原因有很多，包括但不限于：待烧录设备未供电、JLink未连接、待烧录设备芯片型号选择错误、S32DS安装目录下的Segger目录文件被替换。</p>
<h1 id="S32DS工程相关"><a href="#S32DS工程相关" class="headerlink" title="S32DS工程相关"></a>S32DS工程相关</h1><p>在切换不同项目时，我习惯先在Project Explorer框中，右键选中并删除当前项目的工程文件夹，然后，再右键导入工程来打开另外一个项目。在选择要导入的工程路径时，IDE会记忆之前选择过的路径，这样的话切换起来比较方便。但是，有些项目已经移动或者删除了，这样一来，这些路径就是无效的。但是，IDE的下拉框还是会显示这些无效的路径。于是，可以通过下面的方式，来修改历史选择过的路径。导入的工程路径保存在：<br><code>工作目录\.metadata\.plugins\org.eclipse.ui.ide\dialog_settings.xml</code></p>
<p>具体操作时，<strong>首先要退出S32DS软件</strong>，然后找到上面这个xml文件，修改文件内容，也就是删除不需要的路径。这样的话，下次重新启动S32DS时，下拉提示框显示的内容就会做出相应改变了。</p>
<p>顺便一提，每次切换工程后，建议先make clean，再make编译。</p>
]]></content>
      <categories>
        <category>嵌入式IDE</category>
      </categories>
      <tags>
        <tag>S32DS</tag>
      </tags>
  </entry>
  <entry>
    <title>spreadsheet compare 简单使用说明</title>
    <url>/2023/spreadsheet-compare-cf954b484b3c/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Office2013开始，Office家族增加了Spreadsheet Compare工具，使用这个工具可快速比较识别两个工作簿（或者同一个工作簿的不同版本）来查看不同工作簿之间的差异。Spreadsheet Compare是名符其实的Office官方出品的数据比对神器。</p>
<p>Beyond Compare 也可以用来对比表格差异，但是只能比较两个Excel的当前工作表，如果每个 Excel 文件中包含多个工作表时就会对比错误的情况，而 <code>Spreadsheet Compare</code> 在这一点上更加优秀，可以对比多个表格数据。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>打开两份需要比较Excel（注意：两份原文件一定要做备份，Spreadsheet Compare会修改当前文件。）</p>
<p>点击任意一个文件Exce菜单加载项</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20220220213550.png" alt="image20220220203635055"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20220220213603.png" alt="image20220220204055371"></p>
<h2 id="Compare-Type设置"><a href="#Compare-Type设置" class="headerlink" title="Compare Type设置"></a>Compare Type设置</h2><p>选择Database Style Compare，Primary KEY Colum选择可作为数据库内主键的列，否则对比的结果会有错乱。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20220220213609.png" alt="image20220220205530434"></p>
<p>设置Excel工作薄中需要比较的Sheet，两个文件均需要设置具体的Sheet，这边有两步，选择好之后点击Next。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20220220213612.png" alt="image20220220205827545"></p>
<h2 id="报告查看"><a href="#报告查看" class="headerlink" title="报告查看"></a>报告查看</h2><p>Report详细列出了两份文件的修改情况。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20220220213615.png" alt="image20220220211610710"></p>
<p>Merged Diffs则把两份合并在一起，列出其差异。同时工具也会修改原文件，把有差异的地方标红，两份文件并排在一起方便对比查看。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20220220213618.png" alt="image20220220212018465"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20220220213622.png" alt="image20220220213418872"></p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>其余选项的说明可以查看帮助文档</p>
]]></content>
      <categories>
        <category>Office</category>
      </categories>
      <tags>
        <tag>对比工具</tag>
      </tags>
  </entry>
  <entry>
    <title>使用拨号上网时，笔记本电脑无法打开热点的解决方法</title>
    <url>/2021/%E6%97%A0%E6%B3%95%E5%BC%80%E5%90%AF%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98-38d92260e969/</url>
    <content><![CDATA[<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>一般情况下，我们是可以正常使用笔记本电脑来开启热点的。但是，在使用拨号的方式上网时，热点无法正常开启。具体表现如下图所示，热点按钮无法点击。当然，你也可以买一个路由器达到曲线救国的目的。在这里，本文给出一种方法，在不用路由器的情况下(<del>绝对不是因为穷</del>😭)开启电脑热点，供其它设备正常连接使用。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20210809005435.png" alt="image-20210808225118370"></p>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ol>
<li>先不要拨号上网，如果连上了就先断开连接，然后手机开启热点</li>
<li>电脑连接手机开启的热点，这时电脑的热点按钮是可以点击开启的。我们开启电脑的热点功能，然后手机关掉热点（这里注意：是关闭手机的，电脑不要把热点关了）。完成之后，依次点击<code>网络和Internet设置--&gt;更改适配器选项</code>，我们可以看到有一个叫本地连接*2之类的适配器（后面的数字不重要），这个对应的就是电脑开启的热点。<br><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20210809005442.png" alt="image-20210808223329092"></li>
<li>电脑正常拨号上网，然后按照下图的操作，共享给上一步的本地连接*2即可。<br><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20210809005448.png" alt="image-20210808224205345"></li>
<li>以上的操作，网上已有不少的博客介绍了。但是，这里面存在一个问题，这样操作之后的电脑热点用不了多久就会自动关闭。我上网找了一下，没有相应的解决方法。下面本文将会给出一种解决方法，也算是有一点原创的内容了。</li>
</ol>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>通过上面设置后，电脑热点只能使用20分钟左右，就会自动关闭，并且无法通过右下角的任务栏来再次打开。</p>
<p>这里我猜测自动关闭是因为步骤2中，手机突然关闭了热点，但是电脑的热点功能还开启着（这时候其它的设备连上这个电脑热点也是无法上网的，因为手机的热点关闭了。当然，完成步骤3后是可以上网的，只不过会自动关闭），没有实时的对手机热点的关闭做出响应，会有一段时间的延迟，也就是20分钟左右，才会对手机热点的关闭做出响应，响应的具体表现就是电脑热点的自动关闭。</p>
<p><strong>解决方法</strong>就是完成上面的一系列操作后，进入热点的设置界面（图一中的热点按钮右键点击设置，即可打开），<mark>不要关闭这个界面</mark>，可以将界面最小化，一直等到热点自动关闭后，我们再点击这个热点设置界面的开启按钮即可。这样处理一次之后，电脑热点就会一直保持开启了，这个时候就可以关闭热点的设置界面了。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20210809005454.png" alt="image-20210809004547802"></p>
<p>当然，如果重启电脑的话，又得按照上面的步骤来一遍。虽说会有点繁琐，不过熟练操作以后，也花不了太多的时间。这里提一下，重启电脑后如果完成了上面的操作，手机连接上电脑的热点，提示<code>已连接，但无法访问互联网</code>，这时我们只需要将步骤3的宽带连接先取消共享（取消勾选），然后再次共享即可。</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>疑难杂症</tag>
      </tags>
  </entry>
  <entry>
    <title>CCS使用笔记</title>
    <url>/2025/prefix%20remember%20to%20change!!!-0d2b6ccd334f/</url>
    <content><![CDATA[<h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><p>TI 官方文档：<a href="https://software-dl.ti.com/ccs/esd/documents/users_guide_ccs_20.1.0/index.html">Code Composer Studio™ User Guide</a></p>
<h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><p><strong>CCS下载链接：</strong><a href="https://www.ti.com/tool/download/CCSTUDIO/20.1.0">CCSTUDIO IDE, configuration, compiler or debugger | TI.com</a></p>
<p><strong>SDK下载链接：</strong><a href="https://www.ti.com.cn/tool/cn/download/MCU-PLUS-SDK-AM62A">MCU-PLUS-SDK-AM62A 软件开发套件 (SDK) | 德州仪器 TI.com.cn</a></p>
<ul>
<li>SDK安装完成后，如果需要用CCS编译，则需要做如下配置：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016165912.png"></p>
<p><strong>SysConfig下载链接：</strong><a href="https://www.ti.com.cn/tool/cn/download/SYSCONFIG/1.20.0.3587">SYSCONFIG IDE、配置、编译器或调试器 | 德州仪器 TI.com.cn</a></p>
<p><strong>编译器下载链接：</strong><a href="https://www.ti.com/tool/download/ARM-CGT-CLANG/3.2.2.LTS">ARM-CGT-CLANG IDE, configuration, compiler or debugger | TI.com</a></p>
<p><strong>MCAL SDK：</strong></p>
<ol>
<li><p>使用以下链接申请</p>
<p><a href="https://www.ti.com/licreg/docs/swlicexportcontrol.tsp?form_id=337627&prod_no=PROCESSORSDK-MCAL-AM62X&ref_url=EP-Proc-Sitara-MPU">https://www.ti.com/licreg/docs/swlicexportcontrol.tsp?form_id=337627&amp;prod_no=PROCESSORSDK-MCAL-AM62X&amp;ref_url=EP-Proc-Sitara-MPU</a></p>
</li>
<li><p>获得批准后，从以下链接下载 MCAL SDK：</p>
<p><a href="https://www.ti.com/securesoftware/docs/autopagepreview.tsp?opnId=27760">https://www.ti.com/securesoftware/docs/autopagepreview.tsp?opnId=27760</a></p>
</li>
<li><p>文档</p>
<p><a href="https://software-dl.ti.com/mcu-plussdk/esd/PLATFORM_SW_MCAL/AM62Ax/09.00.00.01/mcusw_c_ug_top.html">https://software-dl.ti.com/mcu-plussdk/esd/PLATFORM_SW_MCAL/AM62Ax/09.00.00.01/mcusw_c_ug_top.html</a></p>
</li>
</ol>
<h1 id="CCT"><a href="#CCT" class="headerlink" title="CCT"></a>CCT</h1><p>CTT：Clock Tree Tool，适用于TI处理器的时钟树工具，直观的显示系统时钟。</p>
<p>根据用户定义的时钟源（晶振、PLL等）、分频系数、输出频率等参数，工具可自动生成时钟寄存器配置。</p>
<h2 id="在线使用"><a href="#在线使用" class="headerlink" title="在线使用"></a>在线使用</h2><p>TI官网上针对AM62AX的CCT工具是在线的：<a href="https://login.ti.com/as/authorization.oauth2?client_id=DCIT_ALL_LOGIN_CALLOUT&redirect_uri=https://auth.ti.com/davinci/oauth2/callback&response_type=code&state=c83e81af5f0a3fc11b3bc04088891eb635189b744e3294e9668b677ebf88d5b9&scope=openid%20profile%20email">Log in</a></p>
<p>其他在线工具：<a href="https://dev.ti.com/">TI Developer Zone</a></p>
<p>在线的CCT版本是1.1.4。</p>
<h2 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h2><p>在链接里面可以找到CCT的安装包：<a href="https://dev.ti.com/tirex/explore">TI Resource Explorer</a></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016170637.png"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016170655.png"></p>
<ol>
<li><p>解压下载好的压缩包</p>
</li>
<li><p>CCS里面需要导入CCT</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016170819.png"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016171023.png" title="" alt="" width="715"><strong>可能会有版本不匹配的问题，按照提示解决。</strong><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016171118.png"></p>
</li>
<li><p>找到sysconfig的安装路径，双击打开</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016171205.png"></p>
<p>按照如下配置，点击start，会创建cfg文件。save的时候会保存相关的寄存器配置文件。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016171238.png"></p>
</li>
</ol>
<h2 id="生成物"><a href="#生成物" class="headerlink" title="生成物"></a>生成物</h2><p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016171309.png"></p>
<p>生成文件说明</p>
<ul>
<li><p><code>.syscfg</code> 文件：是ClockTree生成的配置文件，可在TI的开发环境中导入使用(目前无法打开，会报错，可能和CCS 的版本有关系)。</p>
</li>
<li><p><code>.gel</code> 文件：是用于CCS的脚本文件，可在调试时加载，用于打印时钟寄存器值。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016171545.png"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016171604.png"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016171757.png"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016172103.png"></p>
<ul>
<li><p><code>.py</code> 文件：在Linux环境下，使用<code>k3conf</code>打印时钟寄存器值的Python文件。和gel作用一样，也是打印寄存器的值。打印的结果可以保存到txt，然后再导入CCT里面。</p>
</li>
<li><p><code> .rd1</code> 、<code>.rd2</code> 寄存器转储文件：记录寄存器的值，用于调试和验证配置是否正确。</p>
</li>
</ul>
<h1 id="编译报错"><a href="#编译报错" class="headerlink" title="编译报错"></a>编译报错</h1><h2 id="SDK和sysconfig版本不匹配报错"><a href="#SDK和sysconfig版本不匹配报错" class="headerlink" title="SDK和sysconfig版本不匹配报错"></a>SDK和sysconfig版本不匹配报错</h2><p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016172230.png"></p>
<p>sysconfig版本需要和SDK版本匹配，如果不匹配需要自己在TI官网下载并安装SDK以及sysconfig。 修改版本方法见下图，SDK和sysconfig设置方法一致。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016172257.png"></p>
<p>如果选择的版本不匹配，会有报错提示</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016172327.png"></p>
<h2 id="Norflash相关函数链接报错"><a href="#Norflash相关函数链接报错" class="headerlink" title="Norflash相关函数链接报错"></a>Norflash相关函数链接报错</h2><p>MCU R5F核添加了norflash驱动，据说是TI修改了SDK，改完的SDK用CCS去编译会出现如下错误：</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016172408.png"></p>
<p>从上面这个报错，可以推测有一些文件使用了其他C文件的函数，但是编译这个库的时候，没有包含对应文件去编译，导入我们自己的工程后，找不到对应的函数实现，导致链接报错。</p>
<p><mark>MCU+SDK v10.01已经解决了这个问题。</mark></p>
<h3 id="解决方法一：添加缺失的文件"><a href="#解决方法一：添加缺失的文件" class="headerlink" title="解决方法一：添加缺失的文件"></a>解决方法一：添加缺失的文件</h3><p>去SDK里面找到缺少的函数定义，找到对应的C文件，添加到我们自己的工程里面。</p>
<h3 id="解决方法二：切换成Release编译"><a href="#解决方法二：切换成Release编译" class="headerlink" title="解决方法二：切换成Release编译"></a>解决方法二：切换成Release编译</h3><p>用makefile编译是ok的，CCS编译不行，对比了一下发现makefile是Release的配置，用的库也是release，所以尝试把CCS改为Release，测试是可行的。</p>
<ol>
<li><p>选择Release</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016172616.png"></p>
</li>
<li><p>修改完后，发现没有添加对应的头文件，需要手动添加。修改工程文件，添加头文件路径如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//找到Release标签</span><br><span class="line"><span class="tag">&lt;<span class="name">cconfiguration</span></span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">&quot;com.ti.ccstudio.buildDefinitions.TMS470.Release.1770007231&quot;</span>&gt;</span></span><br><span class="line">//添加如下内容 主要就是头文件路径</span><br><span class="line"><span class="tag">&lt;<span class="name">listOptionValue</span> <span class="attr">builtIn</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">value</span>=<span class="string">&quot;$&#123;workspace_loc:/$&#123;ProjName&#125;/xxx/inc&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listOptionValue</span> <span class="attr">builtIn</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"><span class="attr">...</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag"></span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="fatal-error-‘xxx-h’-file-not-found"><a href="#fatal-error-‘xxx-h’-file-not-found" class="headerlink" title="fatal error: ‘xxx.h’ file not found"></a>fatal error: ‘xxx.h’ file not found</h2><p>前提：<code>xxx.c</code>包含了<code>xxx.h</code>文件。</p>
<p><strong>问题的根本原因</strong></p>
<p>在编译命令中，通过 <code>-I</code> 参数指定了多个头文件搜索路径，但这些路径中没有包含 <code>xxx.h</code> 的实际位置。</p>
<p><code>subdir_rules.mk</code> 的编译命令没有这个路径，因此，编译器无法自动搜索到 <code>xxx.h</code> ，导致报错。</p>
<p>解决方法：</p>
<ol>
<li>改为相对路径</li>
</ol>
<ul>
<li><p>相对路径是相对于当前源文件（ <code>xxx.c</code> ）的位置解析的。编译器会从<code>xxx.c </code>所在目录出发，按照相对路径找到 <code>xxx.h</code> 。</p>
</li>
<li><p>相对路径绕过了编译器默认的搜索路径机制，直接指定了文件的实际位置，因此不再依赖 <code>-I </code>参数。</p>
</li>
</ul>
<ol start="2">
<li>修改 .<code>cproject </code>文件</li>
</ol>
<p>由于 <code>subdir_rules.mk </code>是自动生成的，而且在项目配置中也添加了头文件路径，但是还是出现了这个错误。于是想到查看 <code>.cproject</code> 文件：</p>
<p>问题在于 <code>xxx.c </code>文件有一段单独的配置，但是这段配置没有包含对应的头文件路径。</p>
<ul>
<li><p>可以增加<code>xxx.h</code>实际所在的路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;listOptionValue builtIn=&quot;false&quot; value=&quot;$&#123;workspace_loc:/$&#123;ProjName&#125;/xxx/inc&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>或者直接把这个单独的配置整个删掉（推荐）</p>
</li>
</ul>
<h2 id="current-parser-token-‘include’-xxx-h"><a href="#current-parser-token-‘include’-xxx-h" class="headerlink" title="current parser token ‘include’ xxx.h"></a>current parser token ‘include’ xxx.h</h2><p>解决方法：再编译一次。</p>
<p>编译命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;D:\\ti\\ccs1240\\ccs\\utils\\bin\\gmake&quot; -k -j 16 all -O</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>-j 16 </code>是明确的并行编译标志，表示允许同时运行 16 个编译任务。</p>
</li>
<li><p><code>-O </code>选项表示输出同步（<code> --output-sync</code> ），确保不同线程的编译日志不会交错显示。</p>
</li>
</ul>
<p>可能的原因：</p>
<ol>
<li><p>首次编译：如果某些生成的代码（如 xxx.h ）尚未完成生成，而其他线程已经开始编译依赖它的文件（如 xxx.c ），会导致头文件缺失错误。</p>
</li>
<li><p>第⼆次编译：生成的文件已经存在（如 xxx.h ），竞态条件消失，编译成功。</p>
</li>
</ol>
<p><strong>降低并行度测试</strong></p>
<p>可以使用单线程编译验证是否为竞态问题，如果单线程编译始终成功，则可确认是并行竞态问题。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016173942.png"></p>
<h2 id="“-linker-cmd”-line-53-error-10099-D-program-will-not-fit-into-available-memory"><a href="#“-linker-cmd”-line-53-error-10099-D-program-will-not-fit-into-available-memory" class="headerlink" title="“..&#x2F;linker.cmd”, line 53: error #10099-D: program will not fit into available memory,"></a>“..&#x2F;linker.cmd”, line 53: error #10099-D: program will not fit into available memory,</h2><p>按照ti demo工程替换linker.cmd文件后，使用ccs编译报错，原因是内存不⾜。</p>
<p>查看map文件发现，ccs debug模式下，没有编译优化，编译出来的文件text段比较⼤。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016174057.png"></p>
<p>解决方法：可以和makefile文件使用相同的编译优化参数</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016174123.png"></p>
]]></content>
      <categories>
        <category>嵌入式IDE</category>
      </categories>
      <tags>
        <tag>Code Composer Studio</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Curl排查HTTP问题的经历</title>
    <url>/2025/prefix%20remember%20to%20change!!!-92342a72fd01/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我的核心职责是MCU侧的CAN总线开发。在联调过程中，Soc端需依赖一个专用Box来生成第三方算法的运行License。联调期间，该Box无法生成License，严重阻碍了联调进度。本文记录了本人协助Soc同事定位并解决此问题的全过程。</p>
<h1 id="Box策略分析"><a href="#Box策略分析" class="headerlink" title="Box策略分析"></a>Box策略分析</h1><blockquote>
<p>因为不清楚Box的策略，以下分析都是主观的，不⼀定准确。</p>
</blockquote>
<p>Box有⼀个默认的网址，用于查看当前的状态信息。这个网址内容数据来源于Box的固件，存储在Box的非易失性存储器中。当Box启动后，收到请求时，固件会加载相关文件，然后通过http协议传输内容给PC，使得我们可以在本地浏览器查看信息。</p>
<p>PC不联网也可以生成license，这是因为当通过网线连接PC和Box时，PC和Box之间形成了⼀个本地网络，数据访问和设置过程都是在本地网络内进行的，不需要互联网连接。</p>
<h1 id="http连接异常分析"><a href="#http连接异常分析" class="headerlink" title="http连接异常分析"></a>http连接异常分析</h1><p><strong>错误信息</strong></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">D:\share&gt;python .\main_create_license.py</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">&quot;D:\software\Python\lib\site-packages\urllib3\connection.py&quot;</span>, line</span><br><span class="line"><span class="number">207</span>, <span class="keyword">in</span> _new_conn</span><br><span class="line">socket_options=self.socket_options,</span><br><span class="line">File <span class="string">&quot;D:\software\Python\lib\site-packages\urllib3\util\connection.py&quot;</span>,</span><br><span class="line">line <span class="number">60</span>, <span class="keyword">in</span> create_connection</span><br><span class="line"><span class="keyword">for</span> res <span class="keyword">in</span> socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):</span><br><span class="line">File <span class="string">&quot;D:\software\Python\lib\socket.py&quot;</span>, line <span class="number">752</span>, <span class="keyword">in</span> getaddrinfo</span><br><span class="line"><span class="keyword">for</span> res <span class="keyword">in</span> _socket.getaddrinfo(host, port, family, <span class="built_in">type</span>, proto, flags):</span><br><span class="line">socket.gaierror: [Errno <span class="number">11001</span>] getaddrinfo failed</span><br></pre></td></tr></table></figure>

<p>根据错误信息， <code>socket.gaierror: [Errno 11001] getaddrinfo failed </code>这个错误⼀般是尝试解析主机名以获取地址信息时失败了。</p>
<p><strong>测试网络连接</strong></p>
<p>PC和Box，通过网线连接，Box对应网络适配器是<code>#2</code>，使用 <code>ipconfig</code> 查看Box的IP地址。</p>
<p>地址是可以ping通的，可以说明：</p>
<ol>
<li><p>设备能够通过网络到达目标地址，说明至少在网络层面上，设备和目标地址之间的路径是通的。</p>
</li>
<li><p>目标地址上的设备或服务处于开机状态，并响应了ICMP请求。</p>
</li>
<li><p>目标地址的防火墙和路由器配置允许ICMP包通过，没有被阻止。</p>
</li>
</ol>
<p>即使地址可以ping通，也不能保证所有的网络服务都能正常工作，因为ping命令通常只检测ICMP协议的响应。</p>
<p><strong>测试HTTP的连通性</strong></p>
<p>对于HTTP，因为”ping”不支持HTTP协议，可以通过以下方法来测试：</p>
<ol>
<li>使用浏览器访问： 直接在浏览器地址栏输入HTTP地址，如果服务器响应，说明是可访问的。(如下图)</li>
</ol>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016183351.png"></p>
<ol start="2">
<li><p>在命令行中，可以使用 <code>curl </code>命令来测试HTTP地址。例如： curl <a href="http://xxx.local:3000/">http://xxx.local:3000/</a> ，这将发送⼀个HTTP GET请求，并显示响应内容。(如下所示)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">C:\Users\uidq9792&gt;curl http://xxx.local:3000/</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">href</span>=<span class="string">&quot;/stylesheets/style.css&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="问题一：浏览器无法访问Box网址"><a href="#问题一：浏览器无法访问Box网址" class="headerlink" title="问题一：浏览器无法访问Box网址"></a>问题一：浏览器无法访问Box网址</h1><p>PC连接WiFi，浏览器无法访问Box网址，但<code>curl</code>可以获取到内容。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016183808.png"></p>
<p>这种情况http是通的，不影响license生成，不过也可以解决。从错误码<code>DNS_PROBE_FINISHED_NXDOMAIN </code>来看，是域名解析问题。</p>
<p><strong>方法⼀：</strong></p>
<p>修改hosts文件(需要权限)，绕过DNS解析。文件通常位于</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C:\Windows\System32\drivers\etc\</span><br></pre></td></tr></table></figure>

<p>如果域名对应的IP地址发生变化，需要手动更新 hosts 文件。</p>
<blockquote>
<p>hosts文件是⼀个系统文件，用于将域名映射到IP地址。这个文件主要用于将特定的域名与IP地址关联起来，使得计算机可以直接通过这个映射关系来访问网络资源，而不需要通过DNS服务器进行域名解析</p>
</blockquote>
<p><strong>方法⼆：</strong></p>
<p>断开PC的WiFi连接，然后重置适配器，刷新网页就行了。</p>
<h1 id="问题二：Curl-无法解析主机名"><a href="#问题二：Curl-无法解析主机名" class="headerlink" title="问题二：Curl 无法解析主机名"></a>问题二：Curl 无法解析主机名</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl: (6) Could not resolve host: xxx</span><br></pre></td></tr></table></figure>

<p>出现这种情况，可以右键对应的网络适配器，然后点击诊断，这个过程会重置适配器(不用关心诊断的结果)，然后重新执行curl命令，看是否可以获取到响应内容。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016184052.png"></p>
<p>当可以获取到响应内容时，执行license生成脚本，成功执行的结果如下：</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016184153.png"></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Curl</tag>
      </tags>
  </entry>
  <entry>
    <title>同星UDS刷写工程搭建</title>
    <url>/2025/prefix%20remember%20to%20change!!!-68598371f033/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前做的升级工程是基于CANoe的，但是CANoe工具数量有限，且价格昂贵，在没有CANoe的情况下，可以使用同星的自动诊断流程来升级ECU。SOC的同事也可以使用同星，自行验证升级的功能。</p>
<h1 id="同星UDS刷写工程搭建"><a href="#同星UDS刷写工程搭建" class="headerlink" title="同星UDS刷写工程搭建"></a>同星UDS刷写工程搭建</h1><h2 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h2><p>同星硬件配套的TSMaster软件：</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016214458.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.tosunai.com/tosun-ecu-diagnostic-flashing-solution-reduce-difficulty-developing-ecu-flashing-software-2/">解决方案 | 同星ECU诊断与刷写解决方案：降低了开发ECU刷写软件的难度！ - 上海同星智能科技有限公司</a></p>
<p>官方文档：<code>TSMaster的UDS刷写流程.pdf</code></p>
<h2 id="工程配置流程"><a href="#工程配置流程" class="headerlink" title="工程配置流程"></a>工程配置流程</h2><ol>
<li><p>创建一个UDS诊断和刷写工程。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016214802.png"><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016214822.png"><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016214852.png"></p>
</li>
<li><p>配置通道和波特率，这里不介绍。</p>
</li>
<li><p>导入DBC文件。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016214934.png"></p>
</li>
<li><p>增加必要的模拟发送报文（网络、点火、车速报文）。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016215212.png"></p>
</li>
<li><p>添加一个基础诊断模块，修改诊断传输层配置，主要是CANID。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016215348.png"></p>
<p>修改诊断服务层配置如下：</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016215426.png"></p>
</li>
<li><p>配置34，36，37组合服务。</p>
<p><strong>基本诊断配置提供组合服务，该服务能够根据加载的数据文件自动生成0x34,0x36,0x37服务步骤流程，支持加载多种主流的数据格式（hex，bin，s19，vbf），支持多种校验方式。</strong></p>
<p><strong>通用配置（校验和配置不用关注）</strong></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016222957.png"></p>
<p><strong>擦除flash配置</strong></p>
<p>可以不用配置，在自动诊断流程增加。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016215746.png"></p>
<p><strong>请求和传输数据配置</strong></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016215813.png"><strong>传输退出配置</strong></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016215851.png"></p>
</li>
<li><p>增加自动诊断流程</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016220125.png"><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016220246.png"></p>
</li>
</ol>
<h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><ol>
<li><p>支持文件格式（hex，bin，s19，vbf），不支持zip文件，但是可以手动修改待升级文件的扩展名，也就是把扩展名从zip改成bin。</p>
</li>
<li><p>启动流程的时候也要选择对应的流程。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016220653.png"><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016220749.png"></p>
</li>
</ol>
<p><mark>所有步骤都按照预期回复的话，会显示绿色，如果有异常会显示红色&#x2F;⻩色。</mark></p>
<p>下面是一个升级成功的截图：</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016221034.png"></p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><mark>报错：”从系统变量转化为字节数组失败”。</mark></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016221240.png"></p>
<p><mark>原因：出现这个报错是因为没有识别到升级文件。</mark></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016221344.png"></p>
<p>正常识别到升级文件，是会显示文件名的。如下图：</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016221459.png"></p>
<p>解决方法：重新配置（需要先解锁编辑器），然后选择需要的组合服务，如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016221844.png"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016220246.png"></p>
]]></content>
      <categories>
        <category>CAN总线工具</category>
      </categories>
      <tags>
        <tag>TSMaster</tag>
      </tags>
  </entry>
  <entry>
    <title>报文回放</title>
    <url>/2025/prefix%20remember%20to%20change!!!-76f0d30e8b43/</url>
    <content><![CDATA[<h1 id="在线回放"><a href="#在线回放" class="headerlink" title="在线回放"></a>在线回放</h1><p><strong>为什么需要在线回放报文？</strong></p>
<ol>
<li><p>复现问题场景</p>
<p>在网络通信系统（如CAN总线）中，某些问题可能只在特定的报文交互场景下才会出现。通过在线回放报文，可以将之前记录的报文重新发送到总线上，从而精确地复现问题发生的场景，便于定位和解决问题。</p>
<p>例如，某些偶现的故障可能与特定的报文序列有关，通过在线回放可以重现这些报文序列，帮助快速找到问题。因为偶发性故障很难在实时环境中捕捉，通过在线回放报文，可以在离线环境中反复重现故障场景，从而更高效地排查问题。</p>
</li>
<li><p>模拟真实网络环境</p>
<p>在线回放报文可以模拟真实的网络通信环境，包括报文的发送时间间隔、报文内容等。支持基于时间戳的报文发送，可以按照实际记录的时间顺序和间隔发送报文，从而更真实地模拟真实环境。这对于测试网络设备、协议栈或软件在实际运行中的表现非常重要。</p>
<p>例如，通过在线回放可以模拟高负载的网络环境，测试系统在极端条件下的稳定性和性能。</p>
</li>
<li><p>优化开发和测试流程</p>
<p>在线回放提供了一种灵活的测试手段，可以快速切换不同的报文序列和测试场景，减少测试准备时间。</p>
<p>例如，通过脚本和通道映射功能，可以灵活地选择需要回放的报文和发送通道，甚⾄可以屏蔽某些不需要的报文。</p>
</li>
</ol>
<p><strong>如何在线回放报文？</strong></p>
<ol>
<li><p>以同星工具为例，打开同星工程，找到总线回放的选项卡，选择在线回放。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016223753.png"></p>
</li>
<li><p>选择要回放的文件。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016223819.png"></p>
</li>
<li><p>报文回放设置。</p>
<p>根据需要修改配置，下图只是一个示例配置（只修改了红框的配置，其他都是默认的）。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016224008.png"></p>
</li>
<li><p>开始回放。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016224300.png"><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016224318.png"></p>
</li>
</ol>
<p><strong>关于通道映射</strong></p>
<p>我的工程只用了一个通道，如果是台架测试的报文，默认也是通道1，所以通道映射不用修改。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016224107.png"></p>
<p>如果要回放实车报文，需要知道ECU所在的通道，假设ECU所在通道是通道8，就需要将通道8映射到通道1。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016224209.png"></p>
<h1 id="离线回放"><a href="#离线回放" class="headerlink" title="离线回放"></a>离线回放</h1><p>以CANoe工具为例，其他工具的方法大同小异。</p>
<ol>
<li><p>导入DBC文件。</p>
<p>DBC文件是用于描述和解释车辆中CAN网络上传输的数据的数据库文件。主要用来做数据解析：DBC文件包含有关CAN总线上各个信号的信息，例如每个信号的比特位置、长度、比例因子、偏移量等。这些信息使得接收报文的电子控制单元（ECU）或分析人员能够理解报文中的各个数据位代表的物理或逻辑含义。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016224556.png"></p>
</li>
<li><p>导入要回放的文件。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016224654.png"></p>
</li>
<li><p>确定CAN报文中，我们要看的是哪个通道的报文。</p>
<p>可以根据ECU的网络管理报文确认通道，先点start运行，在Trace窗口过滤网络报文ID。确认通道后，要在simulation里面设置，确保通道一致。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016224846.png"></p>
</li>
<li><p>添加想要分析的信号，添加完后，再点一次Start运行。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016225144.png"></p>
</li>
<li><p>设置图形样式，方便查看。按照个人习惯设置即可，一般设置如下：</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016225222.png"></p>
<p>1：选中，用来显示信号图例。</p>
<p>2&#x2F;3：设置光标。</p>
<p>4：不选择，关掉。</p>
<p>5：Start运行后，选择Fit All Signals Y。</p>
<p>6：选择Show Signals in Separate Diagrams（分离显示）。</p>
<p>7：如下图，网格，采样点，纵坐标，都打开。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016225250.png"></p>
</li>
</ol>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>CAN报文时间查看方式：</p>
<ol>
<li><p>在Graphics窗口里面配置；<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016225605.png"></p>
</li>
<li><p>查看时间报文。一般会有ECU节点发送时间报文，时间数据可能来源于GPS，如果没有GPS，则数据不准确。注意：如果是UTC时间，小时的数据会存在相差8小时的情况。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016225731.png"></p>
</li>
</ol>
<h1 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h1><p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251016225440.png"></p>
<p>如果导入回放文件出现上面这种红色感叹号的图标，那么有可能回放出来的报文，在Trace窗口什么都看不到，但是把文件拖拽到Trace窗口又是有报文的。而且，用notepad++打开也是有数据的。这种情况把文件拖拽到Trace窗口，然后右键export，重新导出asc&#x2F;blf格式，然后保存。再用这个新保存的文件去回放就可以了。</p>
]]></content>
      <categories>
        <category>CAN总线工具</category>
      </categories>
      <tags>
        <tag>报文分析与回放</tag>
      </tags>
  </entry>
  <entry>
    <title>ASPICE文档编写笔记</title>
    <url>/2025/prefix%20remember%20to%20change!!!-728c68a67aa9/</url>
    <content><![CDATA[<h1 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h1><p>在软件工程中，有如下的术语定义和关系：</p>
<p><strong>软件单元（Software Unit）</strong>：软件单元是最小的功能单元，通常由一个或几个源代码文件组成。它是系统中最小的测试和维护单元，通常可以单独编译和测试。软件单元在某些上下文中也可以指具体的类、函数、或方法等。</p>
<p><strong>组件（Component）</strong>：组件是由多个软件单元组成的功能模块。组件可以是一个较大的、具有独立功能的软件部分，通常包含多个软件单元。组件可以被多个系统或子系统复用，并且有定义良好的接口与其他组件进行交互。</p>
<p><strong>子系统（Subsystem）</strong>：子系统是由多个组件组成的较大功能模块，通常代表系统中的一个主要功能区域。子系统将组件组织起来，提供更高级别的功能和服务，并可能包括多个组件之间的协作。</p>
<p><strong>模块（Module）</strong>：模块是一个广泛使用的术语，通常指软件系统中的一个独立功能部分，可以是软件单元、组件、子系统等的集合。模块通常用于描述系统的结构和组织，关注于如何将系统分解为多个部分以便于管理和维护。</p>
<p><strong>关系总结：</strong></p>
<ul>
<li><p>软件单元是最小的构建块。</p>
</li>
<li><p>组件由一个或多个软件单元组成。</p>
</li>
<li><p>子系统由多个组件组成。</p>
</li>
<li><p>模块可以是软件单元、组件、子系统等的集合，作为系统的一个功能区块来考虑。</p>
</li>
</ul>
<p>这些术语在不同的上下文中可能会有不同的具体含义，但通常它们都围绕着软件系统的组织和结构进行描述。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017213628.png"></p>
<h1 id="软件需求"><a href="#软件需求" class="headerlink" title="软件需求"></a>软件需求</h1><p>软件需求通常可以分为以下几类：</p>
<p><strong>功能性需求（Functional Requirements）</strong>：描述系统应该执行的功能或服务，包括输入、处理和输出。它们定义了系统应如何响应特定输入或条件。</p>
<p><strong>非功能性需求（Non-Functional Requirements）</strong>：描述系统的性能标准和质量属性，包括：</p>
<ul>
<li><p>性能需求：响应时间、吞吐量等。</p>
</li>
<li><p>安全性需求：数据加密、用户认证等。</p>
</li>
<li><p>可用性需求：系统的可用性和可靠性。</p>
</li>
<li><p>可维护性需求：系统的可维护性和可扩展性。</p>
</li>
</ul>
<p><strong>接口需求（Interface Requirements）</strong>：描述系统与其他系统或组件之间的交互要求，包括API、用户界面和外部系统的通信协议等。</p>
<p><strong>系统需求（System Requirements）</strong>：描述系统内部和外部的需求，包括硬件、软件和网络环境的需求。</p>
<p><strong>约束需求（Constraint Requirements）</strong>：描述在开发和实现过程中需要遵循的限制条件，如法律法规、标准和技术限制。</p>
<p><strong>用户需求（User Requirements）</strong>：描述用户的期望和需求，包括用户体验和交互流程。关注最终用户的需求和使用场景。</p>
<p><strong>业务需求（Business Requirements）</strong>：描述对软件系统的高层期望和目标，通常与商业价值和战略目标相关。</p>
<h1 id="SW-RD"><a href="#SW-RD" class="headerlink" title="SW RD"></a>SW RD</h1><p>软件需求分析，该过程的目的是：将系统需求中与软件相关的部分转化为一组软件需求。</p>
<ol>
<li><p><strong>需求分析</strong>：首先，需要对系统的功能和非功能需求进行彻底分析。这包括理解用户需求和期望，以及分析需求的可行性、正确性、可验证性和对运行环境的影响 。</p>
</li>
<li><p><strong>需求结构化</strong>：将需求进行结构化，以便于管理和跟踪。这包括将需求分类和分组，以及建立需求的层次结构 。</p>
</li>
</ol>
<hr>
<p><strong>定义需求</strong>：在需求分析的基础上，明确和定义软件需求。这包括需求的详细描述、优先级和需求之间的依赖关系 。</p>
<ul>
<li><p>描述需求：</p>
<ul>
<li><p>对每个需求进行详细描述，包括需求编号、需求名称、需求描述、验收标准等。</p>
</li>
<li><p>确保需求是明确、可测试、可追踪的，并且符合SMART原则（具体的、可测量的、可实现的、相关的、有时限的）。</p>
</li>
</ul>
</li>
<li><p>定义功能需求：描述系统应具备的具体功能，包括每个功能的输入、处理和输出。</p>
</li>
<li><p>定义非功能需求：说明性能、可靠性、兼容性、安全性、可维护性、可扩展性等方面的需求。</p>
</li>
<li><p>编写接口需求：描述系统与其他系统或组件之间的接口，包括数据交换格式、通信协议等。</p>
</li>
</ul>
<p><strong>文档管理</strong>：确保文档版本控制，记录修改历史。</p>
<hr>
<ol>
<li><p><strong>需求追溯性</strong>：确保需求具有双向可追溯性，建立系统需求与软件需求之间的双向追溯性，建立系统架构设计与软件需求之间的双向追溯性。即从需求到设计、实现和测试的可追溯性，以及从这些活动回溯到需求的能力。</p>
</li>
<li><p><strong>需求评审</strong>：组织需求评审会议，邀请相关利益相关者参与，确保需求的明确性和无歧义性，并收集反馈进行需求的迭代和改进 。</p>
</li>
<li><p><strong>需求管理计划</strong>：制定需求管理计划，包括需求变更的控制流程、需求状态跟踪和需求的版本控制 。</p>
</li>
<li><p><strong>持续监控和维护</strong>：在软件开发过程中持续监控需求的状态，对需求变更进行管理，并根据需要更新需求文档。</p>
</li>
</ol>
<h1 id="SW-AD"><a href="#SW-AD" class="headerlink" title="SW AD"></a>SW AD</h1><p>软件架构设计，该过程的目的是：建立软件架构设计，识别将哪些软件需求分配给软件的哪些组件，并依照定义的准则来评估软件架构设计。</p>
<ol>
<li><p><strong>需求分析</strong>：了解系统需求和软件需求。</p>
</li>
<li><p><strong>高层架构设计</strong>：描述系统的总体架构，定义系统的子系统&#x2F;主要模块及其之间的交互和依赖关系。</p>
</li>
<li><p><strong>设计决策</strong>：记录架构设计中的关键决策和选择，论述并比较系统中使用的重要技术方案，分析其优缺点。</p>
</li>
<li><p><strong>定义软件架构目标</strong>：明确软件架构设计的目标和约束条件，以及需要满足的关键质量属性（如性能、可维护性、可扩展性等）。</p>
</li>
</ol>
<hr>
<p><strong>子系统&#x2F;模块架构设计</strong>：详细描述子系统&#x2F;模块的内部结构(组件)及其交互方式。</p>
<p><strong>组件定义和描述</strong>：定义并详细描述每个组件的功能和相互关系。</p>
<p><strong>分配软件需求</strong>：将软件需求分配到子系统&#x2F;模块架构设计的组件。</p>
<p><strong>接口定义</strong>：定义组件之间的接口，包括接口功能、输入&#x2F;输出数据(参数和返回值)和通信协议。</p>
<p><strong>描述动态行为</strong>：展示组件间的时序和动态交互，以满足系统所需的动态行为。 动态行为取决于运行模式（例如：启动、关机、正常模式、标定、诊断等）、进程及进程间相互通信、任务、线程、时间片、中断等。</p>
<p><strong>定义资源消耗目标</strong>：资源消耗如：内存(ROM、RAM、外部内部 EEPROM 或 数据闪存）、CPU 负载等。</p>
<hr>
<ol>
<li><p><strong>溯源</strong>：建立软件需求与软件架构设计要素之间的双向可追溯性。</p>
</li>
<li><p><strong>评审</strong>：对架构设计进行内部评审，确保设计符合需求和标准。</p>
</li>
<li><p><strong>文档修订</strong>：根据评审反馈修订文档，完善设计细节。</p>
</li>
<li><p><strong>发布与维护</strong>：发布最终版本的文档，并确保文档在软件开发过程中的持续更新和维护。</p>
</li>
</ol>
<h1 id="SW-DD"><a href="#SW-DD" class="headerlink" title="SW DD"></a>SW DD</h1><p>软件详细设计和单元构建，该过程的目的是：为软件组件提供经过评估的详细设计，并定义和生成软件单元。</p>
<ol>
<li><p><strong>理解需求和架构设计</strong>：在开始详细设计之前，需要对软件的需求有深入的理解，并分析系统架构设计，确保详细设计能够满足这些需求 。</p>
</li>
<li><p><strong>定义软件单元</strong>：根据软件架构设计划分的组件，并进一步将组件划分为可以独立开发和测试的软件单元 。</p>
</li>
</ol>
<hr>
<p><strong>设计概述</strong>：简要描述组件功能，设计方针。</p>
<p><strong>开发详细设计</strong>：具体说明<strong>组件</strong>的内部设计，包括软件单元的接口、数据结构、内部逻辑以及与其他单元的交互等（<mark>每个组件的详细设计都如此，设计完一个组件就继续设计下一个</mark>）</p>
<ul>
<li><p>每个软件<strong>单元</strong>的功能描述</p>
</li>
<li><p>每个软件<strong>单元</strong>的接口设计（包括数据结构、算法和流程图）</p>
<ul>
<li><p>设计外部接口（单元之间的接口也是）</p>
</li>
<li><p>设计内部接口（只在单元内使用的接口）</p>
</li>
</ul>
</li>
<li><p>动态行为</p>
<ul>
<li><p>外部接口：描述软件组件和其他组件的处理时序，如果AD有明确清晰设计，则省略。</p>
</li>
<li><p>内部接口：描述软件<strong>单元之间</strong>的动态行为和交互，使用时序图、状态迁移图等来展示。</p>
</li>
</ul>
</li>
<li><p>状态机图（如适用）</p>
</li>
<li><p>错误处理机制</p>
</li>
</ul>
<p><strong>明确非功能需求</strong>：如性能、资源消耗、安全性等。</p>
<p><strong>评价软件详细设计</strong>：从互操作性、交互、关键性、技术复杂性、风险和可测试性等方面对软件详细设计进行评价 。</p>
<hr>
<ol>
<li><p><strong>溯源</strong>：建立软件需求与软件单元之间的双向可追溯性。建立软件架构设计与软件详细设计之间的双向可追溯性。</p>
</li>
<li><p><strong>评审&#x2F;发布等</strong>：同RD&#x2F;AD。</p>
</li>
</ol>
<h1 id="SW-UT"><a href="#SW-UT" class="headerlink" title="SW UT"></a>SW UT</h1><p>软件单元验证，该过程的目的是：验证软件单元，以提供软件单元符合软件详细设计和非功能性软件需求的证据。</p>
<p>需要对DD文档中的所有 <code>modify/new</code> 函数做单元测试。</p>
<p>输出物：UTS–&gt;UT code –&gt;UTR。</p>
<p><strong>UTS</strong></p>
<p>UTS是做单元验证的指导书，通过UTS可以确定如何做单元测试，需要多少个测试case。</p>
<p>根据函数的圈复杂度来确定被测函数需要多少个测试case，测试case总是要大于等于圈复杂度。</p>
<p><strong>UT code</strong></p>
<p>做单元测试的测试代码。可以使用<code>tessy</code>或<code>googletest</code>进行验证。</p>
<p><strong>UTR</strong></p>
<p>单元测试报告，将测试结果补充到UTS中就是UTR。</p>
<h1 id="SW-IT"><a href="#SW-IT" class="headerlink" title="SW IT"></a>SW IT</h1><p>软件集成及集成测试的核心目的是：通过逐步将软件单元组合成更大的功能模块，最终形成符合架构设计的完整系统，同时在集成过程中对各组件间的接口及整体功能进行验证，确保系统实现与设计规范（特别是模块间接口）的高度一致性。</p>
<h1 id="文档发布流程"><a href="#文档发布流程" class="headerlink" title="文档发布流程"></a>文档发布流程</h1><p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017214234.png"></p>
<h1 id="溯源"><a href="#溯源" class="headerlink" title="溯源"></a>溯源</h1><p>溯源需在文档评审前完成，评审时需要关注上下游溯源和一致性。</p>
<p>溯源需输出溯源报告，未溯源的要分析原因并备注原因。</p>
]]></content>
      <categories>
        <category>ASPICE</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>LIN总线介绍</title>
    <url>/2025/prefix%20remember%20to%20change!!!-bf0b42ffbba4/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>LIN（Local Interconnect Network）总线是在汽车内广泛应用的串行通信协议，它的第一个完整版本 V1.3 发布于 2002 年，在 2016 年LIN总线被正式列为国际标准（ISO 17987）。</p>
<p>LIN总线是针对汽车分布式电子系统而定义的一种低成本的低速串行通讯网络，是对控制器区域网络(CAN)等其它汽车多路网络的一种补充，适用于对网络的带宽、性能或容错功能没有过高要求的应用。</p>
<p>LIN适用于节点数目小于等于 16 个，数据速率 20Kbps 以内的应用场合。</p>
<p>LIN总线相对于CAN的成本节省主要是由于采用单线传输、硅片中硬件或软件的低实现成本和无需在从属节点中使用石英或陶瓷谐振器。这些优点是以较低的带宽和受局限的单宿主总线访问方法为代价的。</p>
<p>LIN总线是基于SCI(UART)数据格式，采用单主控制器&#x2F;多从设备的模式，是UART中的一种特殊情况。</p>
<p>LIN总线上的所有通讯都由主机节点中的主机任务发起，主机任务根据调度表来确定当前的通讯内容，发送相应的帧头，并为报文帧分配帧通道。总线上的从机节点接收帧头之后，通过解读标识符来确定自己是否应该对当前通讯做出响应、做出何种响应。基于这种报文滤波方式，LIN可实现多种数据传输模式，且一个报文帧可以同时被多个节点接收利用。</p>
<h1 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h1><p>开发流程中的核心组件为描述网络特征的 LDF（LIN Description File），LDF定义LIN网络的所有通信特征，通信主机基于LDF可以自动生成通信过程的所有软件组件。同时，LDF可以为测试测量工具提供分析LIN网络所必须的信息。</p>
<p>LIN Configuration Language Specification 定义了创建LDF的过程，创建语法相当简单，可以手动或通过软件工具自动生成LDF。</p>
<p>自 LIN V2.0 规范起，增补的节点统一描述语言可以清晰地说明商用节点（Off-the-Shelf Nodes）设备的通信特征，通过这种 LIN Node Capability Language 描述的节点特征文件称 NCF（Node Capability File），而LIN子网（Cluster）中所有节点NCF正是创建系统LDF的必要条件。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017221518.png"></p>
<h1 id="特点和任务"><a href="#特点和任务" class="headerlink" title="特点和任务"></a>特点和任务</h1><p>LIN总线有如下特点：</p>
<ol>
<li><p>单主控器&#x2F;多从设备模式无需仲裁机制；</p>
</li>
<li><p>低成本，基于通用UART 接口，所有控制机都具备LIN 必需的硬件；</p>
</li>
<li><p>单信号线传输，同时保证信号传输的延迟时间；</p>
</li>
<li><p>LIN具有可预测的电磁兼容性能，为了限制EMC的强度，LIN协议规定最大传输速率为20kbps；</p>
</li>
<li><p>LIN总线提供信号的配置、处理、识别和诊断功能。</p>
</li>
</ol>
<p><strong>主机任务：</strong></p>
<ol>
<li><p>调度总线上帧的传输次序；</p>
</li>
<li><p>监测数据，处理错误；</p>
</li>
<li><p>作为标准时钟参考；</p>
</li>
<li><p>接收从机节点发出的总线唤醒命令；</p>
</li>
<li><p>从机任务不能直接向总线发送数据，需要接受到主节点发送的帧头后，根据帧头所包含的信息来判断。</p>
</li>
</ol>
<p><strong>从机任务</strong>：发送应答，接收应答，忽略应答。</p>
<h1 id="网络拓扑"><a href="#网络拓扑" class="headerlink" title="网络拓扑"></a>网络拓扑</h1><p>LIN总线有其“局域”特性，在汽车中一般不独立存在，通常与上层CAN网络相连，形成CAN-LIN网关节点，通常汽车电子中，整车厂会规定该“网关节点”(主机节点)的控制器归属。</p>
<p>LIN总线拓扑通常为线型，即所有节点设备均通过单线连在一起。主机包括主机任务（Master Task）和从机任务（Slave Task），从机节点只包括从机任务。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017221616.png"></p>
<p>在LIN总线上，主机控制子网内每条消息的传输过程，这种总线访问方式称为授权令牌（Delegated Token）。授权令牌方式的优点是它可以避免消息传输过程的冲突竞争，因为完全由主机协调控制每条消息的应答请求。</p>
<p>LIN总线主机可以根据预设好的调度表（Schedule）规划总线上的数据传输。授权令牌总线访问方式因此被归类为确定性总线访问方式。</p>
<p>授权令牌访问方式的缺点有两点：首先，如果主机失效，则整个总线通信随即失效，因此该方式不适合安全要求高的应用；其次，由于每次通信过程均由主机控制，该方式不适合事件驱动型通信，从机无法自动获取总线访问权以发送数据。为弥补这点缺憾，LIN协议中增补额外的帧类型可以不按授权令牌方式发送消息。</p>
<h1 id="LIN报文帧结构"><a href="#LIN报文帧结构" class="headerlink" title="LIN报文帧结构"></a>LIN报文帧结构</h1><p>LIN报文帧由帧头（Hearder）与应答（Response）两部分组成。传输过程中，主机任务负责发送帧头；从机任务负责接收帧头，然后作出解析决定发送应答，还是接收应答或不回复。</p>
<p><mark>LIN总线显隐性与CAN总线是相同的。</mark></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017221658.png"></p>
<h2 id="同步间隔段"><a href="#同步间隔段" class="headerlink" title="同步间隔段"></a>同步间隔段</h2><p>同步间隔段（Sync Break Field）由同步间隔和同步间隔段间隔符构成，同步间隔是至少持续 13 位（以主机节点的位速率为准）的显性电平，由于帧中的所有间隔或总线空闲时都应保持隐性电平，并且帧中的任何其它字段都不会发出大于 9 位的显性电平，因此同步间隔可以标志一个帧的开始。</p>
<p>同步间隔段的间隔符是至少持续 1 位的隐性电平。</p>
<p>从机任务接收帧头的同步间隔段时，以该从机任务所在节点的位速率为准，当检测总线上出现持续 11 位的显性电平时，认为是帧的开始。当从机节点使用精度较高的时钟时，识别阈值可以选择 9.5 位。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017221730.png"></p>
<h2 id="同步段"><a href="#同步段" class="headerlink" title="同步段"></a>同步段</h2><p>在介绍同步段之前，首先介绍一下字节域(Byte Field)的概念，字节域包括1位起始位(Start Bit，显性) + 8位数据位 + 1位停止位(Stop Bit，隐性)，，这是一种标准UART数据传输格式。在 LIN 的一帧当中，除了同步间隔段，后面的各段都是通过字节域的格式传输的。</p>
<p>在 LIN 帧中，数据传输都是先发送LSB，最后发送 MSB。</p>
<p>LIN总线将下降沿作为判断标志，通过字节0x55（01010101b）进行同步，在从机节点上可以采用非高精度时钟，如果带来偏差，可以通过同步场来调整。</p>
<h2 id="PID段"><a href="#PID段" class="headerlink" title="PID段"></a>PID段</h2><p>受保护的ID，其前6位为帧ID(依据节点LDF生成)，加上两个奇偶效验码称作受保护的ID。</p>
<p>帧ID的取值范围为0x00~0x3F，共64个，帧ID标识了帧的类别和目的地，从机任务会根据帧头ID作出反应(接收&#x2F;发送&#x2F;忽略应答)，其中P0与P1效验如下：</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017221800.png"></p>
<p>其中“⊕”代表“异或”运算，“¬”代表“取非”运算。由公式可以看出，PID 不会出现全 0 或全 1 的情况，因此，如果从机节点收到了“0xFF”或“0x00”，可判断传输错误。</p>
<h2 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h2><p>包含1-8个字节，可以分为两种数据类型，信号和诊断消息。信号由信号携带帧传递，诊断消息由诊断帧传递。</p>
<p>LIN2.x规定可传输的LIN字节数为2，4，8，并不是1-8内任意一个数字。一般而言，车内会选择统一字节数，最常用的是每帧传递8个字节。</p>
<p>与CAN总线不同，LIN协议中并没有规定数据长度的信息，数据内容和长度均由系统设计者根据帧ID提前设定。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017221833.png"></p>
<h2 id="校验和段"><a href="#校验和段" class="headerlink" title="校验和段"></a>校验和段</h2><p>效验分为标准型效验与增强型效验。采用标准型还是增强型是由主机节点管理，发布节点和收听节点根据帧ID来判断采用哪种效验和。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017221859.png"></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017221916.png"></p>
<h1 id="帧类型"><a href="#帧类型" class="headerlink" title="帧类型"></a>帧类型</h1><p>LIN总线根据帧ID的不同，将报文分为信号携带帧、诊断帧、保留帧。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017221944.png"></p>
<p><mark>从机应答帧是一个完整的帧，与帧结构中的“应答”不是一个概念。</mark></p>
<ol>
<li><p>无条件帧</p>
<p>无条件帧是具有单一发布节点的，无论信号是否发生变化，帧头均会被无条件应答的帧。无条件帧在主机任务分配给它的固定的帧时隙（Reserved Frame Slot）中传输。总线上一旦有帧头发送出去，必须有从机任务作应答(即无条件发送应答)。</p>
</li>
<li><p>事件触发帧</p>
<p>事件触发帧是主机节点在一个帧间隙中，<mark>主机查询</mark>各从机节点的信号是否发生变化时使用的帧。当从机节点信号发生变化的频率较低时，主机任务查询各个节点信息会占用一定的带宽。为了减小带宽的占用，引入了事件触发帧的概念。</p>
<p>其主要原理就是：</p>
<p>当从机节点信息状态没有发生变化的时候，从机节点可以不应答主机发出的帧头；当有多个节点信息同时发生变化的时候，同时应答事件触发帧头会造成总线的冲突。当主机节点检测到冲突时，便会执行冲突解决调度表，通过发送无条件帧轮询所有从机来确定从机节点的信息状态。</p>
<p>因为无条件帧只有1个节点应答，同一个 PID 的事件触发帧和无条件帧对应的第一个字节数据是相同的，即，如果从机的数据已更新，则它会做出响应，其受保护的ID位于第一个数据字节中。当多个从机同时响应时，它们各自的应答信号会在总线上产生叠加，造成电压水平异常。由于LIN总线的物理层特性，主机能够通过检测这种电压水平的变&#x2F;response_error来识别出，发生了冲突。</p>
</li>
<li><p>偶发帧</p>
<p>偶发帧是主机节点在同一帧时隙中，当自身信号发生变化时向总线发送的帧。当存在多个关联的应答信号变化时，通过预先设定的优先级来仲裁。偶发帧主要用于<mark>主机发送</mark>不经常变化的信息，可以理解为主机用的事件触发帧。与事件触发帧类似，偶发帧也定义了一组无条件帧。规定：偶发帧只有由主机节点发布。</p>
<p>主机节点上面也有信息需要告诉从机节点，当主机节点检测到某个无条件帧的信号发生变化时，它会在适当的时机（即偶发帧的时隙）将这个变化发送出去。</p>
</li>
<li><p>诊断帧</p>
<p>包括主机请求帧和从机应答帧，主要用于配置、识别和诊断。</p>
<ul>
<li><p>主机请求帧ID&#x3D;0x3C，应答部分的发布节点为主机节点；</p>
</li>
<li><p>从机应答帧ID&#x3D;0x3D，应答部分的发布节点为从机节点。</p>
</li>
<li><p>数据场规定为8个字节，一律采用标准效验和。</p>
</li>
</ul>
</li>
</ol>
<h2 id="偶发帧"><a href="#偶发帧" class="headerlink" title="偶发帧"></a>偶发帧</h2><p>偶发帧的传输可能出现 3 种状况：</p>
<ol>
<li><p>当关联的无条件帧没有信号发生变化时，该时隙保持沉默，<mark>主机节点</mark>连帧头都不需要发送；</p>
</li>
<li><p>当其中一个关联的无条件帧包含的信号发生了变化， 则<mark>发送</mark>该关联的无条件帧的<mark>应答部分</mark>，如图15上半部分所示；</p>
</li>
<li><p>如果有两个或以上关联的无条件帧包含的信号发生了变化，则按照事先规定好的优先级，优先级较高的关联的无条件帧获得发送权，优先级较低的要等到下一个偶发帧的帧头到来时才能<mark>发送</mark>应答。由于<mark>主机节点是唯一的发布节点</mark>，所以主机节点事先就知道各个关联信号的优先级别，这样在传输时不会产生冲突，如图15下半部分所示。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017222307.png"></p>
<h1 id="调度表"><a href="#调度表" class="headerlink" title="调度表"></a>调度表</h1><p>调度表规定了总线上帧的传输次序以及传输时间。调度表位于主机节点，主机任务根据应用程序需要进行调度。</p>
<p>调度表可以有多个，一般情况下，轮到某个调度表执行的时候，从该调度表的入口处开始执行，到调度表的最后一个帧时，如果没有新的调度表启动则返回到当前调度表的第一个帧开始执行；也有可能在执行到某个调度表时发生中断，跳到另一个调度表后再返回，如事件触发帧就是典型的例子。</p>
<h2 id="主机状态机"><a href="#主机状态机" class="headerlink" title="主机状态机"></a>主机状态机</h2><p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017222347.png"></p>
<p>在总线开始工作时，主机随即启动主机任务，周期性地执行调度表（Schedule）规定的消息发送程序。下表示意LIN总线调度表的内容，在调度表中包括各项消息 PID（Message Header）和启动时间。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017222408.png"></p>
<h2 id="从机状态机"><a href="#从机状态机" class="headerlink" title="从机状态机"></a>从机状态机</h2><p>从机任务负责发布或者接听帧的应答状态，包括连两个状态机：同步间隔段与同步段检查器、帧处理器。</p>
<p>从机任务状态机中，检测同步间隔段和同步段序列，要求节点处于任何状态下都能识别出该序列，包括已经检测到序列或进入帧处理的状态。</p>
<p>帧处理包括接收并分析PID，接收数据，接收校验和，发送数据和发送校验和，对接收到的受保护ID进行分析，按照事先的设计，选择是接收应答部分，还是发送应答部分，或不接收也不发送。在五个子状态中，如果收到同步间隔段或同步段序列，将重新跳到“接收并分析PID”的子状态，通信不停止，根据需要置位相应的错误标志。</p>
<h1 id="帧传输时间"><a href="#帧传输时间" class="headerlink" title="帧传输时间"></a>帧传输时间</h1><p>在消息调度中，协议为单条消息定义 Slot 的概念，Slot持续的时间必须大于帧头（Frame Header）和消息应答（Response）的时间以保证消息传送完毕。单个帧总是在同一个Slot内传输完的。考虑到收发器性能的影响，LIN协议规定单个消息传输时间有40%裕量，即帧的最小持续时间为其典型持续时间的1.4倍。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017222504.png"></p>
<p>若同步间隔段是 13 bit 显性位 + 1 bit 隐性位，则帧头计 34 bit。应答包括数据段和校验和段，根据数据段长度的不同，应答最短为 20 bit（数据段 1 Byte），应答最长为 90 bit（数据段 8 Byte）。综上， LIN总线的帧最长为 124 bit（数据段 8 Byte），最短为 54 bit（数据段 1 Byte）。</p>
<p>帧的额定传输时间计算公式如下</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017222531.png"></p>
<p>LIN协议规定帧的最大传输时间为额定传输时间的 1.4 倍，即为帧传输预留 40% 的裕量。该特性是考虑到总线上节点设备性能参差不齐，允许节点不必收到指令后立即执行。也就是说，协议允许节点推迟下一个 UART 字符的发送。</p>
<p>帧的最大传输时间计算公式如下：</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017222553.png"></p>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>协议强制规定， 每个从机节点都要在它发布的某个无条件帧中包含一个长度为一位的标量信号 response_error，向主机节点报告自身状态。 主机节点负责接收这个信号并且执行分析，如下表所示。事件触发帧由于允许总线冲突，需特殊处理。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017222622.png"></p>
<p>LIN 协议并没有标准化错误类型，用户可根据需要自行制定。 下表列出了可能出现的一些错误类型供参考。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017222644.png"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.wangdali.net/lin/">http://www.wangdali.net/lin/</a></p>
<p><a href="https://blog.csdn.net/dailbing/article/details/124248328">https://blog.csdn.net/dailbing/article/details/124248328</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/357967013">https://zhuanlan.zhihu.com/p/357967013</a></p>
<p><a href="https://news.eeworld.com.cn/qrs/article_2018012444047.html">https://news.eeworld.com.cn/qrs/article_2018012444047.html</a></p>
]]></content>
      <categories>
        <category>汽车与工业网络</category>
      </categories>
      <tags>
        <tag>LIN</tag>
      </tags>
  </entry>
  <entry>
    <title>个人学习分享</title>
    <url>/2025/prefix%20remember%20to%20change!!!-3bef8c1b86a0/</url>
    <content><![CDATA[<h1 id="关于学习的思考"><a href="#关于学习的思考" class="headerlink" title="关于学习的思考"></a>关于学习的思考</h1><p>我认为的高效学习：在有限时间内，精准获取所需知识，并能有效内化和应用。</p>
<p>我对学习的看法：知识是学不完的，论学习能力也比不上AI。我的观点是面向问题学习，让AI成为认知加速器。</p>
<p>AI是认知的杠杆： 将AI视为研究助理、翻译器、知识连接器和初稿生成器，可以大幅提升工作效率。比如：</p>
<ul>
<li><p>客户邮件翻译</p>
</li>
<li><p>需求文档的翻译和理解</p>
</li>
</ul>
<p>传统的翻译，翻译完后，也不一定能够理解对方想表达的意思。AI翻译不只是翻译，还会做出解释，这样效率更高。</p>
<h1 id="高效获取信息与知识"><a href="#高效获取信息与知识" class="headerlink" title="高效获取信息与知识"></a>高效获取信息与知识</h1><p><strong>信息源选择</strong></p>
<p>获取信息&#x2F;资料的信息源：官方文档 &gt; 官方论坛 &gt; 博客&#x2F;论文。 官方文档包括：</p>
<ul>
<li><p>官方网站的文档区域</p>
</li>
<li><p>SDK&#x2F;软件包，其中的 <code>README</code>、 <code>docs</code>、 <code>example</code>等目录</p>
</li>
<li><p>官方源代码仓库（GitHub 等）中的文档文件</p>
</li>
<li><p>官方提供的 API 参考</p>
</li>
<li><p>官方入门教程和指南</p>
</li>
</ul>
<p><strong>利用公司资源</strong></p>
<p>内部Wiki、知识库、过往项目文档。比如飞书云文档，可以在里面搜索想要了解的知识。</p>
<p><strong>利用AI找资料</strong></p>
<p>比如：项目需要使用共享内存，实现MCU和SOC之间的数据交互。</p>
<p>以<code>KIMI</code>为例，找资料的时候，要打开接入互联网功能，不开的话，因为训练大模型使用的数据不是最新的，有些东西可能找不到。打开接入互联网的功能，就会通过互联网搜索资料。如果使用的AI工具不支持联网功能，不建议用来找资料。长思考主要用来分析一些复杂问题，如果只是收集信息，可以打开也可以不开。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017205152.png"></p>
<ol>
<li><p>假设项目用的芯片是TI的芯片。首先询问TI德州仪器的官网网址是多少？我们可以从回答里面看到阅读了哪些网页，展开后可以看看网页标题和简介，哪些与我们要找的信息强相关，可以点击对应的链接看看。<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017205235.png"></p>
</li>
<li><p>进入官网，在最底部可以找到官方论坛。<img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017205324.png"></p>
</li>
<li><p>在官方论坛搜索IPC rpmsg相关的帖子，里面会有一些意想不到的收获。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017205415.png"></p>
</li>
<li><p>基于官网和官方论坛找资料。找软件安装包的下载地址也是一样的方法。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017205511.png"></p>
</li>
<li><p>rpmsg原理资料收集。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017205551.png"></p>
</li>
<li><p>了解基本概念后，继续了解实现流程。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017205634.png"></p>
</li>
<li><p>在有一定的概念后，再去尝试寻找代码示例，这样才能准确表达想要找的东西是什么。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017205710.png"></p>
<p>最终引用的是官方论坛里面的一个帖子，上面的回复有提到一个demo的仓库地址。所以说官方论坛的帖子也是很重要的，有些资料藏得很深，只有TI的开发&#x2F;员工能找得到。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251017205732.png"></p>
</li>
</ol>
<p>最终收集信息如下：</p>
<ul>
<li><p>MCU SDK介绍文档： <a href="https://software-dl.ti.com/mcu-plus-sdk/esd/AM62AX/09_02_00_38/exports/docs/api_guide_am62ax/IPC_GUIDE.html">Understanding inter-processor communication (IPC)</a></p>
</li>
<li><p>SOC SDK介绍文档：<a href="https://software-dl.ti.com/processor-sdk-linux/esd/AM62AX/latest/exports/docs/linux/Foundational_Components_IPC62ax.html">3.7. IPC for AM62ax &mdash; Processor SDK AM62Ax Documentation</a></p>
</li>
<li><p>官方论坛：<a href="https://e2e.ti.com/search?q=ipc&category=forum">Search - TI E2E support forums</a></p>
</li>
<li><p>代码示例：<a href="https://git.ti.com/cgit/rpmsg/rpmsg_char_zerocopy/">https://git.ti.com/cgit/rpmsg/rpmsg_char_zerocopy&#x2F;</a></p>
</li>
<li><p>高质量技术博客&#x2F;论文：<a href="https://openamp.readthedocs.io/en/latest/protocol_details/index.html">OpenAMP Design Details &mdash; OpenAMP documentation</a></p>
</li>
</ul>
<h1 id="学习习惯"><a href="#学习习惯" class="headerlink" title="学习习惯"></a>学习习惯</h1><p>流程：收集 -&gt; 速览(建框架) -&gt; 主题聚焦 -&gt; 精读(核心) -&gt; 即时笔记(防忘) -&gt; 整理(内化)。 </p>
<p><strong>第一阶段：广泛收集与初步吸收</strong></p>
<ul>
<li><p>行动： 围绕目标主题，广泛收集相关资料（遵循信息源优先级：官方文档 &gt; 官方论坛 &gt; 博客&#x2F;论文）。</p>
</li>
<li><p>方法： 对所有收集的资料进行快速通读，目标是：</p>
<ul>
<li><p>建立整体印象和知识框架。</p>
</li>
<li><p>识别核心概念、关键特性和潜在难点。</p>
</li>
<li><p>此阶段不求深度理解，重在扫盲和定位。</p>
</li>
</ul>
</li>
</ul>
<p><strong>第二阶段：聚焦主题，深度理解</strong></p>
<ul>
<li><p>方法：采用主题阅读法</p>
<ul>
<li><p>速览定位：快速浏览多个来源的目录、图表、摘要和章节标题，锁定与主题相关的核心章节。</p>
</li>
<li><p>精读核心：集中精力深入阅读与当前学习目标最相关、最重要的核心章节（如实现原理、协议机制、关键特性）。</p>
</li>
</ul>
</li>
<li><p>核心原则： 深度优先，聚焦核心，避免在非关键信息上过度耗时。</p>
</li>
</ul>
<p><strong>第三阶段：即时输出，强化记忆与理解</strong></p>
<ul>
<li><p>行动：边学边记</p>
<ul>
<li><p>重要性： 在阅读精读核心内容的同时，强制自己输出笔记。 避免遗忘。</p>
</li>
<li><p>形式： 不拘泥于完美结构，想到什么写什么，优先记录：</p>
<ul>
<li><p>关键概念的定义。</p>
</li>
<li><p>核心原理、机制的理解（用自己的话复述）。</p>
</li>
<li><p>重要的命令、API、配置片段（直接复制代码&#x2F;命令）。</p>
</li>
<li><p>产生的疑问和思考。</p>
</li>
</ul>
</li>
<li><p>心态： 接受此时的笔记可能是草稿或碎片化，目标是即时捕捉想法和知识点。</p>
</li>
</ul>
</li>
</ul>
<p><strong>第四阶段：应用与迭代</strong></p>
<ul>
<li><p>行动：事后整理</p>
<ul>
<li><p>时机：已经应用到实际项目上，基本掌握该知识&#x2F;技能时，整理总结，加深理解。</p>
</li>
<li><p>目标：将碎片化笔记整理成结构化、易检索、有价值的笔记。</p>
</li>
</ul>
</li>
</ul>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p><strong>笔记工具</strong></p>
<p>飞书云文档，支持双向链接，方便知识关联、更新和分享，还可以利用AI速览，总结笔记重点。</p>
<p><strong>信息获取</strong></p>
<p>通用对话AI (认知加速核心)：</p>
<ul>
<li><p>官方DeepSeek：不符合公司安全规范，需要注意使用场景，项目资料等信息需要保密。<a href="%5Bhttps://chat.deepseek.com/%5D(https://chat.deepseek.com/)"><a href="https://chat.deepseek.com/">https://chat.deepseek.com/</a></a></p>
</li>
<li><p>Kimi：不符合公司安全规范，需要注意使用场景，项目资料等信息需要保密。<a href="%5Bhttps://www.kimi.com/%5D(https://www.kimi.com/)"><a href="https://www.kimi.com/">https://www.kimi.com/</a></a></p>
</li>
</ul>
<p>聚合类：<a href="https://www.aigc.cn/#term-1903">https://www.aigc.cn/#term-1903</a></p>
<p><strong>AI 的幻觉&#x2F;错误</strong></p>
<p>永远保持批判性思维！ AI的输出不一定都是正确的。AI是助手，我们才是决策者和责任人，可以同时向多个AI提出相同的问题，对比判断。</p>
]]></content>
      <categories>
        <category>个人成长</category>
      </categories>
      <tags>
        <tag>学习方法</tag>
      </tags>
  </entry>
  <entry>
    <title>IPC共享内存调试</title>
    <url>/2025/prefix%20remember%20to%20change!!!-25bc31419109/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>由于 RPMsg 一次只能传递 496 字节的信息(在Linux系统中，RPMsg的最大大小包括16字节的头部，因此消息的有效载荷大小为512 - 16 &#x3D; 496字节)，而CAN升级过程中需要传输的数据量是很大的，这样会很影响升级速率。因此，考虑在共享内存区域中传递大量数据，这样会更加高效。</p>
<p>参考 <code>RPMsg_char zerocopy</code> 示例，了解如何定义一个共享内存区域来在 Linux 和远程核心之间传递数据，然后使用 <code>RPMsg</code> 作为信号机制，在共享内存区域准备好读取时通知另一个核心。</p>
<h1 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h1><h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><p>IPC代表“处理器间通信”。IPC可以是处理器核心之间的任何形式的通信。TI AM62Ax可以支持多种IPC实现。</p>
<p><strong>IPC涉及核心</strong>：A53，MCU R5F，DM R5F 硬件支持的IPC特性：</p>
<ol>
<li><p>Interrupt：中断通常是从一个处理器核心传输信息到另一个处理器核心的最快方式。</p>
</li>
<li><p>Mailbox：将邮箱想象为与32位寄存器配对的中断信号。IPC Notify机制就是使用邮箱实现。</p>
</li>
<li><p>Spinlock：自旋锁可以用来协调对共享资源的访问。这有助于同步在不同处理器核心上运行的软件。</p>
</li>
</ol>
<p><strong>轮询与中断</strong></p>
<p>处理器核心接收来自另一核心信息的两种主要方法是：</p>
<ul>
<li><p>轮询：接收核心，手动检查更新的信息</p>
</li>
<li><p>中断：接收核心，继续运行自己的软件，直到被中断（通常由中断或邮箱触发）</p>
</li>
</ul>
<p>一些核心结合了硬件中断和软件轮询。在这种情况下，接收到硬件中断，处理器核心必须手动轮询核心的中断控制器（INTC），以查看是否接收到中断，并处理任何额外的信息（如触发了哪个中断）。</p>
<p><strong>内存</strong></p>
<p>可以为以下内容分配DDR或片上内存区域：</p>
<ul>
<li><p>IPC协议</p>
<ul>
<li>IPC RPMsg</li>
</ul>
</li>
<li><p>共享内存区域</p>
<ul>
<li><p>共享内存区域由发送核心直接写入，并由接收核心读取</p>
</li>
<li><p>共享内存区域可以小到一个 32 位字，也可以大到足以容纳千字节或兆字节的数据</p>
</li>
</ul>
</li>
</ul>
<p><strong>延迟与吞吐量</strong></p>
<ul>
<li><p>平均延迟：平均而言，IPC可能需要在特定时间内完成</p>
</li>
<li><p>最坏情况延迟：IPC可能需要始终在特定时间内完成</p>
</li>
<li><p>数据吞吐量：可能需要在特定时间内在核心之间传输一定量的数据</p>
</li>
</ul>
<p>许多设计对IPC有特定要求，一般来说：</p>
<ul>
<li><p>中断、邮箱（IPC Notify）：低延迟，低数据吞吐量</p>
</li>
<li><p>IPC RPMsg：易于实现，但没有针对延迟或吞吐量进行优化</p>
</li>
<li><p>共享内存区域：更高的延迟，更高的数据吞吐量</p>
</li>
</ul>
<p><strong>IPC SW Architecture</strong></p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251018204356.png"></p>
<p><strong>IPC设计模式</strong></p>
<p>以下是使用IPC RP消息在“client-serve”模式下的一个典型设计模式。</p>
<ol>
<li><p>server端</p>
<p>一个服务器CPU通常提供某些服务，例如进行一些计算或读取某个传感器，</p>
<ul>
<li><p>服务器创建一个RP消息端点，一个端点是任何16位数字，然而在实现中，限制为<code>RPMESSAGE_MAX_LOCAL_ENDPT </code>，以便实现低内存占用，并且仍然保持高效能。</p>
</li>
<li><p>一个端点在某种程度上类似于UDP中的端口，而CPU ID在某种程度上类似于IP地址。因此，给定一个CPU ID和该CPU上的端点，任何其他CPU都可以向其发送消息或数据包。这个端点值对于所有希望与其通信的CPU来说是预先知道的，他们也知道所提供的服务的性质。</p>
</li>
<li><p>然后，服务器在这个端点等待接收消息。当它收到一条消息时，消息包指示要执行的操作，通常是通过包的命令ID来指示。</p>
</li>
<li><p>包还包含特定于命令的参数。参数需要适应包缓冲区，如果参数数量很大或参数本身是大量数据，则包缓冲区内的参数应该指向另一个更大的共享内存，该共享内存保存实际数据或附加参数。</p>
</li>
<li><p>作为接收到的消息的一部分，服务器还知道发送者CPU ID和发送者回复端点。处理完消息后，服务器可以向发送者发送一个包括处理结果的“确认”消息，它本身就是另一个消息包，它可以有命令状态和返回参数。</p>
<p>服务器CPU可以创建多个端点，每个端点提供逻辑上不同的服务。使用单独的RTOS任务来等待给定端点上接收的消息是一个非常常见的设计选择。</p>
</li>
</ul>
</li>
<li><p>client端</p>
<p>一个客户端CPU可以向上述服务器端点发送消息，</p>
<ul>
<li><p>创建一个RP消息端点来接收“确认”消息。这个端点可以是任何值，不需要与服务器端点匹配。</p>
</li>
<li><p>调用发送API，传入服务器CPU ID、服务器端点ID和回复端点ID。</p>
</li>
<li><p>发送API填充要发送的包，其中填充了要执行的命令和命令的参数。发送包后，等待回复。收到回复后，处理回复状态和结果。</p>
</li>
</ul>
</li>
</ol>
<p>类似的设计模式也可以用于IPC Notify，只是在这种情况下，消息包只能是一个28位的消息值。而且端点值必须小于 <code>IPC_NOTIFY_CLIENT_ID_MAX</code>。</p>
<h2 id="RPmsg"><a href="#RPmsg" class="headerlink" title="RPmsg"></a>RPmsg</h2><p>RPMsg是一种标准化的IPC协议。RPMsg创建作为共享内存的VRING缓冲区，发送核心将RPMsg消息放入VRING缓冲区，然后使用邮箱或中断通知接收核心有消息等待。VRING 共享内存地址由 Linux 设备树中的值确定，并放置在 DDR 中。</p>
<p><strong>IPC实现</strong></p>
<p>RPMsg可用于MCU+核心之间的通信，或用于Linux与运行MCU+ SDK的核心之间的通信。</p>
<p>TI为MCU核心和Linux核心提供了RPMsg驱动程序，以及仅适用于MCU核心的IPC Notify驱动程序。</p>
<ol>
<li><p>IPC Notify</p>
<p>IPC Notify运行在MCU+核心上（FreeRTOS或裸机&#x2F;NORTOS）。IPC Notify只能用于运行MCU+ SDK的核心之间的通信。TI不支持使用IPC Notify与Linux交互。</p>
<p>优点：低延迟，通过使用邮箱，IPC Notify能够在MCU+核心之间实现微秒级的延迟。</p>
</li>
<li><p>IPC RPMsg and Linux RPMsg</p>
<ul>
<li><p>IPC RPMsg运行在MCU+核心上。</p>
</li>
<li><p>Linux RPMsg运行在Linux上。</p>
</li>
</ul>
</li>
</ol>
<p><strong>IPC RPMsg具体细节</strong></p>
<ul>
<li><p>MCU+ core to MCU+ core</p>
<ul>
<li><p>消息大小和消息缓冲区数量是可配置的</p>
</li>
<li><p>共享内存可以在DDR或内部存储器中</p>
</li>
</ul>
</li>
<li><p>MCU+ core to Linux core</p>
<ul>
<li><p>消息大小和消息缓冲区数量是固定的</p>
</li>
<li><p>共享内存在DDR中</p>
</li>
</ul>
</li>
</ul>
<p><strong>Linux RPMsg具体细节</strong></p>
<p>Linux RPMsg驱动程序可以从Linux用户空间（例如，Linux应用程序）或从Linux内核空间（例如， Linux驱动程序）启用RPMsg。Linux RPMsg旨在易于使用，而不是优化延迟或数据吞吐量。</p>
<ul>
<li><p>共享内存在DDR中而不是内部存储器中</p>
</li>
<li><p>固定的RPMsg数据包大小。总数据包大小为512字节，496字节的数据，16字节的头</p>
</li>
<li><p>Linux用户空间不直接读取VRING缓冲区。相反，数据被多次复制以在Linux用户空间和远程核心之间传输。</p>
</li>
</ul>
<p><strong>RPmsg协议介绍见</strong>：</p>
<p><a href="https://www.jianshu.com/p/c7cdad8273ed">RPMsg：协议简介 - 简书</a></p>
<p><a href="https://www.cnblogs.com/mic-chen/p/18217210">核间通信：RPMsg和OpenAMP - Mic_chen - 博客园</a></p>
<p><a href="https://openamp.readthedocs.io/en/latest/protocol_details/index.html">OpenAMP Design Details — OpenAMP documentation</a></p>
<p><a href="https://blog.csdn.net/qq_21438461/article/details/142793235">【核间通讯】深入解析 Virtio 和 RPMsg：多处理器通信的开放标准与应用实践-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/huang987246510/article/details/103739592">VirtIO实现原理——vring数据结构-CSDN博客</a></p>
<p><a href="https://oenhan.com/virtio-vring">virtIO vring工作机制分析 | OenHan</a></p>
<p><a href="https://cloud.tencent.com/developer/article/2395658">多核异构通信框架（RPMsg-Lite）-腾讯云开发者社区-腾讯云</a></p>
<h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p><code>RPMsg_char zerocopy</code> 这个仓库，展示了如何使用 <code>rpmsg_char</code>API 在 Linux 主机和远程 M4F 或 R5F MCU 端点之间传递共享内存数据。</p>
<p>仓库地址：<a href="https://git.ti.com/cgit/rpmsg/rpmsg_char_zerocopy/">rpmsg&#x2F;rpmsg_char_zerocopy</a></p>
<ul>
<li><p>master分支：适用 Linux 内核 6.6 或更高版本（SDK 10.x）。</p>
</li>
<li><p>ti-linux-6.1 分支：适用 Linux 内核 5.10（SDK 8.x）或 Linux 内核 6.1（SDK 9.x）。</p>
</li>
<li><p>linux目录：基于通用 Linux 的 <code>rpmsg_char</code>示例。</p>
</li>
<li><p>rtos目录：包含了针对 AM64x&#x2F;R5F、AM62x&#x2F;M4F 和 AM62Ax&#x2F;C71&#x2F;R5F 的 FreeRTOS 部分示例。</p>
</li>
</ul>
<p>查看Linux 内核版本，可以在终端或命令行界面中使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251018204603.png"></p>
<h2 id="Demo流程说明"><a href="#Demo流程说明" class="headerlink" title="Demo流程说明"></a>Demo流程说明</h2><ol>
<li><p>Linux端用指定的数据填充共享内存缓冲区。在访问 <code>mmapped </code>区域前后使用<code>DMA_BUF_IOCTL_SYNC</code>ioctl进行非常基础的缓存一致性管理。</p>
</li>
<li><p>将缓冲区的物理地址、缓冲区大小和填充的固定数据通过rpmsg发送到远程端点(MCU)，并开始等待响应。</p>
</li>
<li><p>远程MCU将验证缓冲区数据，然后反转数据，用新数据填充缓冲区，并发送响应。</p>
</li>
<li><p>当Linux收到来自远程端点的消息时，验证与远程端共享的内存中的模式。</p>
</li>
</ol>
<p>注意：填充共享内存缓冲区，也就是往共享内存写数据后，对端是不知道应用程序什么时候写的。所以在这里，rpmsg其实起到了通知的作用，实际上是产生了邮箱或中断通知，否则就需要轮询检查是否有新的数据。</p>
<p>这个示例与 ipc_rpmsg_echo_linux 示例类似，有几个关键的不同点：</p>
<ul>
<li><p>创建了一个单一的 rpmsg 端点，用于与用户空间 Linux <code>rpmsg_char</code> 应用程序通信。</p>
</li>
<li><p>通过 rpmsg 通道交换包含共享内存描述符的⼆进制消息。共享数据位于共享内存中，不通过rpmsg 通道交换。</p>
</li>
<li><p>不与其他 CPU 交换任何消息。</p>
</li>
</ul>
<h2 id="API说明"><a href="#API说明" class="headerlink" title="API说明"></a>API说明</h2><h3 id="Typedef说明"><a href="#Typedef说明" class="headerlink" title="Typedef说明"></a>Typedef说明</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(* RPMessage_RecvCallback)</span> <span class="params">(RPMessage_Object *obj, <span class="type">void</span> *arg, <span class="type">void</span></span></span><br><span class="line"><span class="params">*data, <span class="type">uint16_t</span> dataLen, <span class="type">uint16_t</span> remoteCoreId, <span class="type">uint16_t</span> remoteEndPt)</span></span><br><span class="line">`RPMessage_RecvCallback` 是一个回调函数类型定义，它在从指定的本地端点接收到任何CPU发</span><br><span class="line">送的消息时被调用。</span><br><span class="line"></span><br><span class="line">这个回调函数可以在 `RPMessage_construct` 期间选择性注册。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">回调函数中必须处理所有消息内容。当回调函数返回时，消息缓冲区会被释放回发送者。</span><br><span class="line">如果需要延迟处理消息内容，则需要复制消息内容。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">`obj` [in] 使用 `RPMessage_construct` 创建的RPMessage端点对象。</span><br><span class="line">`arg` [in] 用户在 `RPMessage_construct` 期间指定的参数。</span><br><span class="line">`data` [in] 指向消息的指针。</span><br><span class="line">`dataLen` [in] 消息的⻓度。</span><br><span class="line">`remoteCoreId` [in] 发送方的核ID。</span><br><span class="line">`remoteEndPt` [in] 发送方的端点。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(* RPMessage_RecvNotifyCallback)</span> <span class="params">(RPMessage_Object *obj, <span class="type">void</span></span></span><br><span class="line"><span class="params">*arg)</span></span><br><span class="line">`RPMessage_RecvNotifyCallback` 是一个回调函数类型定义，它在从指定的本地端点接收到任何</span><br><span class="line">CPU发送的消息时被调用。</span><br><span class="line"></span><br><span class="line">这个回调函数可以在 `RPMessage_construct` 期间选择性注册。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">与 `RPMessage_RecvCallback` 不同，这个回调函数仅通知有一条或多条消息待读取，</span><br><span class="line">但消息本身不会被驱动程序读取，除非在该回调函数中或之后的某个任务中调用了</span><br><span class="line">`RPMessage_recv`。</span><br><span class="line">如果设置了 `RPMessage_RecvCallback`，则不会使用 `RPMessage_RecvNotifyCallback` 回</span><br><span class="line">调函数。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">`obj` [in] 使用 `RPMessage_construct` 创建的RPMessage端点对象。</span><br><span class="line">`arg` [in] 用户在 `RPMessage_construct` 期间指定的参数。</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(* RPMessage_ControlEndPtCallback)</span> <span class="params">(<span class="type">void</span> *arg, <span class="type">uint16_t</span></span></span><br><span class="line"><span class="params">remoteCoreId, <span class="type">uint16_t</span> remoteEndPt, <span class="type">const</span> <span class="type">char</span> *remoteServiceName)</span></span><br><span class="line">`RPMessage_ControlEndPtCallback` 是一个回调函数类型定义，在控制端点上接收到通知消息</span><br><span class="line">时调用的回调。</span><br><span class="line"></span><br><span class="line">这个回调函数可以在 `RPMessage_init` 期间选择性注册。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">与 `RPMessage_RecvCallback` 类似，回调函数中必须处理所有消息内容。</span><br><span class="line">当回调函数返回时，消息缓冲区会被释放回发送者。如果需要延迟处理消息内容，则需要复制消息内</span><br><span class="line">容。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">`arg` [in] 用户在 `RPMessage_init` 期间指定的参数。</span><br><span class="line">`remoteCoreId` [in] 发送方的核ID。</span><br><span class="line">`remoteEndPt` [in] 在控制端点上宣布服务的发送者的端点。</span><br><span class="line">`remoteServiceName` [in] 被宣布的远程服务的名称。</span><br></pre></td></tr></table></figure>

<h3 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RPMessage_Params_init</span><span class="params">(RPMessage_Params * params)</span></span><br><span class="line"></span><br><span class="line">`<span class="title function_">RPMessage_Params_init</span><span class="params">()</span>` 函数用于为 `RPMessage_Params` 结构体设置默认值。</span><br><span class="line">参数：</span><br><span class="line">`params` [out] 需要被初始化为默认值的结构体。</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RPMessage_CreateParams_init</span><span class="params">(RPMessage_CreateParams * params)</span></span><br><span class="line"></span><br><span class="line">`<span class="title function_">RPMessage_CreateParams_init</span><span class="params">()</span>` 函数用于为 `RPMessage_CreateParams` 结构体设置默</span><br><span class="line">认值。 </span><br><span class="line">参数：</span><br><span class="line">`params` [out] 需要被初始化为默认值的结构体。</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">RPMessage_init</span><span class="params">(<span class="type">const</span> RPMessage_Params * params)</span></span><br><span class="line"></span><br><span class="line">`<span class="title function_">RPMessage_init</span><span class="params">()</span>` 函数用于初始化 RPMessage 模块。</span><br><span class="line">参数：</span><br><span class="line">`params` [in] 初始化参数。</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RPMessage_deInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"></span><br><span class="line">`<span class="title function_">RPMessage_deInit</span><span class="params">()</span>` 函数用于反初始化 RPMessage 模块。</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">RPMessage_waitForLinuxReady</span><span class="params">(<span class="type">uint32_t</span> timeout)</span></span><br><span class="line"></span><br><span class="line">`<span class="title function_">RPMessage_waitForLinuxReady</span><span class="params">()</span>` 函数用于等待 Linux 端的 RPMessage 准备就绪。</span><br><span class="line">在启用了 Linux 端的 RPMessage 之前，不应该向 Linux 发送消息，直到这个函数返回成功。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">当在 RTOS/非RTOS 核心之间使用 RPMessage 时，不需要调用这个 API。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">`timeout` [in] 超时时间，以系统时钟周期为单位。</span><br><span class="line">返回值：</span><br><span class="line">`SystemP_SUCCESS`，表示 Linux 端的 RPMessage 已经初始化完成。</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RPMessage_controlEndPtCallback</span><span class="params">(RPMessage_ControlEndPtCallback</span></span><br><span class="line"><span class="params">controlEndPtCallback,</span></span><br><span class="line"><span class="params"><span class="type">void</span> * controlEndPtCallbackArgs</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line"></span><br><span class="line">`<span class="title function_">RPMessage_controlEndPtCallback</span><span class="params">()</span>` 函数用于设置一个回调，当在控制端点接收到控制消息</span><br><span class="line">时调用。</span><br><span class="line">参数：</span><br><span class="line">`controlEndPtCallback` [in] 用户定义的回调函数，当控制消息到达时将被调用。</span><br><span class="line">`controlEndPtCallbackArgs` [in] 传递给用户控制端点回调的参数。</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">RPMessage_construct</span><span class="params">(RPMessage_Object * obj,</span></span><br><span class="line"><span class="params"><span class="type">const</span> RPMessage_CreateParams * createParams</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line"></span><br><span class="line">`<span class="title function_">RPMessage_construct</span><span class="params">()</span>` 函数用于创建一个 RPMessage 对象，以便在指定的端点接收消息。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">- 每个新创建的对象必须有一个唯一的本地端点。</span><br><span class="line">- 本地端点必须小于 `RPMESSAGE_MAX_LOCAL_ENDPT`。</span><br><span class="line">- 用户必须选择一个值，不支持使用 ANY 值。</span><br><span class="line">- 如果在 `RPMessage_CreateParams` 中注册了回调，则不能使用 `RPMessage_recv`。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">`obj` [out] 创建的对象。</span><br><span class="line">`createParams` [in] 创建对象时的参数。</span><br><span class="line">返回值：</span><br><span class="line">`SystemP_SUCCESS` 表示成功，否则表示失败。</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RPMessage_destruct</span><span class="params">(RPMessage_Object * obj)</span></span><br><span class="line"></span><br><span class="line">`<span class="title function_">RPMessage_destruct</span><span class="params">()</span>` 函数用于删除之前创建的 RPMessage 对象。</span><br><span class="line">参数：</span><br><span class="line">`obj` [in] 要删除的对象。</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RPMessage_unblock</span><span class="params">(RPMessage_Object * obj)</span></span><br><span class="line"></span><br><span class="line">`<span class="title function_">RPMessage_unblock</span><span class="params">()</span>` 函数用于解除对输入对象的 `RPMessage_recv` 调用的阻塞，如果它</span><br><span class="line">正在等待消息并且用户想要退出该任务。</span><br><span class="line">参数：</span><br><span class="line">`obj` [in] 要解除阻塞的对象。</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">RPMessage_getLocalEndPt</span><span class="params">(<span class="type">const</span> RPMessage_Object * obj)</span></span><br><span class="line"></span><br><span class="line">`<span class="title function_">RPMessage_getLocalEndPt</span><span class="params">()</span>` 函数用于返回一个 `RPMessage_Object` 的本地端点。</span><br><span class="line">返回的值将与之前创建该对象时使用的值相同。</span><br><span class="line">参数：</span><br><span class="line">`obj` [in] 对象。</span><br><span class="line">返回值：</span><br><span class="line">输入对象的本地端点。</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">RPMessage_announce</span><span class="params">(<span class="type">uint16_t</span> remoteProcId,</span></span><br><span class="line"><span class="params"><span class="type">uint16_t</span> localEndPt,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> * name</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line"></span><br><span class="line">`<span class="title function_">RPMessage_announce</span><span class="params">()</span>` 函数用于向远程核心宣告一个本地端点，该端点上创建了一个服务。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">- 宣告端点是可选的，IPC RPmessage不会以任何方式内部使用它。</span><br><span class="line">- 用户必须逐个向所有感兴趣的远程核心宣告。没有向所有核心宣告的选项。</span><br><span class="line">- 为了处理宣告消息，确保用户在 `RPMessage_init` 期间通过 `RPMessage_Params` 注册了</span><br><span class="line">用户处理程序。</span><br><span class="line">- 由最终用户决定如何使用回调来发出信号或等待直到远程服务被宣告。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">`remoteProcId` [in] 要宣告的远程核心。</span><br><span class="line">`localEndPt` [in] 正在宣告的服务的本地端点。</span><br><span class="line">`name` [in] 正在宣告的服务的名称。</span><br><span class="line">返回值：</span><br><span class="line">如果宣告消息已发送，则返回 `SystemP_SUCCESS`，否则表示失败。</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">RPMessage_send</span><span class="params">(<span class="type">void</span> * data,</span></span><br><span class="line"><span class="params"><span class="type">uint16_t</span> dataLen,</span></span><br><span class="line"><span class="params"><span class="type">uint16_t</span> remoteCoreId,</span></span><br><span class="line"><span class="params"><span class="type">uint16_t</span> remoteEndPt,</span></span><br><span class="line"><span class="params"><span class="type">uint16_t</span> localEndPt,</span></span><br><span class="line"><span class="params"><span class="type">uint32_t</span> timeout</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line"></span><br><span class="line">`<span class="title function_">RPMessage_send</span><span class="params">()</span>` 函数用于向指定远程端点的远程核心发送消息。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">- `dataLen` 必须小于等于RPMessage_Params::vringMsgSize - 16字节，以留出内部头部的</span><br><span class="line">空间。</span><br><span class="line">- 为了让远程核心能够接收到消息，远程核心上要有一个与 `remoteEndPt` 相同值的端点。</span><br><span class="line">- `localEndPt` 不是必需的，但是这个值在远程核心上是可用的，并且可以用作回复端点。使用</span><br><span class="line">`RPMessage_getLocalEndPt` 来设置监听回复的 RPMessage 对象的本地端点。</span><br><span class="line">- 当超时时间设置为 0 时，如果不可用的传输缓冲区，将⽴即返回 `SystemP_TIMEOUT`。否则，</span><br><span class="line">它将等待指定的超时时间，直到有可用的传输缓冲区。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">`data` [in] 要发送的消息数据的指针。</span><br><span class="line">`dataLen` [in] 要发送的消息数据的大小。</span><br><span class="line">`remoteCoreId` [in] 消息被发送到的远程核心ID。</span><br><span class="line">`remoteEndPt` [in] 消息被发送到的远程核心端点ID。</span><br><span class="line">`localEndPt` [in] 发送消息的本地端点。</span><br><span class="line">`timeout` [in] 等待时间，以系统时钟周期为单位。</span><br><span class="line">返回值：</span><br><span class="line">`SystemP_SUCCESS`，当发送消息成功时返回。</span><br><span class="line">`SystemP_TIMEOUT`，由于没有可用的传输缓冲区且超时发生，消息未被发送。</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">RPMessage_recv</span><span class="params">(RPMessage_Object * obj,</span></span><br><span class="line"><span class="params"><span class="type">void</span> * data,</span></span><br><span class="line"><span class="params"><span class="type">uint16_t</span> * dataLen,</span></span><br><span class="line"><span class="params"><span class="type">uint16_t</span> * remoteCoreId,</span></span><br><span class="line"><span class="params"><span class="type">uint32_t</span> * remoteEndPt,</span></span><br><span class="line"><span class="params"><span class="type">uint32_t</span> timeout</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line"></span><br><span class="line">`<span class="title function_">RPMessage_recv</span><span class="params">()</span>` 函数是一个阻塞式 API，直到在指定的本地端点接收到来自任何CPU的消</span><br><span class="line">息。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">- 本地端点在 `RPMessage_construct` 期间指定。</span><br><span class="line">- 如果注册了回调，则不应使用此 API。</span><br><span class="line">- 用户传递的 `dataLen` 包含用户消息缓冲区的大小，即指向 `data` 的缓冲区大小。如果接收</span><br><span class="line">到的消息大小超过了 `*dataLen`，则会被截断。如果接收到的消息大小小于等于 `*dataLen`，则</span><br><span class="line">所有接收到的字节都会被复制到 `data` 中，并且 `*dataLen` 表示 `data` 中有效字节的大</span><br><span class="line">小。</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">`obj` [in] 使用 `RPMessage_construct` 创建的RPMessage端点对象。</span><br><span class="line">`data` [in] 指向接收到的消息内容的指针。</span><br><span class="line">`dataLen` [in] 用户消息缓冲区的⻓度，以字节为单位。</span><br><span class="line">[out] 接收到的消息的大小，以字节为单位。</span><br><span class="line">`remoteCoreId` [out] 发送方的核ID。</span><br><span class="line">`remoteEndPt` [out] 发送方的端点。</span><br><span class="line">`timeout` [in] 阻塞等待消息接收的时间，以系统时钟周期为单位。</span><br><span class="line">返回值：</span><br><span class="line">- `SystemP_SUCCESS`，接收到新消息，所有输出参数都是有效的。</span><br><span class="line">- `SystemP_TIMEOUT`，由于超时，API被解除阻塞，输出参数不应被使用。</span><br></pre></td></tr></table></figure>

<p><strong>API for Task</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TaskP_Params_init</span><span class="params">(TaskP_Params * params)</span></span><br><span class="line"></span><br><span class="line">`<span class="title function_">TaskP_Params_init</span><span class="params">()</span>` 函数用于为 `TaskP_Params` 结构体设置默认值。</span><br><span class="line">强烈建议在设置 `TaskP_Params` 中的值之前调用此函数。</span><br><span class="line">参数：</span><br><span class="line">`params` [out] 要设置为默认值的参数结构体。</span><br><span class="line"></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">TaskP_construct</span><span class="params">(TaskP_Object * obj,</span></span><br><span class="line"><span class="params">TaskP_Params * params</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line"></span><br><span class="line">`<span class="title function_">TaskP_construct</span><span class="params">()</span>` 函数用于创建一个任务对象。</span><br><span class="line">参数：</span><br><span class="line">`obj` [out] 创建的对象。</span><br><span class="line">`params` [in] 创建任务的参数。</span><br><span class="line">返回值：</span><br><span class="line">如果成功，返回 `SystemP_SUCCESS`。</span><br><span class="line">如果出错，返回 `SystemP_FAILURE`。</span><br></pre></td></tr></table></figure>

<h2 id="共享内存的使用"><a href="#共享内存的使用" class="headerlink" title="共享内存的使用"></a>共享内存的使用</h2><p>使用共享内存的通讯方式，数据是不通过 rpmsg 通道交换的，rpmsg主要起通知作用，并传递共享内存描述的相关信息。这一条通知消息，可以和其他rpmsg的处理区分开，也可以不区分，主要有几种方式：</p>
<ol>
<li><p>不新增 RPMessage 对象，和其他rpmsg一起处理，那么需要增加自定义交互协议，来交换包含共享内存描述的相关信息；</p>
</li>
<li><p>调用 <code>RPMessage_construct</code>创建一个新的 RPMessage 对象，和其他rpmsg分开处理。根据输入参数区分不同的RPMessage对象，做不同的处理。</p>
</li>
</ol>
<p><mark>注意：每个新创建的对象必须有一个唯一的本地端点。</mark></p>
<p>假如之前已经用了14端点，共享内存的RPMessage对象可以用16端点。这就需要在项目中添加多个端点。</p>
<p><strong>如何在MCU项目中添加多个RPMsg端点？</strong></p>
<p><a href="https://dev.ti.com/tirex/explore/node?node=A__AcOC0VpHUlAvx.sBVgyDVQ__AM62A-ACADEMY__WeZ9SsL__LATEST">TI Resource Explorer</a></p>
<p>实际上就是应用了下面的补丁：</p>
<p><a href="https://dev.ti.com/tirex/explore/content/am62ax_academy_10_01_00_00/_build_am62ax_academy_10_01_00_00/_downloads/8572acd8118b2273bb40546f07e38f56/0001-Linux_RPMsg_Echo-add-additional-endpoints.patch"><code>Linux_RPMsg_Echo-add-additional-endpoints.patch</code></a></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="ASSERT"><a href="#ASSERT" class="headerlink" title="ASSERT"></a>ASSERT</h3><p>在之前代码的基础上，把demo的代码移植过去，增加一个任务后，出现了断言，如下图:</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251018205540.png"></p>
<p>在 <code>queue.c </code>文件 <code>xQueueSemaphoreTake </code>函数1582行，<code>configASSERT</code>断言 <code>QueueHandle_t xQueue </code>是否为空。</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251018205603.png"></p>
<p>出现断言打印，说明传了NULL。全局搜索没有直接调用 <code>xQueueSemaphoreTake </code>的地方，用的是<code>xSemaphoreTake </code>这个宏。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> xSemaphoreTake( xSemaphore, xBlockTime ) xQueueSemaphoreTake( (</span></span><br><span class="line">xSemaphore ), ( xBlockTime ) )</span><br></pre></td></tr></table></figure>

<p>使用的地方比较多，所以下一步要定位，是新增加了哪个函数调用，导致该问题。</p>
<p>最终定位是新加的任务，调用 <code>RPMessage_recv</code>函数出现的这个问题。</p>
<p>问题在于<code>RPMessage_recv</code>使用了，未经过<code>RPMessage_construct</code>创建的RPMessage对象。</p>
<p><strong>代码分析</strong></p>
<p>详细分析见注释。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IPC_RPMESSAGE_ENDPT_CHRDEV_PING (14U)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MCU_IPC_RECV_OBJ (1)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 在初始化的阶段，RPMessage_construct函数会创建一个RPMessage对象gIpcRecvMsgObject[1]，</span></span><br><span class="line"><span class="comment">* 用来在IPC_RPMESSAGE_ENDPT_CHRDEV_PING端点接收消息。</span></span><br><span class="line"><span class="comment">* 然后会调用SemaphoreP_constructBinary创建一个⼆进制信号量对象。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">RPMessage_CreateParams_init(&amp;createParams);</span><br><span class="line">createParams.localEndPt = IPC_RPMESSAGE_ENDPT_CHRDEV_PING;</span><br><span class="line">status = RPMessage_construct(&amp;gIpcRecvMsgObject[MCU_IPC_RECV_OBJ],</span><br><span class="line">&amp;createParams);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Create the tasks which will handle the ping service */</span></span><br><span class="line">TaskP_Params_init(&amp;taskParams);</span><br><span class="line">taskParams.name = <span class="string">&quot;RPMESSAGE_CHAR_ZEROCOPY&quot;</span>;</span><br><span class="line">taskParams.stackSize = IPC_RPMESSAGE_TASK_STACK_SIZE;</span><br><span class="line">taskParams.<span class="built_in">stack</span> = gIpcTaskStack[<span class="number">0</span>];</span><br><span class="line">taskParams.priority = IPC_RPMESSAFE_TASK_PRI;</span><br><span class="line"><span class="comment">/* we use the same task function for echo but pass the appropiate rpmsg</span></span><br><span class="line"><span class="comment">handle to it, to echo messages */</span></span><br><span class="line">taskParams.args = &amp;gIpcRecvMsgObject[<span class="number">0</span>];<span class="comment">//gIpcRecvMsgObject[0]作为参数传递给</span></span><br><span class="line">ipc_recv_task_main</span><br><span class="line">taskParams.taskMain = ipc_recv_task_main;</span><br><span class="line">status = TaskP_construct(&amp;gIpcTask[<span class="number">0</span>], &amp;taskParams);</span><br><span class="line">DebugP_assert(status == SystemP_SUCCESS);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ipc_recv_task_main</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32_t</span> status;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_buf</span> <span class="title">ibuf</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">uint16_t</span> recvMsgSize, remoteCoreId;</span><br><span class="line">    <span class="type">uint32_t</span> remoteCoreEndPt;</span><br><span class="line">    RPMessage_Object *pRpmsgObj = (RPMessage_Object *)args;</span><br><span class="line"></span><br><span class="line">    DebugP_log(<span class="string">&quot;[IPC RPMSG ZEROCOPY] Remote Core waiting for messages at endpoint %d ... !!!\r\n&quot;</span>,RPMessage_getLocalEndPt(pRpmsgObj));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* wait for messages forever in a loop */</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Set &#x27;recvMsgSize&#x27; to size of recv buffer, after return`recvMsgSize`</span></span><br><span class="line"><span class="comment">        * contains actual size of valid data in recv buffer.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        recvMsgSize = <span class="keyword">sizeof</span>(ibuf);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 前面在初始化的时候，创建的RPMessage对象是gIpcRecvMsgObject[1]，</span></span><br><span class="line"><span class="comment">        * 而gIpcRecvMsgObject[0]并没有做创建处理，对应的信号量是NULL。</span></span><br><span class="line"><span class="comment">        * 那么，在任务里面，gIpcRecvMsgObject[0]作为输入参数传给RPMessage_recv之后，</span></span><br><span class="line"><span class="comment">        * 会调用RPMessage_getEndPtMsg。当消息队列为空时，调用SemaphoreP_pend等待一个信号量对象</span></span><br><span class="line"><span class="comment">        * 或锁定一个互斥锁，最终调用xSemaphoreTake，检测信号量为NULL，于是出现了断言。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        status = RPMessage_recv(pRpmsgObj,</span><br><span class="line">                    &amp;ibuf, &amp;recvMsgSize,</span><br><span class="line">                    &amp;remoteCoreId, &amp;remoteCoreEndPt,</span><br><span class="line">                    SystemP_WAIT_FOREVER);</span><br><span class="line">        DebugP_assert(status==SystemP_SUCCESS);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MPU"><a href="#MPU" class="headerlink" title="MPU"></a>MPU</h3><p>MCU无法访问SOC发过来的地址，具体表现为，对地址进行读&#x2F;写操作，MCU会挂掉。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">IPC message: buffer address 0xXXXX, size 1M, pattern 0xaaaa5555</span><br></pre></td></tr></table></figure>

<p>可能原因有：</p>
<ol>
<li><p>内存权限和属性：R5F核可能没有足够的权限访问该内存区域，或者内存属性（如执行、写入、读取等）可能没有正确配置。检查共享内存区域的权限和属性设置。</p>
</li>
<li><p>内存对齐：如果共享内存的地址或大小没有正确对齐，可能会导致访问错误。</p>
</li>
</ol>
<p>实际排查是因为没有访问权限，MPU里面没有对相应内存区域进行设置，需要在syscfg设置如下：</p>
<p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251018210125.png"></p>
<h1 id="核间同步"><a href="#核间同步" class="headerlink" title="核间同步"></a>核间同步</h1><p>两个CPU核同时访问同一个共享内存区域，如何实现同步，实现资源互斥访问是一个需要重点考虑的问题。</p>
<p><a href="https://blog.csdn.net/lyd0813/article/details/126825378">核间通信（IPC）的两种解决方案-CSDN博客</a></p>
<p>第一种通信的同步方案：</p>
<p>使用virtIO来实现，详见RPMSG-VirtIO。前面多次提到一次只能传递 496 字节的信息。</p>
<p>第⼆种通信的同步方案：</p>
<p><strong>方案工作流程</strong></p>
<ol>
<li><p>R5F核写入共享内存：</p>
<ul>
<li><p>R5F核准备好数据后，将数据写入到共享内存的指定位置。</p>
</li>
<li><p>R5F核通过RPMsg发送一个消息给A53核，通知它数据已经写入完成。</p>
</li>
<li><p>这个消息可以通过核间中断来触发A53核的处理，解除其阻塞状态。</p>
</li>
<li><p>可以将多个数据包批量写入共享内存，然后通过RPMsg通知一次，减少中断的频率，提升性能。</p>
</li>
</ul>
</li>
<li><p>A53核读取数据：</p>
<ul>
<li><p>A53核在收到中断后从阻塞状态恢复，读取共享内存中R5F核写入的数据。</p>
</li>
<li><p>数据处理完后，A53核发送RPMsg通知R5F核操作完成。</p>
</li>
</ul>
</li>
</ol>
<p>同样，A53也可以通过类似的方式（共享内存写入 -&gt; RPMsg 通知）将数据写给R5F核。</p>
<p><strong>优点</strong></p>
<ol>
<li><p>同步精确：通过核间中断来通知对方核，可以做到精确的同步，这种方式减少了忙等(不像自旋锁那样忙等)。</p>
</li>
<li><p>同步机制简单：不需要复杂的锁来控制共享内存的访问权限。因为在每个核被通知后才会进行读写操作，避免了数据竞争。</p>
</li>
<li><p>减少CPU开销：通过阻塞等待和通知机制，避免了轮询式的资源检查，大大减少了CPU资源的浪费。</p>
</li>
<li><p>减少中断频率：通过批量写入共享内存，能够减少核间中断的频率，降低处理器之间的通信开销。RPMsg只在批量数据处理完后触发一次通知，从而提高效率。</p>
</li>
</ol>
<p><strong>需要注意的点</strong></p>
<ol>
<li><p>共享内存的一致性：需要手动清除缓存，确保两个核访问的是同样的数据。</p>
</li>
<li><p>RPMsg 通知的延迟：核间中断和RPMsg通常比较高效，但仍需要关注实际场景中的通知延迟，尤其是在高频率通信场景下。</p>
</li>
</ol>
<p><strong>优化思考</strong></p>
<ol>
<li><p>双缓冲机制：使用双缓冲，保证读写操作互不影响。例如，当R5F核写入时，A53核可以读取另一块缓冲区，减少读写等待的时间。</p>
</li>
<li><p>异步处理机制：如果接收方的处理速度较慢，可能会影响整个数据传输的吞吐量。在这种情况下，可以考虑让接收方异步处理接收到的数据，而不阻塞发送方的后续传输。当然，异步机制需要更复杂的同步控制。</p>
</li>
</ol>
<p><strong>说明</strong></p>
<p>一个核心不同的task，访问同一个共享内存区域，也要考虑资源访问问题。</p>
<h1 id="共享内存划分"><a href="#共享内存划分" class="headerlink" title="共享内存划分"></a>共享内存划分</h1><p>假设共享内存传输的数据，都用同样一块地址空间。因为升级数据不是写一次就通知soc，是写满之后才通知，那么在升级数据传输过程中，如果有其他功能，需要使用共享内存来传输数据，会导致之前升级包的数据被覆盖。考虑到这种场景(实际可能不会这么操作)，可以对共享内存划分不同的区域。</p>
<h2 id="物理地址说明"><a href="#物理地址说明" class="headerlink" title="物理地址说明"></a>物理地址说明</h2><p><img src="https://raw.githubusercontent.com/xianren-WRD/Picture/main/img/20251018210408.png"></p>
<ol>
<li><p>上面接口获取的是soc app申请的内存的物理地址，而不能简单认为是一个首地址，它可以不是首地址。如果soc app上电初始化之后，去申请内存，并且永远只申请一次(要考虑申请的大小，是申请一整个区域，还是其他)，那么由于内存空间都是空闲的，此时的物理地址就是首地址。或者可以每次申请并在使用完后释放，那么下次再去申请，应该也还是首地址。</p>
</li>
<li><p>soc app是把申请的内存的fd， 通过 <code>mmap</code>函数把一个文件映射到进程的地址空间中，这样就可以直接通过内存操作来访问文件内容，也就是操作的就是app申请的空间。那么调用<code>dmabuf_get_phys</code>，获取到申请的内存的物理地址之后，发给mcu，这样两边访问的就是同一块地方。</p>
</li>
</ol>
<h1 id="TI官方资料"><a href="#TI官方资料" class="headerlink" title="TI官方资料"></a>TI官方资料</h1><p><a href="https://software-dl.ti.com/mcu-plus-sdk/esd/AM62AX/09_02_00_38/exports/docs/api_guide_am62ax/IPC_GUIDE.html">AM62Ax MCU+ SDK: Understanding inter-processor communication (IPC)</a></p>
<p><a href="https://software-dl.ti.com/processor-sdk-linux/esd/AM62AX/latest/exports/docs/linux/Foundational_Components_IPC62ax.html?highlight=rpmsg">3.7. IPC for AM62ax — Processor SDK AM62Ax Documentation</a></p>
<p><a href="https://software-dl.ti.com/jacinto7/esd/processor-sdk-rtos-jacinto7/06_02_00_21/exports/docs/psdk_rtos_auto/docs/user_guide/developer_notes_ipc.html">8.5. Developing IPC applications — Processor SDK RTOS Automotive</a></p>
]]></content>
      <categories>
        <category>异构多核通信</category>
      </categories>
      <tags>
        <tag>共享内存</tag>
        <tag>TI AM62A</tag>
      </tags>
  </entry>
</search>
